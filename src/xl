#!/usr/bin/env python

from __future__ import print_function

DEBUG_TARGET  = "ncurses_debug"

NATIVE_TARGET = "ncurses"

C64_EMULATOR = "x64"
VIC20_EMULATOR = "xvic"
PLUS4_EMULATOR = "xplus4"
PET_EMULATOR = "xpet"

MAME_EMULATOR = "mame"

import shutil

import os,sys,re

import time

import re


from os import walk

sys.path.append("assets")

from import_from_source import *

from tiles import *

from strings import *

from collections import OrderedDict


platform = sys.platform

global NATIVE_EXTENSION

# if(platform in ["cygwin", "linux", "linux2", "darwin", "msys", "msys2", "win32"]):
    # GNU_MAKE="make"
# else:
    # GNU_MAKE="gmake"


if(platform in ["cygwin", "msys"]):
    NATIVE_EXTENSION="exe"
else:
    NATIVE_EXTENSION="out"


COMMANDS_DESCRIPTIONS = OrderedDict( \
    {
    # "add": "adds targets to a project", \
    "assets": "builds assets from tile and/or shape files", \
    "build": "builds a project", \
    "check": "it checks dependencies", \
    "clean": "cleans binary files generated by a project", \
    "clone": "clones a project", \
    "commands" :"list all commands",  \
    "compilers": "check present compilers", \
    "config": "displays the configuration", \
    "create": "creates a new project",  \
    "debug": "builds the native version of a project in debug mode", \
    "delete": "completely deletes a project", \
    "extend": "generates non-8x8 shapes from 8x8 shapes", \
    "files": "shows all generated binary files", \
    "help": "provides help on a command or topic", \
    "import": "imports tiles from (Assembly/BASIC) files", \
    "list": "lists all projects", \
    "make": "build project using shape files", \
    "manual": "prints the manual", \
    "rebuild": "generates assets and builds a project", \
    # "remove": "removes targets from a project", \
    "rename": "renames a project", \
    "reset": "deletes graphics assets", \
    "rip": "rips Assembly or BASIC listings to produce tiles", \
    "rotate": "rips Assembly or BASIC listings to produce rotated tiles", \
    "run": "runs a project", \
    "self": "test xl script", \
    "shapes": "generates tiles from shapes", \
    "show": "shows tiles of a project as shapes", \
    "size": "builds the native version of a project with a given size", \
    "split": "splits a shape file in left and right shape", \
    "string": "produces case-sensitive strings as Cross-Lib characters macros", \
    "test": "runs some tests", \
    "tile": "converts a shape file into a tile", \
    "tools": "builds the tools", \
    "unit-tests": "run unit-tests",
    })

COMMANDS_LIST = COMMANDS_DESCRIPTIONS.keys()


SHORT_COMMANDS_LIST = OrderedDict( \
    { \
        "c": "clean", \
        "d": "debug", \
        "f": "file", \
        "m": "make", \
        "h": "help", \
        "l": "list", \
        "f": "files", \
        "r": "rebuild", \
        "x": "run", \
        "t": "test"
    })


def all_compilers_opts(zsdcc_extra_optimization, compiler_opts):

    if z88dk_compiler == 'zsdcc' or z88dk_compiler == 'sdcc':
        compiler_selection = " -compiler=sdcc "
        compiler_opts = compiler_opts + " " + zsdcc_compiler_opts
    elif z88dk_compiler == 'ez80clang' or z88dk_compiler == 'clang':
        compiler_selection = " -compiler=ez80clang "
        compiler_opts = compiler_opts
    else:
        compiler_selection = ""
        compiler_opts = compiler_opts + " " + sccz80_compiler_opts 
        

    return " ZSDCC_MAKEFILE_COMPILATION_OPTS='" + zsdcc_compiler_opts + " " + zsdcc_extra_optimization + "'" + \
           " Z88DK_MAKEFILE_COMPILATION_OPTS='" + z88dk_compiler_opts + compiler_opts + compiler_selection + "'" + \
           " GCC4TI99_MAKEFILE_COMPILATION_OPTS='" + gcc4ti99_compiler_opts + "'" + \
           " NATIVE_MAKEFILE_COMPILATION_OPTS='" + native_compiler_opts + "'" + \
           " CMOC_MAKEFILE_COMPILATION_OPTS='" + cmoc_compiler_opts + "'" + \
           " CC65_MAKEFILE_COMPILATION_OPTS='" + cc65_compiler_opts + "'" + \
           " LCC1802_MAKEFILE_COMPILATION_OPTS='" + lcc1802_compiler_opts + "'"


def run_command_verbosely(command_string):
    if global_vars.verbose: 
        print("Going to run: ")
        printc(bcolors.BOLD, command_string+"\n")
    else:
        command_string+= " > /dev/null 2>&1"

    os.system(command_string)


def generic_input(str):
    if sys.version_info[0] < 3:
        return raw_input(str)
    else:
        return input(str)

def are_you_sure():
    return generic_input("Are you sure [Y/N]? ").lower()


def files_in_path(mypath):
    files = []
    for (dirpath, dirnames, filenames) in walk(mypath):
        files.extend(filenames)
        break
    return files


def multiple_project_rebuild(params):

    mypath = params[0]
    target = params[1]
    
    if(len(params)>=3):
        reset_opts = [params[2]]
    else:
        reset_opts = []
    
    projects = []
    for (dirpath, dirnames, filenames) in walk(mypath):
        projects.extend(dirnames)
        break
            
    for project_name in projects:
        print("\n")
        print("PROJECT: " + project_name)
        print("\n")
        reset([mypath, project_name]+reset_opts)
        build([mypath, project_name, target])


def multiple_reset(mypath):
    projects = []
    for (dirpath, dirnames, filenames) in walk(mypath):
        projects.extend(dirnames)
        break
            
    for project_name in projects:
        print("PROJECT: " + project_name)
        reset([mypath, project_name])
        print("\n")


def multiple_size_build(mypath,target,xsize,ysize,debug):
    projects = []
    for (dirpath, dirnames, filenames) in walk(mypath):
        projects.extend(dirnames)
        break
        
    if use_tools:
        use_tools_str = " USE_TOOLS=1 "
    else:
        use_tools_str = "" 
        
    for project_name in projects:
    
        if(is_project_split(project_name)):
            project_type = project_category(project_name)
            create_main(project_name,project_type)
        make_command = \
            GNU_MAKE + " " + target + use_tools_str + " XSIZE=" + xsize +  " YSIZE=" + ysize + " _DEBUG_FLAG=" + str(debug) + \
                " _NATIVE_CC=" + native_compiler + " " + all_compilers_opts("","") + " GNU_MAKE=" + GNU_MAKE + \
                " TOOL_CC=" + tool_compiler + \
                " -f " + mypath+"/"+project_name+"/Makefile."+project_name;
                
        run_command_verbosely(make_command)
        if(is_project_split(project_name)):
            delete_main(project_name,project_type)

#TODO: cc65 targets 
#TODO: cmoc targets
#TODO: lcc1802 targets
#TODO: mc10 (6303)
#TODO: c128 (complicated because of c1541)
#TODO: cpc (complicated because of nocart)
PARALLEL_TARGETS = \
    [
    'stdio', 
    
    'ncurses',
    
    'ace',
    'agon',
    'aquarius',
    'camputers_lynx', 
    'cpm',
    'coleco',
    'gb',
    'gal',
    'gamegear',
    'kc85',
    'laser500',
    'm100',
    'mc1000',
    'mc1000_mono',
    'microbee',
    'msx',
    'mtx500',
    'mtx512',
    'mz',
    'pc8201',
    'pc88',
    'samcoupe',
    'sc3000',
    'sc3000_rom',
    'sg1000',
    'sms',
    'spectrum',
    't200',
    'trs80',
    'vg5k',
    'vz200',
    'zx81',
    'zx81_wrx',
    'zx81_8x6',   
    'zx81_wrx64',
    'zx81_8x6_wrx64',
    'zx81_wrx128',
    'zx81_8x6_wrx128',
    'z9001',
    'kc',
    'z1013'
    ]

def multiple_build(mypath,target,threads,zsdcc_extra_optimization):
    projects = []
    
    if use_tools:
        use_tools_str = " USE_TOOLS=1 "
    else:
        use_tools_str = ""   
    
    for (dirpath, dirnames, filenames) in walk(mypath):
        projects.extend(dirnames)
        break
    
    projects_to_build = len(projects)

    # files_before = len(files_in_path("../build"))-1
    if global_vars.verbose:
        print("Building " + str(projects_to_build) + " projects: ", end="")
        for project_name in projects:
            printc(bcolors.OKCYAN,project_name+" ")
        print("")

    if (parallelize_multi_build==1) and (target in PARALLEL_TARGETS):
        pool = Pool(processes=int(threads))

        for project_name in projects:
            if(is_project_split(project_name)):
                project_type = project_category(project_name)
                create_main(project_name,project_type)
            make_command = \
                GNU_MAKE + " " + target + use_tools_str + \
                    " ZSDCC_MAKEFILE_THREADS_OPTS=\'-j " + threads + "'" \
                    + all_compilers_opts(zsdcc_extra_optimization, "") + \
                    " _NATIVE_CC=" + native_compiler + \
                    " TOOL_CC=" + tool_compiler + " GNU_MAKE=" + GNU_MAKE + \
                    " -f " + mypath+"/"+project_name+"/Makefile."+project_name;
            pool.apply_async(run_command_verbosely, [make_command])
        
        pool.close()
        pool.join()

        for project_name in projects:
            if(is_project_split(project_name)):
                delete_main(project_name,project_type)        
    else:
        for project_name in projects:
            if(is_project_split(project_name)):
                project_type = project_category(project_name)
                create_main(project_name,project_type)
            make_command = \
                GNU_MAKE + " " + target + use_tools_str + \
                    " ZSDCC_MAKEFILE_THREADS_OPTS=\'-j " + threads + "'" \
                    + all_compilers_opts(zsdcc_extra_optimization, "") + \
                    " _NATIVE_CC=" + native_compiler + \
                    " TOOL_CC=" + tool_compiler + " GNU_MAKE=" + GNU_MAKE + \
                    " -f " + mypath+"/"+project_name+"/Makefile."+project_name;

            run_command_verbosely(make_command)
            if(is_project_split(project_name)):
                delete_main(project_name,project_type)




# Run a project natively (terminal with ncurses) with a given XSize and YSize
def size(params,debug):

    if len(params)<2:
        game_dir = "helloworld"
    else:
        game_dir = params[1]

    project_type = project_category(game_dir)

    parent_dir = project_type + "s"

    if len(params)<5:
        xsize = params[2]
        ysize = params[3]
        target = NATIVE_TARGET
    else:
        xsize = params[3]
        ysize = params[4]
        target = params[2]

    if target in [NATIVE_TARGET,'stdio']:
        target = target + '_sized'

    if global_vars.verbose:

        print("Project name       : " + game_dir)
        print("Project type       : " + project_type)
        print("XSize: " + xsize)
        print("YSize: " + ysize)
        print("target: " + target)

    parent_and_game_dir = parent_dir + "/" + game_dir

    files_before = len(files_in_path("../build"))-1


    if(game_dir not in ["games", "examples", "projects", "all"]):
        if not os.path.exists(parent_and_game_dir):
            print("Project not found!")
            return

        if is_project_split(game_dir):
            printc(bcolors.OKBLUE,"Create main.c from split source files\n")
            create_main(game_dir, project_type)
        make_command = \
            GNU_MAKE + " " + target + " XSIZE=" + xsize +  " YSIZE=" + ysize + " _DEBUG_FLAG=" + str(debug) + " " \
                + all_compilers_opts("","") + \
                " _NATIVE_CC=" + native_compiler + \
                " TOOL_CC=" + tool_compiler + \
                " -f " + parent_dir+"/"+game_dir+"/Makefile."+game_dir;
        run_command_verbosely(make_command)
        
        if is_project_split(game_dir):
            printc(bcolors.OKBLUE,"Delete main.c (because of split source files)\n")
            delete_main(game_dir, project_type)        
    else:
        if game_dir in["games","examples","projects"]:
            multiple_size_build(game_dir,target,xsize,ysize,debug)
        elif game_dir in["new"]:
            multiple_size_build("projects",target,xsize,ysize,debug)
        elif game_dir in["builtin","built-in"]:
            multiple_size_build("games",target,xsize,ysize,debug)
            multiple_size_build("examples",target,xsize,ysize,debug)
        elif game_dir=="all":
            multiple_size_build("games",target,xsize,ysize,debug)
            multiple_size_build("examples",target,xsize,ysize,debug)
            multiple_size_build("projects",target,xsize,ysize,debug)
        else:
            return

    files_after = len(files_in_path("../build"))-1
    
    if global_vars.verbose:
        print("New binaries built: " + str(files_after-files_before)+"\n")



# Rebuild a project, i.e., also rebuilds assets
def rebuild(params):
    game_dir = params[1]

    if game_dir=="new":
        game_dir = "projects"

    # project_groups = 

    if game_dir in ["games","examples","projects"]:
        # print([game_dir]+params[2:])
        multiple_project_rebuild([game_dir]+params[2:]) #, target, reset_opts)
        return
    elif game_dir in ["builtin","built-in"]:
        multiple_project_rebuild(["games"]+params[2:])
        multiple_project_rebuild(["examples"]+params[2:])
        return
    elif game_dir=="all":
        multiple_project_rebuild(["games"]+params[2:])
        multiple_project_rebuild(["examples"]+params[2:])
        multiple_project_rebuild(["projects"]+params[2:])
        return
    
    reset(params)
    # if(params[len(params)-1]=="-y"):
        # build(params[:-1])
    # else:
        
    build(params)




def convert_makefile(dir,old_type,old_name,new_name):

    dest_path = "projects/"+dir
    source_game_dir = old_name
    target_game_dir = new_name
    source_parent_dir = old_type
    target_parent_dir = "projects"
    
    if global_vars.verbose:
        print("- dir: " + dir)
        print("- old_type: " + old_type)
        print("- old_name: " + old_name)
        print("- new_game: " + new_name)
    
    fin = open("./"+dest_path+"/Makefile."+source_game_dir, "rt")
    data = fin.read()
    data = data.replace('CROSS-' + source_game_dir.upper(),'CROSS-'+target_game_dir.upper())
    data = data.replace('GAME_NAME := ' + source_game_dir, 'GAME_NAME := '+target_game_dir)
    data = data.replace('PARENT_DIR = ' + source_parent_dir + "s", 'PARENT_DIR = ' + target_parent_dir)

    data = data.replace('include ./' + old_type + "s/" + source_game_dir, 'include ./projects/' + target_game_dir)
    fin.close()
    fin = open("./"+dest_path+"/Makefile."+target_game_dir, "wt")
    fin.write(data)
    fin.close()
    
    os.remove("./"+dest_path+"/Makefile."+source_game_dir)


# Rename a project
def rename(params):
    if len(params)<2:
        source_game_dir = "helloworld"
    else:
        source_game_dir = params[1]
        
    if len(params)<3:
        print("ERROR: You need to provide more paramaters")
        return
        
    target_game_dir = params[2]
            
    source_project_type = project_category(source_game_dir)
    source_parent_dir = source_project_type + "s"
    source_parent_and_game_dir = source_parent_dir + "/" + source_game_dir

    if source_project_type != "project":
        return

    target_project_type = "project"
    target_parent_dir = target_project_type + "s"
    target_parent_dir_and_game_dir = target_parent_dir + "/" + target_game_dir
    
    if global_vars.verbose:

        print("source_project_type: " + source_project_type)
    
    convert_makefile(source_game_dir, source_project_type, source_game_dir, target_game_dir)
    
    os.rename(target_parent_dir + "/" +source_game_dir, target_parent_dir_and_game_dir)


# Clone a project to create a new one
def clone(params):
    if len(params)<2:
        source_game_dir = "helloworld"
    else:
        source_game_dir = params[1]
        
    if len(params)<3:
        return
        
    target_game_dir = params[2]
        
        
    source_project_type = project_category(source_game_dir)
    if global_vars.verbose:
        print("source project category: " + source_project_type)
    source_parent_dir = source_project_type + "s"
    source_parent_and_game_dir = source_parent_dir + "/" + source_game_dir

    target_project_type = "project"
    target_parent_dir = target_project_type + "s"
    target_parent_dir_and_game_dir = target_parent_dir + "/" + target_game_dir

    if global_vars.verbose:
        print("Source project name    : " + source_game_dir)
        print("Source Project type    : " + source_project_type)
        print("Path to source project : " + source_parent_and_game_dir)
        print("")
        print("Target project name    : " + target_game_dir)
        print("target Project type    : " + target_project_type)
        print("Path to target project : " + target_parent_dir_and_game_dir)

    # if not os.path.exists(target_parent_dir_and_game_dir):
        # print("Creating project dir...")
        # os.makedirs(target_parent_dir_and_game_dir)

    source_path = source_parent_and_game_dir
    if global_vars.verbose:
        print("source_path: " + source_path)
    dest_path = target_parent_dir_and_game_dir
    if global_vars.verbose:
        print("dest_path: " + dest_path)

    if not os.path.exists(dest_path+"/tiles"):
        if global_vars.verbose:
            print("Copying tiles...")
        shutil.copytree(source_path, dest_path)

    if not os.path.exists(dest_path+"/generated_assets"):
        if global_vars.verbose:
            print("Create empty generated_assets directory...")
        os.makedirs(dest_path+"/generated_assets")

    convert_makefile(target_game_dir, source_project_type, source_game_dir, target_game_dir)


# Generate tools from source code
def tools():
    make_command = \
        GNU_MAKE + " -j " + compilation_threads + " tools TOOL_CC=" + tool_compiler + " GNU_MAKE=" + GNU_MAKE + " -f makefiles.common/auxiliary/Makefile_tools"
    run_command_verbosely(make_command)
        

def create_main(game_dir, project_type):
    parent_dir_path = "./" + project_type + "s/"
    project_dir_path = parent_dir_path + game_dir + "/"
    split_dir_path = project_dir_path + "split_files/"

    # run_command_verbosely("cat " + split_dir_path + "*.c > " + project_dir_path + "main.c")
    os.system("cat " + split_dir_path + "*.c > " + project_dir_path + "main.c")


def delete_main(game_dir, project_type):
    parent_dir_path = "./" + project_type + "s/"
    project_dir_path = parent_dir_path + game_dir + "/"
    run_command_verbosely("rm -rf " + project_dir_path + "main.c")

# TODO: This should be replaced by a real check on the existence of the split_files directory
# SPLIT_PROJECTS = ['chase','shoot','snake']

def is_project_split(game_dir):
    project_type = project_category(game_dir)
    parent_dir_path = "./" + project_type + "s/"
    project_dir_path = parent_dir_path + game_dir + "/"
    
    # return game_dir in SPLIT_PROJECTS
    return os.path.isdir(project_dir_path+"split_files")

# Build a project (for a target or multiple targets)
def build(params):
    
    if len(params)<2:
        game_dir = "helloworld"
    else:
        game_dir = params[1]

    if len(params)>=1 and game_dir=="tools":
        tools()
    else:

        files_before = len(files_in_path("../build"))-1

        project_type = project_category(game_dir)
        parent_dir = project_type + "s"

        if len(params)<3:
            target = "ncurses"
        else:
            target = params[2]

        if len(params)<4:
            threads = str(compilation_threads)
        else:
            threads = params[3]

        if len(params)>=5 and params[4]=="on":
            zsdcc_extra_optimization = "--max-allocs-per-node200000"
        else:
            zsdcc_extra_optimization = ""

        if len(params)>=6:
            compiler_opts = " " + params[5]
        else:
            compiler_opts = ""

        if global_vars.verbose:

            print("Project name       : ", end="")
            printc(bcolors.BOLD, game_dir+"\n")
            
            print("Target name        : ", end="")
            printc(bcolors.UNDERLINE, target+"\n")

            print("Project type       : " + project_type)
            print("Number of threads  : " + threads)
            print("Extra optimization : " + zsdcc_extra_optimization)
            print("Compiler's options : " + compiler_opts)
            
            print("--------------------------")
            print("z88dk_compiler_opts     : " + z88dk_compiler_opts)
            print("zsdcc_compiler_opts     : " + zsdcc_compiler_opts)
            print("cmoc_compiler_opts      : " + cmoc_compiler_opts)
            print("cc65_compiler_opts      : " + cc65_compiler_opts) 
            print("lcc1802_compiler_opts   : " + lcc1802_compiler_opts) 
            print("gcc4ti99_compiler_opts  : " +  gcc4ti99_compiler_opts)
            print("native_compiler_opts    : " +  native_compiler_opts)
            
            print("")

        parent_and_game_dir = parent_dir + "/" + game_dir
        
        if os.path.exists(parent_and_game_dir + "/config.ini"):
            print("Local config.ini detected")
            read_config(parent_and_game_dir + "/config.ini")
        # else:
            # print("Use general config.ini")
            # read_config()


        if(game_dir not in ["games", "examples", "projects", "all"]):
            if not os.path.exists(parent_and_game_dir):
                print("Project not found!")
                return
            if use_tools:
                use_tools_str = " USE_TOOLS=1 "
            else:
                use_tools_str = ""
    
            if is_project_split(game_dir):
                printc(bcolors.OKBLUE,"Create main.c from split source files\n")
                create_main(game_dir, project_type)

            make_command = \
                GNU_MAKE + " " + target + \
                    use_tools_str + \
                    " ZSDCC_MAKEFILE_THREADS_OPTS=\'-j " + threads + "' " \
                    + all_compilers_opts(zsdcc_extra_optimization, compiler_opts) +  \
                    " _NATIVE_CC=" + native_compiler + \
                    " TOOL_CC=" + tool_compiler + " GNU_MAKE=" + GNU_MAKE + \
                    " -f " + parent_dir+"/"+game_dir+"/Makefile."+game_dir;
            
            run_command_verbosely(make_command)
            
            if is_project_split(game_dir):
                printc(bcolors.OKBLUE,"Delete main.c because of split source files\n")
                delete_main(game_dir, project_type)
            
        else:
            if game_dir in ["games","examples","projects"]:
                multiple_build(game_dir,target,threads,zsdcc_extra_optimization)
            elif game_dir=="new":
                multiple_build("projects",target,threads,zsdcc_extra_optimization)
            elif game_dir in ["builtin","built-in"]:
                multiple_build("games",target,threads,zsdcc_extra_optimization)
                multiple_build("examples",target,threads,zsdcc_extra_optimization)
            elif game_dir=="all":
                multiple_build("games",target,threads,zsdcc_extra_optimization)
                multiple_build("examples",target,threads,zsdcc_extra_optimization)
                multiple_build("projects",target,threads,zsdcc_extra_optimization)
            else:
                return    
        
        files_after = len(files_in_path("../build"))-1
        
        if global_vars.verbose:
            printc(bcolors.OKBLUE, "New binaries built: " + str(files_after-files_before)+"\n")
            




# Create a new project 
def create(params):
    if len(params)<2:
        game_dir = "helloworld"
    else:
        game_dir = params[1]
        game_dir_capital = game_dir.upper()        
        game_dir_capital_without_special_chars = only_upper_digits_and_space(game_dir.upper().replace("-"," ").replace("_"," "))
        
        game_dir = no_space(game_dir)
        
        if(game_dir in example_projects or game_dir in game_projects or game_dir in COMMANDS_LIST):
            print("invalid name!")
            return

    if len(params)<3:
        project_type = "helloworld"
    else:
        if params[2]=="game" or params[2]=="arcade":
            project_type = "arcade_game"
        elif params[2]=="text":
            project_type = "text_game"
        elif params[2]=="test":
            project_type = "test"
        else: 
            if params[2] in ["apis","show_apis","example","show","demo"]:
                project_type = "demo"
            else:
                project_type = "helloworld"

    parent_dir = "projects" 

    if global_vars.verbose:
        print("New project name: " + game_dir)
        print("Project type: " + project_type)

    parent_and_game_dir = parent_dir + "/" + game_dir

    if not os.path.exists(parent_and_game_dir):
        if global_vars.verbose:
            print("Creating project dir...")
        os.makedirs(parent_and_game_dir)

    source_path = "./template_projects/"+project_type+"_code.template"
    if global_vars.verbose:
        print("source_path: " + source_path)
    dest_path = parent_and_game_dir
    if global_vars.verbose:
        print("dest_path: " + dest_path)

    if not os.path.exists(dest_path+"/tiles"):
        if global_vars.verbose:
            print("Copying tiles...")
        shutil.copytree(source_path+"/tiles", dest_path+"/tiles")

    if not os.path.exists(dest_path+"/shapes"):
        if global_vars.verbose:
            print("Copying shapes...")
        if not os.path.exists(source_path+"/shapes"):
            os.makedirs(dest_path+"/shapes")
        else:
            shutil.copytree(source_path+"/shapes", dest_path+"/shapes")

    if not os.path.exists(dest_path+"/generated_assets"):
        if global_vars.verbose:
            print("Create empty generated_assets directory...")
        os.makedirs(dest_path+"/generated_assets")

    if not os.path.exists(dest_path+"/config"):
        if global_vars.verbose:
            print("Create empty config directory...")
        os.makedirs(dest_path+"/config")

    file_names = ["main.c"]

    for file_name in file_names:
        if global_vars.verbose:
            print("Copying file_name: " + file_name)
        shutil.copy(source_path+"/"+file_name, dest_path)

    # Replace _GAME_NAME_CAPITAL with the capitalized game name without special characters
    fin = open("./"+dest_path+"/main.c", "rt")
    data = fin.read()
    data = data.replace('_GAME_NAME_CAPITAL',game_dir_capital_without_special_chars)
    fin.close()
    fin = open("./"+dest_path+"/main.c", "wt")
    #overrite the input file with the resulting data
    fin.write(data)
    
    templated_makefile_path = "./template_projects"

    shutil.copy(templated_makefile_path+"/"+"Makefile_game.template", "./"+dest_path+"/Makefile."+game_dir)

    shutil.copy(templated_makefile_path+"/"+"/config/project_config.mk.template", "./"+dest_path+"/config/project_config.mk")
    shutil.copy(templated_makefile_path+"/"+"/config/game_config.mk.template", "./"+dest_path+"/config/game_config.mk")


    #read input file
    fin = open("./"+dest_path+"/Makefile."+game_dir, "rt")
    #read file contents to string
    data = fin.read()
    #replace all occurrences of the required string
    data = data.replace('_GAME_NAME_CAPITAL',game_dir_capital)
    data = data.replace('_GAME_NAME_', game_dir)
    data = data.replace('_PARENT_DIR_', parent_dir)
    #close the input file
    fin.close()
    #open the file in write mode
    fin = open("./"+dest_path+"/Makefile."+game_dir, "wt")
    #overrite the input file with the resulting data
    fin.write(data)
    #close the file
    fin.close()


# Delete temporary project files If a project is specified, it also deletes generated assets.
def reset(params):
    par_len = len(params)

    if par_len>1:
        game_dir = params[1]
    else:
        game_dir=""

    if game_dir in ["games","examples","projects"]:
        multiple_project_reset(game_dir)
        return
    elif game_dir=="new":
        multiple_project_reset("projects")
        return
    elif game_dir in ["builtin","built-in"]:
        multiple_project_reset("games")
        multiple_project_reset("examples")
        return
    elif game_dir=="all":
        multiple_project_reset("games")
        multiple_project_reset("examples")
        multiple_project_reset("projects") 
        return

    elif (len(params)==2) and (params[par_len-1]=='-y'): #(params[1]=='-y'):
        make_command = GNU_MAKE + " clean_generic_no_built_in -f makefiles.common/auxiliary/Makefile_common"

        if global_vars.verbose:
            print("Delete all non-project-specific temporary files")

        run_command_verbosely(make_command)
        return
        
    elif len(params)<2:
        make_command = GNU_MAKE + " clean_generic_no_built_in -f makefiles.common/auxiliary/Makefile_common"
        if global_vars.verbose:

            print("Delete all non-project-specific temporary files")
        if(are_you_sure()=="y"):
            run_command_verbosely(make_command)
            return
        else:
            return
    else:
        game_dir = params[1]

    project_type = project_category(game_dir)

    parent_dir = project_type + "s"

    # if (len(params)>2) and (params[par_len-1]=='-y'): #(params[2]=="-y"):
        # interactive = False
    # else:
        # interactive = True
    if global_vars.verbose:

        print("Project name: " + game_dir)

    parent_and_game_dir = parent_dir + "/" + game_dir

    if not os.path.exists(parent_and_game_dir):
        print("Project not found!")
        return

    if global_vars.verbose:

        print("Delete all temporary files including generated assets for '"+game_dir+"'")

    # if (not interactive) or (are_you_sure()=="y"):
    make_command = GNU_MAKE + " clean_no_built_in -f " + parent_dir+"/"+game_dir+"/Makefile."+game_dir;

    run_command_verbosely(make_command)


# Clean project data
def clean(params):

    if(len(params)>=2) and params[1]=="tools":
        make_command = GNU_MAKE + " clean_tools -f makefiles.common/auxiliary/Makefile_tools"

        run_command_verbosely(make_command)
        return
        
    if len(params)<2:
        make_command = GNU_MAKE + " clean_generic -f makefiles.common/auxiliary/Makefile_common"

        if global_vars.verbose:
            print("Delete all built binaries and non-project=specific temporary files")
        if(are_you_sure()=="y"):
            run_command_verbosely(make_command)
            return
        else:
            return
    elif (len(params)==2) and (params[1]=='-y'):
        make_command = GNU_MAKE + " clean_generic -f makefiles.common/auxiliary/Makefile_common"

        if global_vars.verbose:
            print("Delete all built binaries and non-project-specific temporary files")

        run_command_verbosely(make_command)
        return
    else:
        game_dir = params[1]

    project_type = project_category(game_dir)

    parent_dir = project_type + "s"

    # if (len(params)>2) and (params[2]=="-y"):
        # interactive = False
    # else:
        # interactive = True

    print("Project name: " + game_dir)

    parent_and_game_dir = parent_dir + "/" + game_dir

    if not os.path.exists(parent_and_game_dir):
        print("Project not found!")
        return

    print("Delete all built binaries and temporary files (also specific to '"+game_dir+"', e.g., generated assets)")

    # if (not interactive) or (are_you_sure()=="y"):
    make_command = GNU_MAKE + " clean -f " + parent_dir+"/"+game_dir+"/Makefile."+game_dir;

    run_command_verbosely(make_command)


# Delete project
def delete(params):
    if(len(params)>=2) and params[1]=="tools":
        make_command = GNU_MAKE + " clean_tools"

        run_command_verbosely(make_command)
        return

    if len(params)<2:
        game_dir="helloworld"
    else:
        candidate_name = params[1]
        if(candidate_name in example_projects or candidate_name in game_projects or candidate_name in COMMANDS_LIST):
            print("invalid name!")
            return
        else:
            game_dir = candidate_name

    if (len(params)>2) and (params[2]=="-y"):
        interactive = False
    else:
        interactive = True

    parent_dir = "projects"

    if global_vars.verbose:
        print("Project name: " + game_dir)

    parent_and_game_dir = parent_dir + "/" + game_dir
    if global_vars.verbose:
        print("Remove the project '"+game_dir+"' with all its files (source, graphics assets, makefile)")        
    if (not interactive) or (are_you_sure()=="y"):
        if os.path.exists(parent_and_game_dir):
            if global_vars.verbose:
                print("Deleting directory " + parent_and_game_dir)
            shutil.rmtree(parent_and_game_dir)

        makefile_name = "Makefile."+game_dir
        if os.path.exists(makefile_name):
            if global_vars.verbose:
                print("Deleting..." + makefile_name)
            os.remove(makefile_name)
        if global_vars.verbose:
            print("'" + game_dir + "' deleted")
    else:
        return


def files_in_path(mypath):
    files = []
    for (dirpath, dirnames, filenames) in walk(mypath):
        # print(dirpath, dirnames,filenames)
        files.extend(filenames)
        break
    return files


def built_files_in_path(mypath):
    files = []
    for (dirpath, dirnames, filenames) in walk(mypath):
        built_files = []
        for filename in filenames:
            if not filename.startswith('.'):
                built_files.append(filename)
                
        files.extend(built_files)
        break
    return files


def clean_test():
    clean(["clean","-y"]);
    files_after_clean = len(files_in_path("../build"))

    if files_after_clean>1:
        printc(bcolors.FAIL, "[xl clean]        KO\n")
        return 0
    else:
        printc(bcolors.OKGREEN, "[xl clean]        OK\n")
        return 1


CROSS_COMPILER_COMMAND = \
    {
    'cc65'        : 'cl65', 
    'z88dk'       : 'zcc', 
    'cmoc'        : 'cmoc',
    'cc6303'      : 'cc68 -h',
    'lcc1802'     : 'lcc',
    'vbcc'        : 'vc -h',
    'ack'         : 'ack -h',
    'tms9900-gcc' : 'tms9900-gcc -h'
    }

CROSS_COMPILER_COMMAND_EXPECTED = \
    {
    'cc65'   : 0, 
    'z88dk'  : 0, 
    'cmoc'   : 256,
    'cc6303' : 256,
    'lcc1802': 0,
    'vbcc'   : 256,
    'ack'    : 0,
    'tms9900-gcc': 256
    }


NATIVE_COMPILER_COMMAND = \
    {
    'gcc'         : 'gcc',
    'g++'         : 'g++',
    }

NATIVE_COMPILER_COMMAND_EXPECTED = \
    {
    'gcc'    : 256,
    'g++'    : 256,
    }


TOOL_COMMAND = \
    {
    'f2k5'     : '../tools/cmoc/mo5/f2k5.' + NATIVE_EXTENSION + '',
    'sapfs'    : '../tools/cmoc/mo5/sapfs.' + NATIVE_EXTENSION + '',
    'file2dsk' : '../tools/cmoc/coco/file2dsk/file2dsk.' + NATIVE_EXTENSION + ' -h',
    'makewzd'  : '../tools/z88dk/oz/makewzd.' + NATIVE_EXTENSION + ' -h',
    'fixcart'  : '../tools/cc65/gamate/gamate-fixcart.' + NATIVE_EXTENSION + '',
    'bbcim'    : '../tools/bbc/bbcim.' + NATIVE_EXTENSION + ' -h',
    'nocart'   : '../tools/z88dk/cpc/nocart/nocart.' + NATIVE_EXTENSION + ' -h',
    'm20'      : '../tools/olivetti_m20/m20.' + NATIVE_EXTENSION + ' -h',
    'elf2ea5'  : '../tools/ti99/elf2ea5.' + NATIVE_EXTENSION + ' -h',
    'ea5split' : '../tools/ti99/ea5split.' + NATIVE_EXTENSION + ' -h',
    }

TOOL_COMMAND_EXPECTED = \
    {
    'f2k5'     : 0,
    'sapfs'    : 256,
    'file2dsk' : 256,
    'makewzd'  : 256,
    'fixcart'  : 65280,
    'bbcim'    : 256,
    'nocart'   : 256,
    'm20'      : 256,
    'elf2ea5'  : 256,
    'ea5split' : 256,
    }


EMULATOR_COMMAND = \
    {
    'c1541'    : 'c1541 -h', 
    'x64'      : 'x64 -h',
    'xvic'     : 'xvic -h',
    'xplus4'   : 'xplus4 -h',
    'xpet'     : 'xpet -h',
    'mame'     : 'mame -h',
    }

EMULATOR_COMMAND_EXPECTED = \
    {
    'java'     : 0,
    'perl'     : 0, 
    'c1541'    : 0, 
    'x64'      : 0, 
    'xvic'     : 0,
    'xplus4'   : 0,
    'xpet'     : 0,
    'mame'     : 0,
    }


BUILDABLE_TOOLS = \
{
    'f2k5',
    'sapfs',
    'file2dsk',
    'makewzd',
    'fixcart',
    'bbcim',
    'nocart',
    'm20',
    'elf2ea5',
    'ea5split',
}


INTERPRETER_COMMAND = \
    {
    'java'     : 'java -h',
    'perl'     : 'perl -h', 
    }

INTERPRETER_COMMAND_EXPECTED = \
    {
    'java'     : 0,
    'perl'     : 0, 
    }

LIBRARY_COMMAND = \
    {
    'ncurses'  : "ls /usr/include/ncurses.h",
    }

LIBRARY_COMMAND_EXPECTED = \
    {
    'ncurses'  : 0,
    }

ROM_COMMAND = \
    {
    'msx/msx.zip'      : 'ls ../roms/mame/msx.zip',
    'msx/canon20.zip'  : 'ls ../roms/mame/canonv20.zip',
    
    'c16/kernal'     : 'ls ../roms/vice/plus4/kernal',
    'c16/basic'     : 'ls ../roms/vice/plus4/basic',
    'c16/3plus1hi'     : 'ls ../roms/vice/plus4/3plus1hi',
    'c16/3plus1lo'     : 'ls ../roms/vice/plus4/3plus1lo',

    'c64/basic'     : 'ls ../roms/vice/c64/basic',
    'c64/chargen'     : 'ls ../roms/vice/c64/chargen',
    'c64/kernal'     : 'ls ../roms/vice/c64/kernal',

    'pet/basic1'     : 'ls ../roms/vice/pet/basic1',
    'pet/kernal1'     : 'ls ../roms/vice/pet/kernal1',

    'pet/basic2'     : 'ls ../roms/vice/pet/basic2',
    'pet/kernal2'     : 'ls ../roms/vice/pet/kernal2',

    'pet/basic4'     : 'ls ../roms/vice/pet/basic4',
    'pet/kernal4'     : 'ls ../roms/vice/pet/kernal4',    

    'pet/chargen'     : 'ls ../roms/vice/pet/chargen',
    'pet/characters.901640-01.bin'     : 'ls ../roms/vice/pet/characters.901640-01.bin',

    'pet/edit1g'     :'ls ../roms/vice/pet/edit1g',
    'pet/edit2b'     :'ls ../roms/vice/pet/edit2b',
    'pet/edit2g'     :'ls ../roms/vice/pet/edit2g',

    'pet/edit4b40'     :'ls ../roms/vice/pet/edit4b40',
    'pet/edit4b80'     :'ls ../roms/vice/pet/edit4b80',
    'pet/edit4g40'     :'ls ../roms/vice/pet/edit4g40',

    'vic20/basic'     : 'ls ../roms/vice/vic20/basic',
    'vic20/chargen'     : 'ls ../roms/vice/vic20/chargen',
    'vic20/kernal'     : 'ls ../roms/vice/vic20/kernal',    
    }


ROM_COMMAND_EXPECTED = \
    {
    'msx/msx.zip'        : 0,
    'msx/canon20.zip'    : 0,
    
    'c16/kernal'     : 0,
    'c16/basic'      : 0,
    'c16/3plus1hi'   : 0,
    'c16/3plus1lo'   : 0,
    
    'c64/kernal'     : 0,
    'c64/chargen'     :0,
    'c64/basic'     : 0,

    'pet/kernal1'     : 0,
    'pet/basic1'     : 0,
    
    'pet/kernal2'     : 0,
    'pet/basic2'     : 0,
    
    'pet/kernal4'     : 0,
    'pet/basic4'     : 0,

    'pet/chargen'     :0,
    'pet/characters.901640-01.bin'     :0,
    'pet/chargen'     :0,
    
    'pet/edit1g'     :0,
    'pet/edit2b'     :0,
    'pet/edit2g'     :0,

    'pet/edit4b40'     :0,
    'pet/edit4b80'     :0,
    'pet/edit4g40'     :0,



    'vic20/kernal'     : 0,
    'vic20/chargen'     :0,
    'vic20/basic'     : 0,
    }

MAKE_COMMAND = \
    {
    'make'     : 'make -h',
    'gmake'     : 'gmake -h', 
    }

MAKE_COMMAND_EXPECTED = \
    {
    'make'  : 0,
    'gmake' : 0,
    }

def check_programs(title, command_list, expected_list, verbose=True):
    if verbose:
        printc(bcolors.OKCYAN,"----------------------------------------\n")
        printc(bcolors.OKCYAN, title)
        printc(bcolors.OKCYAN,"\n----------------------------------------\n")

    total_result = {}

    # max_len = 0
    # for compiler in command_list.keys():
        # if len(compiler)>max_len:
            # max_len = len(compiler)
    max_len = 28

    for compiler in command_list.keys():
        result = os.system(command_list[compiler] + " > /dev/null 2>&1")
        spaces = " " * (max_len+1-len(compiler))
        if result==expected_list[compiler]:
            if verbose:
                printc(bcolors.OKGREEN,"[" + compiler + "]")
            res = "found\n"
            res_color = bcolors.OKGREEN
            res_color2 = bcolors.OKGREEN
            total_result[compiler]=True
        else:

            total_result[compiler]=False
            if compiler in BUILDABLE_TOOLS:
                res = "NOT built\n"
                res_color = bcolors.OKBLUE
                res_color2 = bcolors.OKCYAN
            else:
                res = "NOT found\n"
                res_color = bcolors.WARNING
                res_color2 = bcolors.WARNING
            if verbose:
                printc(res_color,"[" + compiler + "]")
        if verbose:
            printc(res_color2, spaces + res)
    if verbose:
        printc(bcolors.OKCYAN,"----------------------------------------\n\n")
    return(total_result)



def test_cross_compilers():
    return check_programs("CROSS_COMPILERS", CROSS_COMPILER_COMMAND,CROSS_COMPILER_COMMAND_EXPECTED)

def test_native_compilers():
    return check_programs("NATIVE_COMPILERS", NATIVE_COMPILER_COMMAND, NATIVE_COMPILER_COMMAND_EXPECTED)

def test_make(verbose=True):
    return check_programs("MAKE", MAKE_COMMAND,MAKE_COMMAND_EXPECTED, verbose)

def test_tools(verbose=True):
    return check_programs("TOOLS", TOOL_COMMAND,TOOL_COMMAND_EXPECTED, verbose)

def test_emulators():
    return check_programs("EMULATORS", EMULATOR_COMMAND,EMULATOR_COMMAND_EXPECTED)

def test_interpreters():
    return check_programs("INTERPRETERS", INTERPRETER_COMMAND,INTERPRETER_COMMAND_EXPECTED)

def test_libraries():
    return check_programs("LIBRARIES", LIBRARY_COMMAND, LIBRARY_COMMAND_EXPECTED)

def test_roms():
    return check_programs("ROMS", ROM_COMMAND, ROM_COMMAND_EXPECTED)


def test_compilers():
    test_native_compilers()
    test_cross_compilers()
    

# TODO: Handle aliases such as dragon->coco

# TODO: Handle Windows vs Linux and targets with 3 binaries
if platform in ["cygwin", "msys"]:
    TARGETS_WITH_2_BINARIES = ['aquarius', 'cpc', 'coco3', 'to5', 'ace', 'mtx500', 'mtx512', 'laser500']
    TARGETS_WITH_3_BINARIES = ['coco','abc80']
else:
    TARGETS_WITH_2_BINARIES = ['aquarius', 'cpc', 'coco3', 'to5', 'ace', 'mtx500', 'mtx512', 'laser500','coco']
    TARGETS_WITH_3_BINARIES = ['abc80']


def list_of_projects(project_category):
    # print("category: " + project_category)
    if project_category in ["examples", "projects", "games"]:
        res = dirs_in_path("./"+project_category)
    else:
        res = dirs_in_path("./examples")+dirs_in_path("./games")+dirs_in_path("./projects")
    # print(res)
    return res


def test_projects(projects, target="stdio"):

    clean_test()
    
    if projects in ["examples", "projects", "games"]:
        number_of_projects = len(dirs_in_path("./"+projects))
    elif projects == "all":
        number_of_projects = len(dirs_in_path("./examples")) + len(dirs_in_path("./games")) + len(dirs_in_path("./projects"))
    else:
        number_of_projects = 1
    print("number of projects: " + str(number_of_projects))
    #multiple_build
    build(["build",projects,target,compilation_threads,""])
    built_files = built_files_in_path("../build")
    
    # TODO: Handle target=*_targets and all
    if target.endswith("_targets") or target=="all": 
        print("Test on the number of binaries for all these targets is not supported")
        
    if target in TARGETS_WITH_3_BINARIES:
        files_per_project = 3
    elif target in TARGETS_WITH_2_BINARIES:
        files_per_project = 2
    else:
        files_per_project = 1
        
    print("Expected binaries per project: " + str(files_per_project))
        
    if len(built_files)<files_per_project*number_of_projects:
        printc(bcolors.FAIL, "[xl build]  KO\n")
        print("Built files: " +str(built_files))
        print("Expected number : " + str(number_of_projects))
        print("No. Built files : " + str(len(built_files)))
        
        # success=0
        return False
    else:
        printc(bcolors.OKGREEN, "[xl build]  OK\n")
        return True


def test_clean_tools():
    #clean tools
    clean(["clean","tools"])
    
    tools_result_map=test_tools(False)
    number_of_tools = len(tools_result_map.keys())
    
    built_tools = 0
    for tool in tools_result_map.keys():
        if tools_result_map[tool]:
            built_tools+=1
    if built_tools==0:
        printc(bcolors.OKGREEN, "[xl clean tools]  OK\n")
    else:
        printc(bcolors.FAIL, "[xl clean tools]  KO\n")
    return number_of_tools, built_tools


def test_self(target = "stdio",opt = "slow"):

    # print("target1: " + str(target))
    # if(len(params)<3):
        # target = "stdio"
    # else:
        # target = params[1]
    # print("target2: " + str(target))
    # quit()
    printc(bcolors.OKCYAN,"----------------------------------------\n")
    printc(bcolors.OKCYAN, "XL SCRIPT TEST")
    printc(bcolors.OKCYAN,"\n----------------------------------------\n")
    success = 1
    printc(bcolors.BOLD,  "target: ")
    printc(bcolors.OKBLUE,target+"\n")
    printc(bcolors.OKCYAN,"----------------------------------------\n")

    global_vars.test = 1
    global_vars.verbose = 0

    #clean tools
    number_of_tools, built_tools = test_clean_tools();
    if built_tools>0:
        success = 0

    if opt!="fast":

        #tools
        tools()
        
        tools_result_map=test_tools(False)
        built_tools = 0
        for tool in tools_result_map.keys():
            if tools_result_map[tool]:
                built_tools+=1
        if built_tools==number_of_tools:
            printc(bcolors.OKGREEN, "[xl tools]        OK\n")    
        else:
            printc(bcolors.FAIL, "[xl tools]       KO\n")
            print("built_tools: " + str(built_tools))
            print("number_of_tools: " + str(number_of_tools))
            success = 0

        #clean tools
        number_of_tools, built_tools = test_clean_tools();
        if built_tools > 0:
            success = 0

    #delete
    delete(["delete","_test_project","-y"])


    #clean
    success = success * clean_test()

    projects_before_create = list(["list"],False)
    
    project_dirs_before_create = len(dirs_in_path("./projects"))
    initial_dirs = project_dirs_before_create

    # create
    create(["create", "_test_project", "test"])
    project_dirs_after_create = len(dirs_in_path("./projects"))
    
    if project_dirs_after_create!=project_dirs_before_create+1:
        printc(bcolors.FAIL, "[xl create]       KO\n")
        return 0
    else:
        printc(bcolors.OKGREEN, "[xl create]       OK\n")

    # list
    projects_after_create = list(["list"],False)
    if projects_after_create!=projects_before_create+1:
        printc(bcolors.FAIL,"[xl list]         KO\n") 
        success = 0
    else:
        printc(bcolors.OKGREEN,"[xl list]         OK\n")

    # create 
    create(["create", "_test_project2", "game"])
    printc(bcolors.OKGREEN, "[xl create]       OK\n")

    # create 
    create(["create", "_test_project3", "demo"])
    printc(bcolors.OKGREEN, "[xl create]       OK\n")

    # create 
    create(["create", "_test_project4", "text"])
    printc(bcolors.OKGREEN, "[xl create]       OK\n")

    # create 
    create(["create", "_test_project5", "helloworld"])
    printc(bcolors.OKGREEN, "[xl create]       OK\n")

    #build
    build(["build", "_test_project2", target])
    built_files = built_files_in_path("../build")
    printc(bcolors.OKGREEN,"[xl build]        OK\n")
    
    #build
    build(["build", "_test_project3", target])
    built_files = built_files_in_path("../build")
    printc(bcolors.OKGREEN,"[xl build]        OK\n")
    
    #build
    build(["build", "_test_project4", target])
    built_files = built_files_in_path("../build")
    printc(bcolors.OKGREEN,"[xl build]        OK\n")

    #build
    build(["build", "_test_project5", target])
    built_files = built_files_in_path("../build")
    printc(bcolors.OKGREEN,"[xl build]        OK\n")

    #clean
    success = success * clean_test()
    if success:
        printc(bcolors.OKGREEN,"[xl clean]        OK\n")

    #delete
    delete(["delete","_test_project2","-y"])
    printc(bcolors.OKGREEN, "[xl delete]       OK\n")
    
    #delete
    delete(["delete","_test_project3","-y"])
    printc(bcolors.OKGREEN, "[xl delete]       OK\n")

    #delete
    delete(["delete","_test_project4","-y"])
    printc(bcolors.OKGREEN, "[xl delete]       OK\n")

    #delete
    delete(["delete","_test_project5","-y"])
    printc(bcolors.OKGREEN, "[xl delete]       OK\n")

    #delete
    delete(["delete","_foo_test","-y"])

    #rename
    rename(["","_test_project", "_foo_test"])
    printc(bcolors.OKGREEN,"[xl rename]       OK\n")

    #rename
    rename(["","_foo_test", "_test_project"])
    printc(bcolors.OKGREEN,"[xl rename]       OK\n")

    #build
    build(["build", "_test_project", target])
    built_files = built_files_in_path("../build")
    
    if global_vars.verbose:
        print("built binaries: " + str(built_files))
    if len(built_files)==0:
        print("built binaries: " + str(built_files))

        printc(bcolors.FAIL, "[xl build]        KO\n")
        success=0
    else:
        printc(bcolors.OKGREEN, "[xl build]        OK\n")

    dirs_in_proj_before = len(dirs_in_path("./projects/_test_project"))
    if dirs_in_proj_before != 4:
        printc(bcolors.FAIL, "[xl build]        KO\n")
        success=0

    dirs_in_shapes_before = len(dirs_in_path("./projects/_test_project/shapes"))
    if dirs_in_shapes_before != 1:
        printc(bcolors.FAIL, "[xl build]        KO\n")
        print(dirs_in_shapes_before)
        print(str(dirs_in_path("./projects/_test_project/shapes")))
        success=0

    extend(["extend", "_test_project"])

    dirs_in_proj_after = len(dirs_in_path("./projects/_test_project"))

    if dirs_in_proj_after != 4:
        printc(bcolors.FAIL, "[xl extend]       KO\n")
        success=0

    dirs_in_shapes_after = len(dirs_in_path("./projects/_test_project/shapes"))

    if dirs_in_shapes_after != 5:
        printc(bcolors.FAIL, "[xl extend]       KO\n")
        print("no. dirs_in_shapes_after: " + str(dirs_in_shapes_after))
        print("dirs_in_shapes_after: " + str(dirs_in_path("./projects/_test_project/shapes")))
        success=0
    
    if success:
        printc(bcolors.OKGREEN, "[xl extend]       OK\n")


    # run
    run(["run", "_test_project", "stdio"])

    if global_vars.verbose:
        print("")
    printc(bcolors.OKGREEN, "[xl run]          OK\n")


    projects_before_create = list(["list"],False)
    
    project_dirs_before_create = len(dirs_in_path("./projects"))


    # print(str(dirs_in_path("./projects")))

    # clone
    clone(["","_test_project","_cloned_test_project"]);
    project_dirs_after_create = len(dirs_in_path("./projects"))
    
    # print(str(dirs_in_path("./projects")))
    
    if project_dirs_after_create!=project_dirs_before_create+1:
        printc(bcolors.FAIL, 
                            "[xl clone]        KO\n")
        return 0
    else:
        printc(bcolors.OKGREEN, 
                            "[xl clone]        OK\n")


    # run
    run(["run", "_test_cloned_test_project_project", "stdio"])

    if global_vars.verbose:
        print("")
    printc(bcolors.OKGREEN, "[xl run]          OK\n")

    # delete
    delete(["","_cloned_test_project","-y"])
    printc(bcolors.OKGREEN, "[xl delete]       OK\n")

    
    #clean
    success = success * clean_test()
    
    #shapes
    shapes(["","_test_cloned_test_project_project"])    
    # make_assets_from_tiles(["_test_cloned_test_project_project"])
    printc(bcolors.OKGREEN, "[xl shapes]       OK\n")

    
    if opt!="fast":

        #size
        size(["size", "_test_project", "stdio_sized", "12", "12"],True)
        built_files = built_files_in_path("../build")

        if global_vars.verbose:
            print("built binaries: " + str(built_files))
        if len(built_files)!=1:
            printc(bcolors.FAIL, "[xl size]         KO\n")
            print(str(built_files))
            success=0
        else:
            printc(bcolors.OKGREEN, "[xl size]         OK\n")

        dirs_in_proj_before = len(dirs_in_path("./projects/_test_project"))
        if dirs_in_proj_before != 4:
            printc(bcolors.FAIL, "[xl size]         KO\n")
            print(str(dirs_in_path("./projects/_test_project")))
            success=0

        dirs_in_shapes_before = len(dirs_in_path("./projects/_test_project/shapes"))
        if dirs_in_shapes_before != 5:
            printc(bcolors.FAIL, "[xl size]         KO\n")
            print(str(dirs_in_path("./projects/_test_project/shapes")))
            success=0

        #reset
        reset(["","-y"])
        printc(bcolors.OKGREEN, "[xl reset]        OK\n")

        #size
        size(["size", "_test_project", "stdio_sized", "32", "24"],False)
        built_files = built_files_in_path("../build")

        if global_vars.verbose:
            print("built binaries: " + str(built_files))

        if len(built_files)!=2:
            printc(bcolors.FAIL, "[xl size]         KO\n")
            print(str(built_files))
            print("Wrong number of built files")
            success=0
        else:
            printc(bcolors.OKGREEN, "[xl size]         OK\n")

        projects = []
        for (dirpath, dirnames, filenames) in walk("./projects"):
            projects.extend(dirnames)
            break
        
        games = []
        for (dirpath, dirnames, filenames) in walk("./games"):
            games.extend(dirnames)
            break
        
        examples = []
        for (dirpath, dirnames, filenames) in walk("./examples"):
            examples.extend(dirnames)
            break

        #reset
        reset(["","_test_project"])
        printc(bcolors.OKGREEN, "[xl reset]        OK\n")


    projects_before_delete = list(["list"],False)
    
    project_dirs_before_delete = len(dirs_in_path("./projects"))


    #delete
    delete(["delete","_test_project","-y"])
    project_dirs_after_delete = len(dirs_in_path("./projects"))
    
    if project_dirs_after_delete != initial_dirs:
        printc(bcolors.FAIL,    "[xl delete]       KO\n")
        print(project_dirs_before_create)
        print(project_dirs_after_delete)
        success=0
    else:
        printc(bcolors.OKGREEN, "[xl delete]       OK\n")

    if clean_test()==0:
        success=0


    # build (all examples)
    build(["","examples","stdio"])
    
    built_files = built_files_in_path("../build")
    
    if len(built_files)!=len(examples):
        success=0
        printc(bcolors.FAIL, "[xl build]        KO\n")
        print(built_files)
        print(examples)
    else:
        printc(bcolors.OKGREEN, "[xl build]        OK\n")

    if clean_test()==0:
        success=0

    # build (all games)
    # global_vars.verbose = 1
    # global_vars.test = 0
    build(["","games","stdio"])
    
    built_files = built_files_in_path("../build")
    
    if len(built_files)!=len(games):
        success=0
        printc(bcolors.FAIL, "[xl build]        KO\n")
        print(built_files)
        print(games)
        quit()
    else:
        printc(bcolors.OKGREEN, "[xl build]        OK\n")

    if clean_test()==0:
        success=0

    printc(bcolors.OKCYAN,"----------------------------------------\n")

    return success


def test_all(params):

    test_compilers()
    # test_make()
    test_tools()
    test_libraries()
    test_interpreters()
    # test_emulators()
    # test_roms()
    
    unit_tests()
    # print("params: " + str(params))
    return test_self(params)

expected_files = {
    "cc65_targets": 8, 
    "z88dk_targets": 6, 
    "cmoc_targets": 3, 
    "lcc1802_targets": 1,
    "stdio": 1,
    "z88dk_targets_alt": 38
    }


def targets_test(params):

    success = clean_test()
    if params[1].startswith("z88dk_targets"):
        parallel = " -j " + compilation_threads
    else:
        parallel = ""         

    game_dir = "chase"
    project_type = "game"
    if is_project_split(game_dir):
        printc(bcolors.OKBLUE,"Create main.c from split source files\n")
        create_main(game_dir, project_type)
    if params[1].endswith("_targets"):
        make_command = GNU_MAKE + parallel + " test_" + params[1] + " " + " GNU_MAKE=" + GNU_MAKE + " _NATIVE_CC="+ native_compiler + " " + all_compilers_opts("","") + \
                                           " -f makefiles.other/chase/tests/Makefile.tests"
        run_command_verbosely(make_command)
    elif params[1]=="stdio_targets":
        make_command = GNU_MAKE + " GNU_MAKE=" + GNU_MAKE + " _NATIVE_CC="+ native_compiler + " stdio " + \
                                           " -f makefiles.other/chase/tests/Makefile.tests"
        run_command_verbosely(make_command)
    elif params[1]=="z88dk_targets_alt":
        # parallel = ""
        make_command = GNU_MAKE + parallel + " GNU_MAKE=" + GNU_MAKE + \
                         " z88dk_quick_test -f makefiles.other/chase/tests/Makefile.z88dk_quick_tests"
        run_command_verbosely(make_command)   
    else:
        printc(bcolors.FAIL, "Parameter not recognized\n")
        if is_project_split(game_dir):
            print("Delete main.c (because of split source files)\n")
            delete_main(game_dir, project_type)
        exit()
    if is_project_split("chase"):
        printc(bcolors.OKBLUE,"Delete main.c (because of split source files)")
        delete_main(game_dir, project_type)


    built_files = len(files_in_path("../build"))-1
    if global_vars.verbose: 
        print("Number of built files: " + str(built_files))
        
    if params[1] in expected_files.keys():
        if global_vars.verbose:
            printc(bcolors.OKCYAN, "Built files: " + str(built_files)+"\n")
            printc(bcolors.OKBLUE, "Expected files: " + str(expected_files[params[1]])+"\n")
        if built_files != expected_files[params[1]]:
            printc(bcolors.FAIL, "binaries KO\n")
            success=0

        else:
            printc(bcolors.OKGREEN, "binaries OK\n")
    
    if clean_test()==0:
        success=0
    return success


def unit_tests():
    printc(bcolors.OKCYAN,"----------------------------------------\n")
    printc(bcolors.OKCYAN, "UNIT-TESTS")
    printc(bcolors.OKCYAN,"\n----------------------------------------\n")
    
    command_string = "python -t tests/testImport.py"
    run_command_verbosely(command_string)
    printc(bcolors.OKBLUE,"--------------------------------\n")


    command_string = "python -t tests/testTiles.py"
    run_command_verbosely(command_string)
    printc(bcolors.OKBLUE,"--------------------------------\n")

    command_string = "python -t tests/testStrings.py"
    run_command_verbosely(command_string)
    printc(bcolors.OKBLUE,"--------------------------------\n")

    command_string = "python -t tests/testAssets.py"
    run_command_verbosely(command_string)
    printc(bcolors.OKCYAN,"----------------------------------------\n")


# Self-test xl and native build
def test(params):
    if (len(params)<=1) or ((len(params)==2) and (params[1]=="check")):
        if test_all("stdio"):
            printc(bcolors.OKGREEN, "TEST OK\n")
        else:
            printc(bcolors.FAIL, "TEST KO\n")
        return
    elif params[1]=="self":
        if(len(params)<3):
            test_self()
        else:
            test_self(params[2])
    elif params[1]=="compilers":
        test_compilers()
    elif params[1]=="tools":
        test_tools()
    elif params[1]=="emulators":
        test_emulators()
    elif params[1]=="cross-compilers" or params[1]=="cross_compilers":
        test_cross_compilers()
    elif params[1]=="native_compilers" or params[1]=="native-compilers":
        test_native_compilers()
    elif params[1]=="libraries":
        test_libraries()
    elif params[1]=="interpreters":
        test_interpreters()
    elif params[1]=="roms":
        test_roms()
    elif params[1]=="make":
        test_make()
    elif params[1]=="unit-tests" or params[1]=="unit_tests":
        unit_tests()
    elif params[1].endswith('targets') or params[1].endswith('targets_alt'):
        if targets_test(params):
            printc(bcolors.OKGREEN, "TEST OK\n")
        else:
            printc(bcolors.FAIL, "TEST KO\n")
        return
    else:
        projects = []
        for (dirpath, dirnames, filenames) in walk("./projects"):
            projects.extend(dirnames)
            break
        
        games = []
        for (dirpath, dirnames, filenames) in walk("./games"):
            games.extend(dirnames)
            break
        
        examples = []
        for (dirpath, dirnames, filenames) in walk("./examples"):
            examples.extend(dirnames)
            break
        
        # print(projects + games + examples)
        # quit()
        if params[1] in projects + games + examples or params[1] in ['examples','games','projects','all']:
            # print("KO")
            # quit()
            if len(params)>=3:
                par1 = params[1]
                par2 = params[2]
            else:
                par1 = params[1]
                par2 = "stdio"
            if test_projects(par1,par2):
                printc(bcolors.OKGREEN, "TEST OK\n")
            else:
                printc(bcolors.FAIL, "TEST KO\n")
        else:
            # print("OK")
            # quit()
            test_all(params[1])
        return
    
    
# Self-test xl and native build
def check(params):
    if len(params)<=1:
        tools = test_tools()
        interpreters = test_interpreters()
        native_compilers =test_native_compilers()
        cross_compilers = test_cross_compilers()
        libraries = test_libraries()
        make = test_make()
        emulators = test_emulators()
        roms = test_roms()
        
        print("")
        
        printc(bcolors.BOLD, "SUMMARY\n")
        tools = True
        xl_run_cross_target = True
        native_target = True
        cross_target = True
        
        
        if not make['make'] and not make['gmake']:
            printc(bcolors.ERROR, "No make command detected!\n")
            
        if not native_compilers['gcc']:
            # printc(bcolors.WARNING, "No gcc compiler detected -> Several targets and native target impacted\n")
            tools = False
            native_target = False
            
        if not native_compilers['g++']:
            # printc(bcolors.WARNING, "No g++ compiler detected -> Few targets impacted (coco/dragon)\n")
            xl_run_cross_target = True
            tools = False

        if not libraries['ncurses']:
            printc(bcolors.WARNING, "No ncurses library detected -> Native target impacted\n")
            native_target = False

        for cross_compiler in cross_compilers.keys():
            if not cross_compilers[cross_compiler]:
                # printc(bcolors.WARNING, "No " + cross_compiler + " cross-compiler -> xl build <project> <target> impacted for some targets\n")
                cross_target = False
                
        for emulator in emulators.keys():
            if not emulators[emulator]:
                # printc(bcolors.WARNING, "No " + emulator + " emulator -> xl run <project> <target> impacted for some targets\n")
                xl_run_cross_target = False
                break

        for rom in roms.keys():
            if not roms[rom]:
                # printc(bcolors.WARNING, "No " + rom + " rom -> xl run <project> <target> impacted for some targets\n")
                xl_run_cross_target = False
                break

        if not tools:
            printc(bcolors.WARNING, "'xl tools' may be KO for some targets\n")
            
        if not native_target:
            printc(bcolors.WARNING, "'xl build <project>' may be KO (no native build)\n")
            
        if not cross_target:
            printc(bcolors.WARNING, "'xl build <project> <target>' may be KO for some targets\n")
            
        if not xl_run_cross_target:
            printc(bcolors.WARNING, "'xl run <project> <target>' may be KO for some targets\n")

        if tools and native_target and xl_run_cross_target and cross_target:
            printc(bcolors.OKCYAN, "No issue found\n")

        
    elif params[1]=="compilers":
        test_compilers()
    elif params[1]=="tools":
        test_tools()
    elif params[1]=="emulators":
        test_emulators()
    elif params[1]=="cross-compilers" or params[1]=="cross_compilers":
        test_cross_compilers()
    elif params[1]=="native_compilers" or params[1]=="native-compilers":
        test_native_compilers()
    elif params[1]=="libraries":
        test_libraries()
    elif params[1]=="interpreters":
        test_interpreters()
    elif params[1]=="make":
        test_make()
    elif params[1]=="roms":
        test_roms()

    
    


# List all projects    
def list(params, print_projects=True):

    if(len(params)<2):
        project_dirs = ["examples", "games", "projects"]
    elif(params[1]=="all"):
        project_dirs = ["examples", "games", "projects"]
    elif params[1] in ["games", "examples", "projects"]:
        project_dirs = [params[1]]
    elif params[1] in ["new"]:
        project_dirs = ["projects"]
    elif params[1] in ["built-in", "builtin"]:
        project_dirs = ["games", "examples"]
    else:
        return

    count = 0

    for mypath in project_dirs:
        if print_projects:
            printc(bcolors.BOLD, "["+mypath+"]\n")
        for (dirpath, dirnames, filenames) in walk(mypath):
            # projects.extend(dirnames)
            for project in dirnames:
                if print_projects:
                    print("  "+str(project))
                count+=1
            break
        if print_projects:
            print("")
    
    if global_vars.verbose:
        print("Projects found: " + str(count))
        print("")

    return count



def help_help():
    print("Possible values for <command>:")
    print(' '.join(str(cmd) for cmd in COMMANDS_LIST))
    print("")
    printc(bcolors.BOLD,"xl help <command or routine>\n")
    print("for <command>-specific help")
    print("\nExample:")
    print("\nxl help create              \n  It displays the help page for the 'create' xl script command")
    print("")
    print("\nxl help _XL_DRAW              \n  It displays the help page for the '_XL_DRAW' C routine")
    print("")
    printc(bcolors.OKCYAN,"POSSIBLE COMMANDS")
    print("")
    commands([])
    print("\nUse")
    printc(bcolors.BOLD,"xl help manual")
    print("\nto get the list of documented C routines.")
    print("\nUse")
    printc(bcolors.BOLD,"xl manual")
    print("\nto get the full manual for the C routines.")

def run_native(params):
    command_prefix = "../build/X" + params[1] + "_ncurses"

    if len(params)>=4:
        xsize = params[2]
        ysize = params[3]
        command_string = command_prefix + "_" + xsize + "X" + ysize + "." + NATIVE_EXTENSION
    else:
        command_string = command_prefix + "." + NATIVE_EXTENSION
    run_command_verbosely(command_string)


def run_stdio(params):
    command_prefix = "../build/X" + params[1] + "_stdio"

    if len(params)>=4:
        xsize = params[3]
        ysize = params[4]
        command_string = command_prefix + "_" + xsize + "X" + ysize + "." + NATIVE_EXTENSION
    else:
        command_string = command_prefix + "." + NATIVE_EXTENSION
    run_command_verbosely(command_string)


DEFAULT_TARGET_MAP = {"vic20":"vic20_exp_16k", "c16":"c16_16k", "plus4":"c16_32k", "pet":"pet_16k", "msx": "msx_16k"}

VICE_TARGETS = ["c64", 
                "vic20", "vic20_unexpanded", "vic20_exp_3k", "vic20_exp_8k", "vic20_exp_16k", 
                "c16", "plus4", "c16_16k", "c16_32k",
                "pet", "pet_8k", "pet_16k"
               ]

MAME_TARGETS = ["msx", "msx_16k"]


# Run a project by using an emulator if necessary. Only few emulators are supported.
def run(params):
    
    if len(params)==2:
        run_native(params)
    
    if len(params)>=3:
        target = params[2]
        
        if target in DEFAULT_TARGET_MAP:
            target = DEFAULT_TARGET_MAP[target]
            if global_vars.verbose:
                print("defaulting to target: " + target)
           
        if target=="stdio":
            run_stdio(params)
        elif target=="ncurses":
            run_native(params[0:2]+params[3:])
            
        # TODO: replace this with a check on prefixes
        elif target in VICE_TARGETS:
            extension = "prg"
            rom_directory = vice_rom_path
            if target=="c64":
                rom_directory += "c64"

                emulator = C64_EMULATOR
            elif target.startswith("vic20"):
                rom_directory += "vic20"

                if target=="vic20_exp_3k":
                    emulator = VIC20_EMULATOR + " -memory 3k"
                elif target=="vic20_unexpanded":
                    emulator = VIC20_EMULATOR + " -memory none"
                else:
                    emulator = VIC20_EMULATOR + " -memory 24k"
            elif target.startswith("c16") or target=="plus4":
                rom_directory += "plus4"

                emulator = PLUS4_EMULATOR
            elif target.startswith("pet"):
                rom_directory += "pet"
                emulator = PET_EMULATOR
            else:
                print("'xl run' does not support this target")
                return
            command_string = vice_path + emulator + " -directory " + rom_directory + " -autostartprgmode 1  ../build/X" + params[1] + "_" + target + "." + extension
            
            run_command_verbosely(command_string)

        elif target in MAME_TARGETS:
            emulator = MAME_EMULATOR
            
            if target.startswith("msx"):
                extension = "rom"
                mame_sub_target = "canonv20" 
                # mame_rom_path = "'c:\\Retro\\Emulators\\Mame0251\\roms\\'"
                command_string = mame_path + emulator + " " + mame_sub_target + " -rompath " + mame_rom_path + " -window -uimodekey DEL  -skip_gameinfo  -cart1 ../build/X" + params[1] + "_" + target + "." + extension
                run_command_verbosely(command_string)
                # print(command_string)
        else:
            print("'xl run' does not support this target")
            return


# It should be able to import from 
# - Assembly files that use byte directives with either decimal and hex notation
# - Assembly files that use word directives with ONLY hex notation
def import_from_source(params, rotate = False):
    filename = params[1]

    rip_option = params[len(params)-1]=="-rip"

    xsize = 8
    ysize = 8

    tiles = rip_tiles(filename, xsize, ysize, rip_option, rotate)

    try:
        if(len(params)>=3) and "-" not in params[2]:
            store_tiles(params[2],tiles, xsize, ysize)
    except Exception as exception:
        print("Sorry! Failed to store tiles: \n" + str(exception.args))


# It should be able to import from 
# - Assembly files that use byte directives with either decimal and hex notation
# - Assembly files that use word directives with ONLY hex notation
# - BASIC files that use decimal, hex notation or "headless" hex notation (by guessing)
# Remark: This function is like "import_from_source" with the "-rip" option
def rip(params, rotate = False):
    filename = params[1]

    xsize = 8
    ysize = 8

    tiles = rip_tiles(filename, xsize, ysize, True, rotate)

    try:
        if(len(params)>=3) and "-" not in params[2]:
            store_tiles(params[2],tiles, xsize, ysize)
    except Exception as exception:
        print("Sorry! Failed to store tiles: \n" + str(exception.args))    

# Show all generated files
def files():
    make_command = "ls -ls ../build"
    os.system(make_command)   


def split(params):

    import_split_tiles(params[1])
    


# Import a shape as single tile from a text file that describes its shape with characters
def tile(params):

    tile,xsize,ysize = import_tile(params[1])
    

    
    if global_vars.verbose:  
        print_shape(compute_shape(tile,xsize))
    
    if(len(params)>=3):
        store_tile(params[2], tile, xsize, ysize, params[3])
    else:
        printc(bcolors.OKCYAN, tile+"\n")

# replace_shapes:
# 0 -> write in _shapes directory,
# 1 -> write in shapes directory but avoid overwriting existing shapes or tiles
def write_shapes(project, shapes, xsize,ysize):
    path = path_to_shapes(project,xsize,ysize)
    if not replace_shapes:
        path = path.replace("shapes","_shapes")
    if global_vars.verbose:
        print("Writing shapes in: " + path)
    if os.path.exists(path):
        if global_vars.verbose:
            print("Directory exists")
    else:
        if global_vars.verbose:
            print("Directory does not exist")
        os.makedirs(path)
    for tile_number, shape in shapes.items():
        #print(tile_number,shape)
        path_to_shape = path+"shape"+tile_number+".txt" 
        if global_vars.verbose:
            print("Path to shape file: " + path_to_shape)
        path_to_tile = path.replace("shapes","tiles")+"tile"+tile_number+".txt"
        if global_vars.verbose:
            print("Path to tile file: " + path_to_tile)
        if replace_shapes and (os.path.exists(path_to_shape) or os.path.exists(path_to_tile)):
            if os.path.exists(path_to_shape):
                if not global_vars.test:
                    print("shape "+ tile_number +" already exists")
            elif os.path.exists(path_to_tile):
                if not global_vars.test:
                    print("tile "+ tile_number +" already exists")
        else:  
            with open(path_to_shape,"w") as file:
                for row in shape:
                    if not global_vars.test:
                        print(row)
                    file.write(row+"\n")
        if global_vars.verbose:
            print("")


# Extand 8x8 shapes by reshaping them into shapes with other dimensions 
def extend(params):
    project = params[1]

    path_to_8x8_files = path_to_shapes(project,8,8)
    if global_vars.verbose:
        print("Path to shape files: " + path_to_8x8_files)
        print("")
    shape_files = files_in_path(path_to_8x8_files)
    
    dict7x8 = dict()
    dict6x8 = dict()
    dict8x6 = dict()
    dict6x9 = dict()
    for shape_file in shape_files:
        path_to_shape_file = path_to_8x8_files + "/" + shape_file
        
        if not global_vars.test:
            print("shape file: " + shape_file)
            
        tile_number_str = shape_file[5:].replace(".txt","")
        
        if not global_vars.test:
            print("---tile number: " + tile_number_str)
            
            print("")

        tile,xsize,ysize = read_shape(path_to_shape_file)
        if(xsize!=8 or ysize!=8):
            print("Shape in file " + path_to_shape_file + " has wrong dimensions!")
            print(tile)
            return
            
        if global_vars.verbose:
            print(tile)
        
        if not global_vars.test:
            print("")
            print("7x8");
        shape7x8 = convert(tile,7,8,extend_algorithm)
        if not global_vars.test:
            display_shape(shape7x8)
        dict7x8[tile_number_str]=shape7x8
        
        if not global_vars.test:
            print("")
            print("6x8");
        shape6x8 = convert(tile,6,8,extend_algorithm)
        if not global_vars.test:
            display_shape(shape6x8)
        dict6x8[tile_number_str]=shape6x8
        
        if not global_vars.test:
            print("")
            print("8x6");
        shape8x6 = convert(tile,8,6,extend_algorithm)
        if not global_vars.test:
            display_shape(shape8x6)
        dict8x6[tile_number_str]=shape8x6
        
        if not global_vars.test:
            print("")
            print("6x9");
        shape6x9 = convert(tile,6,9,extend_algorithm)
        if not global_vars.test:
            display_shape(shape6x9)
        dict6x9[tile_number_str]=shape6x9
        if not global_vars.test:
            print("")
    # print(str(dict7x8))
    write_shapes(project,dict7x8,7,8)
    write_shapes(project,dict6x8,6,8)
    write_shapes(project,dict8x6,8,6)
    write_shapes(project,dict6x9,6,9)
    return


# Import as tiles all shapes from files named "shape<number>.txt" inside the directories in the "shapes" directory of a given project
def shapes(params):
    project_name = params[1]

    project_cat = project_category(project_name)
    
    if(len(params)>3):   # xsize, ysize parameters
        xsize_str,ysize_str = params[2:]
    elif len(params)==3: # target parameter 
        detected_xsize = detect_xsize(params[2])
        detected_ysize = detect_ysize(params[2])
        xsize_str = str(detected_xsize)
        ysize_str = str(detected_ysize)
        # if global_vars.verbose:
            # print("Detected xsize: " + xsize_str)
            # print("Detected ysize: " + ysize_str)
    else:                # no parameter
        xsize_str = "8"
        ysize_str = "8"
    if not global_vars.test:
        print("xsize: " + xsize_str)
        print("ysize: " + ysize_str)
    path_to_files = project_cat + "s/" + params[1] + "/shapes/" + xsize_str + "x" + ysize_str + "/"
    if not global_vars.test:
        print("Path to shape files: " + path_to_files)
    shape_files = files_in_path(path_to_files)
    if global_vars.verbose:
        print("shape files: ", shape_files)
    for shape_file in shape_files:
        if global_vars.verbose:
            print("processing file: ", shape_file)

        path_to_shape_file = path_to_files + str(shape_file)
        if global_vars.verbose:
            print("processing path file: ", path_to_shape_file)
        tile_number_str = shape_file[5:].replace(".txt","")
        
        print("tile number: " + tile_number_str)
        
        tile,xsize,ysize = import_tile(path_to_shape_file)
        
        if str(xsize)!=xsize_str or str(ysize)!=ysize_str:
            print("Shape in file " + path_to_shape_file + " has wrong dimensions!")
            print(tile)
            return
        print(tile)
        print_shape(compute_shape(tile,xsize))
        
        store_tile(project_name, tile, xsize, ysize, tile_number_str)
        
        print("")


# Show all commands
def commands(params):
    # Show full length commands
    for command, description in COMMANDS_DESCRIPTIONS.items():
        printc(bcolors.BOLD, command)
        spaces = " " * (10-len(command))
        print(spaces + " -> " + description)

    # Show short-hands
    print("")
    for short_command in SHORT_COMMANDS_LIST.items():
        printc(bcolors.BOLD, short_command[0])
        print(" -> ",end="")
        printc(bcolors.BOLD, short_command[1]+"\n")


# Show tile shapes of a given project
def show(params):
    parent_dir = project_category(params[1])+"s"
    
    if len(params)<4:
        xsize = "8"
        ysize = "8"
    else:
        xsize = params[2]
        ysize = params[3]

    if len(params)>=5:
        index = params[4]
    else:
        index = "";
    
    if index!="":
        print_shape_from_file(parent_dir, params[1], xsize, ysize, index)
    
    else:
        for i in range(NUMBER_OF_TILES):
            print_shape_from_file(parent_dir, params[1], xsize, ysize, i)
    

# def remove(params):
    # project = params[1]
    
    # target = params[2]
    
    # if global_vars.verbose:
        # print("project: " + project)
        # print("target: " + target)
    
    # proj_cat = project_category(project)
    # if global_vars.verbose:
        # print("project category: " + proj_cat)
    
    # if(proj_cat != "project"):
        # print("You cannot modify a built-in project")
        
    # new_target_path = "makefiles.common/targets/"
    
    # possible_targets = files_in_path(new_target_path)

    # if global_vars.verbose:

        # print("path: " + new_target_path)
        # print(possible_targets)
    
    # new_Makefile = "Makefile_" + target
    
    # if global_vars.verbose:

        # if new_Makefile in possible_targets:
            # print("Target found in list of candidate extra targets")
        # else:
            # print("Target not found in list of candidate extra targets")

    # project_path = "projects/" +  project

    # full_project_path = project_path + "/Makefile." + project
    
    # with open(full_project_path) as file:
        # project_makefile = file.read()

    # if global_vars.verbose:

        # if(target+":" in project_makefile):
            # print("Target present in " + full_project_path)
        # else:
            # print("Target not present in " + full_project_path)
            # return
    
    # full_new_target_path = new_target_path + new_Makefile

    # cleaned_project_makefile = re.sub(target+":(.*)(\r*\n){2}","",project_makefile, flags=re.MULTILINE|re.DOTALL)
    
    # command_string = "mv " + full_project_path + " " + full_project_path + "_BACKUP"
    # run_command_verbosely(command_string)
    
    # with open(full_project_path,'w') as file:
        # file.write(cleaned_project_makefile)


# def add(params):
    # project = params[1]
    
    # target = params[2]
    
    # if global_vars.verbose:
        # print("project: " + project)
        # print("target: " + target)
    
    # proj_cat = project_category(project)
    
    # if global_vars.verbose:
        # print("project category: " + proj_cat)
    
    # if(proj_cat != "project"):
        # print("You cannot modify a built-in project")
        
    # new_target_path = "makefiles.common/targets/"
    
    # if global_vars.verbose:
        # print("path: " + new_target_path)
    
    # possible_targets = files_in_path(new_target_path)
    # if global_vars.verbose:
        # print(possible_targets)
    
    # new_Makefile = "Makefile_" + target
    
    # if new_Makefile in possible_targets:
        # if global_vars.verbose:
            # print("Target found in list of candidate extra targets")
    # else:
        # print("Target not found in list of candidate extra targets")
        # return

    # project_path = "projects/" +  project

    # full_project_path = project_path + "/Makefile." + project
    
    # with open(full_project_path) as file:
        # project_makefile = file.read()
        
    # if(target+":" in project_makefile):
        # print("Target already present. First delete it from " + full_project_path)
        # return
    
    # full_new_target_path = new_target_path + new_Makefile
    
    # if global_vars.verbose:
        # print("Adding this Makefile target(s)")
    # command_string = "cat " + full_new_target_path
    # run_command_verbosely(command_string)
    # if global_vars.verbose:
        # print("\n")
    
    # command_string = "cat " + full_new_target_path + " >> " + full_project_path
    # run_command_verbosely(command_string)


def full_params(params):
    full_command = SHORT_COMMANDS_LIST.get(params[1])
    if(full_command is not None):
        if global_vars.verbose:
            print("Full command: " + str(full_command))
            print();
        # print(params)
        return ["", full_command] + params[2:]
        # print(params)
        # return
    else:
        return params


def help(params):
    if len(params)<2:
        printc(bcolors.BOLD,"\nxl <command> <[optional] parameters>")   
        print("\n(or xl <project> <[optional] parameters> as a shorthand for \n xl build <project> <[optional] parameters>)")
        print("")
        help_help()
    elif params[1] in COMMANDS_DESCRIPTIONS.keys():

        print("Help on ", end="") 
        printc(bcolors.OKCYAN, params[1]+"\n")
        print("It " + COMMANDS_DESCRIPTIONS[params[1]] + "\n")
        params = full_params(params)

        # if params[1]=="add":
            # printc(bcolors.BOLD,"\nxl add <project> <target>\n")
            # print("")
            # print("It adds support for the new target <target> into <project> by modifying its Makefile.")
            # print("")
            # print("Example:")
            # print("If you have previously created a new project 'foo'")
            # print("(e.g., by cloning it with 'xl clone bomber foo'),")
            # print("then you can add support for the 'einstein' target to it with")
            # print("xl add foo einstein")
            
        if params[1]=="assets":
            printc(bcolors.BOLD,"\nxl assets <project>\n")
            print("")
            print("It generates assets files for <project> (new or existing project) by using tile or shape files.")
            print("")
            print("Example:")
            print("Edit any shape file in ./projects/foo/shapes/8x8/")
            print("xl assets foo")
            print("xl show foo (to check the result)")
            print("The output will be in ./projects/foo/generated_assets/")
            
        elif params[1]=="split":
            printc(bcolors.BOLD,"\nxl split <file>\n")
            print("")
            print("It displays a shape file as two shapes, one for the left and one for the right side.")
            print("Example:")
            print("xl split games/shuriken/docs/16x12_multi_tile.txt")
            print("")
            print("...#####")
            print(".###....")
            print("##.....#")
            print("#..#####")
            print("#...#..#")
            print("#...####")
            print("##..#...")
            print(".###....")
            print("...#####")
            print("........")
            print("........")
            print("........")
            print("")
            print("#.......")
            print("###.....")
            print("..##....")
            print("...#....")
            print("...#....")
            print("#..#....")
            print("..##....")
            print("###.....")
            print("#.......")
            print("........")
            print("........")
            print("........")
            

        elif params[1]=="config":
            printc(bcolors.BOLD,"\nxl config\n")
            print("")
            print("It displays the configuration as read from config.ini")
            print("Example:")
            print("xl config")   
        elif params[1]=="extend":
            printc(bcolors.BOLD,"\nxl extend <project>\n")
            print("")
            print("It generates candidate shapes of different sizes from the 8x8 shapes of <project>.")
            print("Example:")
            print("In order to generate candidate shapes for foo using 8x8 shapes, you can do:")     
            print("xl extend foo")
        # elif params[1]=="remove":
            # printc(bcolors.BOLD,"\nxl remove <project> <target>\n")
            # print("")
            # print("It removes support for the new target <target> into <project> by modifying its Makefile.")
            # print("Remark: It does so by searching a regex in the concerned Makefile.")
            # print("        It removes the target in the Makefile.")
            # print("        For extra safety, a backup Makefile file with the previous content is also generated")
            # print("")
            # print("Example:")
            # print("If you have previously created a new project 'foo'")
            # print("(e.g., by cloning it with 'xl clone bomber foo'),")
            # print("then you can remove support for the 'einstein' target to it with")
            # print("xl remove foo einstein")
        elif params[1]=="make":
            printc(bcolors.BOLD,"\nxl make <project> <target>\n")
            print("")
            print("It re-builds <project> for <target> and its assets by using the pictorial text files in the shapes directory.")
            print("It is equivalent to:")
            print("xl shapes <project> <target>")
            print("xl rebuild <project> <target>")
            print("")
            print("Example:")
            print("xl make foo vic20")
            print("builds the project foo and its assets from the pictorial text file for the Vic 20")
        elif params[1]=="tools":
            printc(bcolors.BOLD,"\nxl tools\n")
            print("\n(or xl build tools)")
            print("")
            print("It builds some post-processing tools from their source code.")
            print("")
            print("This command has to be run only once to build the tools. The tools are used by few targets to generate ready to use images.")
        elif params[1]=="rename":
            printc(bcolors.BOLD,"\nxl rename <old project name> <new project name>\n")   
            print("It renames an existing user-defined project <old project name> to <new project name>.")
            print("")
            print("Remark: No matter the type of source project, the target project will be in the 'src/projects' directory")
            print("")
            print("Example:")
            print("If you have previously created a new project 'foo'")
            print("(e.g., by cloning it with 'xl clone bomber foo'),")
            print("then you can rename it to 'bar' with")
            print("xl rename foo bar")
        elif params[1]=="clone":
            printc(bcolors.BOLD,"\nxl clone <source project> <target project>\n")   
            print("It clones an existing project of any type to create a new user-defined project.")
            print("")
            print("Remark: No matter the type of source project, the target project will be in the 'src/projects' directory")
            print("")
            print("Example:")
            print("If you want to clone the built-in game Cross Horde you can just do:")
            print("xl clone horde foo")
            print("")
            print("If you have previously created a user-defined project 'foo',")
            print("you can further clone it with:")
            print("xl clone foo bar")
        elif params[1]=="show":
            printc(bcolors.BOLD,"xl show <project> <[optional] XTileSize> <[optional] YTileSize> <[optional] TileIndex>.\n")
            print("It displays the shape of graphics tiles of a given project.")
            print("")
            print("<project>")
            print("Use this mandatory parameter to specify the project whose tiles you want to display")
            print("")
            print("<XTileSize> <YTileSize>")
            print("These optional parameters specify the size of the tiles we want to see")
            print("")
            print("<TileIndex>")
            print("This optional parameter specifies which tile we want to display.")
            print("When no index is specified, then all tiles of the given shape are displayed.")
            print("")
            print("Example:")
            print("xl show chase 8 8 5")
            print("Decoding file tile: ./games/chase/tiles/8x8/tile5.txt")
            print("")
            print("..####..")
            print(".#....#.")
            print("#.#..#.#")
            print("#..##..#")
            print("#..##..#")
            print("#.#..#.#")
            print(".#....#.")
            print("..####..")
            
        elif params[1]=="size":
            printc(bcolors.BOLD,"xl size <project> <XSize> <YSize>\n")
            print("It builds <project> for the native host with screen size provided by <XSize> and <YSize>.")
            print("The built binaries will be in the 'build' directory.")

            print("\n<project>")
            print("<project> can also be 'games'/'examples'/'projects'/'all' to build multiple projects.")   
            
            print("\nxl size bomber 20 20       \n  It builds Cross Bomber for the native host with screen size 20x20.")
            print("\nxl reize examples 16 12     \n  It builds all examples for the native host with screen size 16x12.")

        elif params[1]=="run":
            printc(bcolors.BOLD,"xl run <project> <[optional] xsize> <[optional] ysize>\n")
            printc(bcolors.BOLD,"xl run <project> <[optional] target>\n")
            print("If no target is specified, it runs the previously compiled native version of <project>.")
            print("If integer parameters <xsize> and <ysize> are provided, then it runs the version of those sizes.")
            print("")
            print("<project>")
            print("This parameter is the name of the project that we want to run.")
            print("")
            print("<xsize> <ysize>")
            print("These parameters are the size of the native version that we want to run.")
            print("")
            print("<target>")
            print("This parameter is the target for which we want to run <project>.")
            print("This parameter only works for a restricted set of targets and it requires an emulator.")
            print("")
            print("Examples:")
            print("xl run snake")
            print("It runs the previously built (e.g., with 'xl build snake') native version of Cross Snake.")
            print("")  
            print("xl run snake 16 16")
            print("It runs the previously built with size 16X16 (with 'xl size snake 16 16') native version of Cross Snake.")
        elif params[1]=="manual":
            printc(bcolors.BOLD,"xl manual <[optional] routine>\n")
            print("If no optional parameter is passed it displays a list of documented CROSS-LIB APIs.")
            print("If a Cross-Lib C rouine is passed as an optional parameter, it displays its description and usage")
            print("")
            print("Documented commands:")
            list_documented_routines()
        elif params[1]=="string":
            printc(bcolors.BOLD,"xl string <string>\n")
            print("It converts a string litteral into a concatenation of")
            print('_XL_A,..., _XL_Z, _XL_a, ..., _XL_z, _XL_SPACE, "0", ..., "9"')
            print("<string>")
            print("This parameter is the string to convert. It has to match the regular expression '[A-Za-z0-9 ]*'.")
            print("")
            print("Example:")
            print('xl string "1 Hello World 2"')
            print('"1" _XL_SPACE _XL_H _XL_e _XL_l _XL_l _XL_o _XL_SPACE _XL_W _XL_o _XL_r _XL_l _XL_d _XL_SPACE "2"')
        elif params[1]=="rebuild":
            printc(bcolors.BOLD,"xl rebuild <project> <[optional] target>\n")
            print("It rebuilds <project>.")
            print("It is equivalent to 'xl reset' followed by 'xl build <project> <target>'")
            print("Use 'xl help reset' and 'xl help build' for more information")
        elif params[1]=="import":
            printc(bcolors.BOLD,"xl import <source_file> <[optional] project>\n")
            print("")
            print("<source_file>")
            print("It is an Assembly or BASIC file (e.g., an Assembly file exported from CharPad or VChar64).")
            print("For example in CharPad you can export the tile data with:")
            print("File->Import/Export->Text/Asm->Export All or File->Import/Export->Text/Asm->Export All")
            print("")
            print("<project>")
            print("If a project name is passed then the tiles are imported into <project> as 8x8 tiles")
            print("")
            print("Remark: For extra heuristics and some BASIC files use '-rip' option or 'xl rip'")
            print("")
            print("Example:")
            print("If you create a new project 'myname' with")
            print("xl create myname")
            print("You can import a tile into it from an Assembly file with something like this:")
            print("xl import ./assets/examples/tile_sets/asm/tile_8x6_shapeA.txt myname")
        elif params[1]=="rip":
            printc(bcolors.BOLD,"xl rip <source_file> <[optional] project>\n")
            print("")
            print("<source_file>")
            print("It is an Assembly or BASIC file (e.g., an Assembly file exported from CharPad or VChar64).")
            print("For example in CharPad you can export the tile data with:")
            print("File->Import/Export->Text/Asm->Export All or File->Import/Export->Text/Asm->Export All")
            print("")
            print("<project>")
            print("If a project name is passed then the tiles are imported into <project> as 8x8 tiles")
            print("")
            print("Example:")
            print("If you create a new project 'myname' with")
            print("xl create myname")
            print("You can import a tile into it from an Assembly file with something like this:")
            print("xl rip ./assets/examples/tile_sets/asm/tile_8x6_shapeA.txt myname")
        elif params[1]=="rotate":
            printc(bcolors.BOLD,"xl rotate <source_file> <[optional] project>\n")
            print("")
            print("It works similarly to 'xl rip <source> <[optional] project>' but rotates the result.")
            print("")
            print("<source_file>")
            print("It is an Assembly or BASIC file (e.g., an Assembly file exported from CharPad or VChar64).")
            print("For example in CharPad you can export the tile data with:")
            print("File->Import/Export->Text/Asm->Export All or File->Import/Export->Text/Asm->Export All")
            print("")
            print("<project>")
            print("If a project name is passed then the tiles are imported into <project> as 8x8 tiles")
            print("")
            print("Example:")
            print("If you create a new project 'myname' with")
            print("xl create myname")
            print("You can import a tile into it from an Assembly file with something like this:")
            print("xl rotate ./assets/examples/tile_sets/asm/tile_8x6_shapeA.txt myname")
        elif params[1]=="tile":
            printc(bcolors.BOLD,"xl tile <shape_file> <[optional] project> <[optional] tile_index>\n")
            print("It converts the pictorial text file file <shape_file> into a line that can be used as an asset file.")
            print("")  
            print("<shape_file>")
            print("The file <shape_file> describes with '#' and '.' the shape of a tile.")
            print("")
            print("<project>")
            print("This optional parameter specifies the project whose tile we want to modify")
            print("")
            print("<tile_index>")
            print("This parameter is the index of the tile we want to modify")
            
            print("\nPress ENTER to continue...")
            time.sleep(1)

            generic_input("")
                
            print("\nExample in 'src/examples/tiles/tile_shape0.txt':")
            print("...##...")
            print("..#..#..")
            print("...##...")
            print(".##..##.")
            print("#.####.#")
            print("# ####.#")
            print("..#..#..")
            print("..#..#..")
            print("")
            print("xl tile ./assets/examples/single_tiles/tile_shape0.txt")
            print("produces: ")
            print("24,36,24,102,189,189,36,36")
            print("")
            print("To be copied in 'tile_<index>.txt' in '<project>/tiles/8x8' to modify the shape.")
            print("Remark: run 'xl reset <project>' before rebuilding <project> with modified tiles.")

        elif params[1]=="shapes":
            printc(bcolors.BOLD,"xl shapes <project> <[optional] xsize> <[optional] ysize>\n")
            printc(bcolors.BOLD,"xl shapes <project> <[optional] target>\n")
            print("It converts all shape files into tiles and stores them as such in the project.") 
            print("It imports from files named 'shape<number>.txt' inside the directories in the 'shapes' directory of a given project")
            print("The shape file format is the one used by 'xl tile'. Run 'xl help tile' for more information.")
            print("If no optional parameter is passed, then 8x8 shape is assumed")
            print("If a target is passed as parameter it will guess xsize and ysize for that target.")
            print("")
            print("Example: ")
            print("Provided that you have a project named 'foo', the command")
            print("xl shapes foo 6 8")
            print("will import as tiles from all shape files 'shape<number>.txt' (found in './projects/foo/shapes/6x8') into './projects/foo/tiles/6x8/'")
            
        elif params[1]=="self":
            printc(bcolors.BOLD,"xl self\n")
            print("It tests itself by performing a sequence of 'xl' commands.")
            print("")
        elif params[1]=="unit-tests":
            printc(bcolors.BOLD,"xl self\n")
            print("It runs unit-tests on the script code.")
        elif params[1]=="compilers":
            printc(bcolors.BOLD,"xl self\n")
            print("It checks the presence of the most common compilers.")
        elif params[1]=="check":
            printc(bcolors.BOLD,"xl check <[optional] params>\n")
            print("It runs some check on the dependencies.")
            print("")
            print("<params>")
            print("If nothing is passed to <params>, then it performs several checks.")
            print("If <params> is 'compilers', then it checks the presence of the most common compilers.")
            print("If <params> is 'tools', then it checks the presence of the most common tools.")
            print("If <params> is 'emulators', then it checks the presence of the emulators used by xl.")
            print("If <params> is 'interpreters', then it checks the presence of the interpreters used by xl.")
            print("If <params> is 'libraries', then it checks the presence of the libraries used by xl.")
        elif params[1]=="test":
            printc(bcolors.BOLD,"xl test <[optional] params> <[optional] target>\n")
            print("It runs some operations to test 'xl'.")
            print("")
            print("<params>")
            print("If nothing is passed to <params>, then it performs several tests including the self-test.")
            print("If 'self' is passed to <params>, then it tests itself by performing a sequence of 'xl' commands.")
            print("If <params> is 'compilers', then it checks the presence of the most common compilers.")
            print("If <params> is 'tools', then it checks the presence of the most common tools.")
            print("If <params> is 'emulators', then it checks the presence of the emulators used by xl.")
            print("If <params> is 'interpreters', then it checks the presence of the interpreters used by xl.")
            print("If <params> is 'libraries', then it checks the presence of the libraries used by xl.")
            print("If <params> is a game/example/project, then it checks if a binary for <target> (native with omitted <target>), for that game/example/project can be built.")
            print('If <params> is "games" or "examples", then it checks if binaries for <target> (native with omitted <target>) can be built for all games/examples.')
            print("If 'z88dk_targets' is passed to <params>, then it compiles a test program using Z88DK.")
            print("If 'z88dk_targets_alt' is passed to <params>, then it compiles a simplified test program using both Z88DK compilers.")
            print("If 'cc65_targets' is passed to <params>, then it compiles a test program using CC65.")
            print("If 'cmoc_targets' is passed to <params>, then it compiles a test program using CMOC.")
            print("If 'lcc1802_targets' is passed to <params>, then it compiles a test program using LCC1802.")
            print("If 'stdio' is passed to <params>, then it compiles a test program using only stdio.h and the native compiler (defined in config.ini).")
            print("If 'unit-tests' is passed to <params>, then it runs unit-tests on the script code.")
        elif params[1]=="debug" or params[1]=="d":
            printc(bcolors.BOLD,"xl debug <project> <XSize> <YSize>")
            print("It builds <project> for the native host in debug mode with screen size provided by <XSize> and <YSize>.")
            print("The built binaries will be in the 'build' directory.")

            print("\n<project>")
            print("<project> can also be 'games'/'examples'/'projects'/'all' to build multiple projects.")   
            
            print("\nxl debug bomber 20 20       \n  It builds Cross Bomber for the native host in debug mode with screen size 20x20.")
            print("\nxl debug examples 16 12     \n  It builds all examples for the native host in debug mode with screen size 16x12.")

            
        elif params[1]=="files" or params[1]=="f":
            printc(bcolors.BOLD,"xl files\n")
            print("It shows the built binary files (the conent of the `build` directory).\n")
            print("Remark: 'xl files' can be shorten with `xl f`.")
            
        elif params[1]=="build":
            printc(bcolors.BOLD,"xl build <project> <[optional] target>\n")
            print("It builds <project> for <target>.")
            print("Remark: The 'build' command can be omitted.")
            print("The built binaries will be in the 'build' directory.")

            print("\n<project>")
            print("<project> can also be 'games'/'examples'/'projects'/'all' to build multiple projects")   
            
            print("\n<target>")
            print("If no <target> is passed, then the native target (terminal console) is considered.")
            print("\nIf '<dev-kit>_targets' is passed as <target> (e.g., 'cc65_targets'), \nthen the given project/s is/are built for all targets that use <dev-kit> to be compiled.")
            print("Possible dev-kits are: 'cc65', 'z88dk', 'cmoc', 'lcc1802'.") 
            print("\n[NOT recommended] If 'all' is passed as <target>, then the given project/s is/are built for all targets (it may take very long and it requires all supported compilers.") 
            
            print("\nPress ENTER to continue...")
            time.sleep(1)

            generic_input("")
            
            print("\nExamples:")
            print("\nxl build bomber vic20       \n  It builds Cross Bomber for the Commodore Vic 20 using CC65.")
            print("\nxl snake                    \n  It builds Cross Snake for the native target (terminal console).")
            print("\nxl chase cc65_targets       \n  It builds Cross Chase for all targets that use CC65 to be built.")
            print("\nxl games cpc                \n  It builds all games for the Amstrad CPC using Z88DK.")
            print("\nxl examples c64             \n  It builds all examples for the Commodore 64 using CC65.")
            print("\nxl horde all                \n  It builds Cross Horde for all its supported targets using all supported necessary compilers.")
            print("\nxl projects all             \n  It builds all built-in projects for all supported targets using all supported necessary compilers.")
            print("\nxl all c16                  \n  It builds all projects (games and examples and user-defined projects) for the Commodore 264 series using CC65.")
        elif params[1]=="create":
            printc(bcolors.BOLD,"xl create <project> <[optional] type>\n")
            print("It creates <project>.")
            
            print("\n<type>")
            print("If no <type> is passed, then the initial code will just display 'hello world'")
            print("If 'game' is passed as <type>, then the project is build with some initial template game code.")
            print("If 'apis' is passed as <type>, then the project is build with some code that shows how to use all APIs.")
            
            print("\nExamples:");
            print("\nxl create foo               \n  It builds a new project 'foo' with some initial code that display 'hello world' on the screen.")
            print("\nxl create bar game          \n  It builds a new project 'bar' with some initial game code (main loop, level loop, etc.).")
        elif params[1]=="delete":
            printc(bcolors.BOLD,"xl delete <project> <[optiona] interactive>\n")
            print("It removes <project>, i.e., it deletes its folder with its content (source code, graphics assets, makefile).")
            
            print("\n<project>")
            print("<project> cannot be a built-in project.")

            print("\n<interactive>")
            print("If '-y' is passed as <interactive>, then the command won't ask for confirmation.")

            print("\nExample:")
            print("\nxl delete foo               \n  It deletes the project 'foo'.")
            print("\nxl delete foo -y            \n  Same as above but no confirmation is asked.")   
        elif params[1]=="reset":
            printc(bcolors.BOLD,"xl reset <[optional] project>\n")
            print("It deletes temporary files created during the build process.")
            print("\n<project>")
            print("If no <project> is passed, only non-project specific temporary files are deleted.") 
            print("If the <project> parameter is used, then also project-specific temporary files are deleted (and in particular generated graphics assets).")

            
            print("\nExamples:")
            print("\nxl reset                    \n  It deletes non-project specific temporary files.")
            print("\nxl reset foo                \n  It deletes all temporary files (both generic and project-specific).")
        elif params[1]=="clean": 
            printc(bcolors.BOLD,"xl clean <[optional] project>\n")
            print("It deletes both built binaries and temporary files created during the build process.")
            print("\n<project>")
            print("If no <project> is passed, only built binaries and non-project specific temporary files are deleted.") 
            print("If the <project> parameter is used, then also project-specific temporary files are deleted (e.g., generated graphics assets).")
            
            print("\n<interactive>")
            print("If '-y' is passed as <interactive>, then the command won't ask for confirmation.")
            
            print("\nExamples:")
            print("\nxl clean                    \n  It deletes all built binaries and non-project specific temporary files.")
            print("\nxl clean foo                \n  It deletes all built-in binaries and all temporary files (both generic and project-specific).")

        elif params[1]=="list" or params[1]=="l":  
            printc(bcolors.BOLD,"xl list <[optional] params>\n")
            print("It lists current projects in a given category or all projects.")
            print("")
            print("<params>")
            print("If nothing is passed as <params> then all projects are built")
            print("If 'games','examples' or 'projects' is passed as <params> then only projects in the respective directory are listed")
            print("\nExamples:")
            print("xl list                       \n  It lists all projects (games, examples and new projects)")
            print("xl list projects              \n  It lists all user-defined projects") 
            
        elif params[1]=="commands":
            printc(bcolors.BOLD,"xl commands\n")
            print("It displays the available commands.")
            
        elif params[1]=="help" or params[1]=="h":
            printc(bcolors.BOLD,"xl help <[optional] command>\n")
            print("It displays help instructions.")
            
            
            print("\n<command>")
            help_help()
    elif params[1] in list_of_documented_routines():
        manual(params)
    
    else:
        print("Command not recognized")
        help_help()


def list_of_documented_routines():
    manual_files = files_in_path("../docs/manual/")
    documented_routines = []
    for manual_file in manual_files:
        documented_routines.append(manual_file.replace(".txt",""))
    return documented_routines

def list_documented_routines():
    documented_routines = list_of_documented_routines()
    for documented_routine in documented_routines:
        print(documented_routine)

def manual(params):
    if len(params)==1:
        printc(bcolors.OKCYAN, "DOCUMENTED ROUTINES\n")
        list_documented_routines()
        print("")
        print("Use")
        printc(bcolors.BOLD,"xl manual <routine>\n")
        return
    elif params[1].startswith("_XL") or params[1] in ["XSize", "YSize"]:
        command_string = "cat ../docs/manual/" + params[1] + ".txt"
    else:
        command_string = "cat ../docs/manual/_XL_" + params[1] + ".txt"
    res = os.system(command_string)
    if res:
        printc(bcolors.WARNING,"\nCommand/topic not found\n")

# ---------------------------------------------


# ---------------------------------------------
#  System               Value               
# ---------------------------------------------
#  Linux                linux or linux2 (*) 
#  Windows              win32               
#  Windows/Cygwin       cygwin              
#  Windows/MSYS2        msys                
#  Mac OS X             darwin              
#  OS/2                 os2                 
#  OS/2 EMX             os2emx              
#  RiscOS               riscos              
#  AtheOS               atheos              
#  FreeBSD 7            freebsd7            
#  FreeBSD 8            freebsd8            
#  FreeBSD N            freebsdN            
#  OpenBSD 6            openbsd6            
# ---------------------------------------------

def read_config_option(section, option):
        if config.has_option(section,option):
            return config.get(section,option)
        else:
            return ""

def read_config(config_file="./config.ini"):
    try:
        import configparser
    except ImportError:
        # Python 2.x fallback
        print("Python 2.x configuration")
        import ConfigParser as configparser
    
    global compilation_threads
    global parallelize_multi_build
    global z88dk_compiler_opts 
    global z88dk_compiler
    global sccz80_compiler_opts
    global zsdcc_compiler_opts
    global cmoc_compiler_opts
    global cc65_compiler_opts
    global lcc1802_compiler_opts
    global gcc4ti99_compiler_opts
    global native_compiler_opts

    global native_compiler
    
    global tool_compiler     
    
    global interactive_clean
    
    global vice_path
    global vice_rom_path
    
    global mame_path
    global mame_rom_path
    
    global extend_algorithm
    
    global replace_shapes
    
    global use_tools
    
    global config 

    config = configparser.ConfigParser()
    
    try:

        # candidate_conf = config_dir+'/config.ini'
        # if os.path.exists(candidate_conf):
            # print("Read configuration from " + candidate_conf, flush=True)
            # config.read(candidate_conf)
        # else:
            # print("Use general config")
        
        config.read(config_file)
        
        global_vars.test = read_config_option("terminal","test")
        if global_vars.test!="":
            global_vars.test=int(global_vars.test)
        else:
            global_vars.test=0
        if global_vars.test:
            print("Test Mode ON")
        
        global_vars.verbose = read_config_option("terminal","verbose")
        if global_vars.verbose!="":
            global_vars.verbose=int(global_vars.verbose)
        else:
            global_vars.verbose=0
        if global_vars.verbose:
            print("----------------------------")
            print("Verbose Mode ON")
        
        # global color_terminal
        global_vars.color_terminal = read_config_option("terminal","color")
        
        if global_vars.verbose:
            if global_vars.color_terminal:
                printc(bcolors.OKCYAN, "Color terminal ON\n")
            else:
                print("Color terminal OFF")
        
        if global_vars.verbose:
            print("Config file found with: " + str(config.sections()))
            # print("")
        
        compilation_threads = read_config_option("build","threads") 
        if compilation_threads=="auto" or compilation_threads=="automaic":
            if global_vars.verbose:
                print("----------------------------")
            import multiprocessing
            compilation_threads = str(multiprocessing.cpu_count())
            if global_vars.verbose:
                print("Detected " + compilation_threads + " threads...")
                print("----------------------------")

        parallelize_multi_build = read_config_option("build","parallelize_multi_build") 
        if parallelize_multi_build!="":
            parallelize_multi_build=int(parallelize_multi_build)
        else:
            parallelize_multi_build=0
            
        z88dk_compiler_opts = read_config_option("build","z88dk_compiler_opts") 
        z88dk_compiler = read_config_option("build","z88dk_compiler")
        sccz80_compiler_opts = read_config_option("build","sccz80_compiler_opts")
        zsdcc_compiler_opts = read_config_option("build","zsdcc_compiler_opts")
        cmoc_compiler_opts = read_config_option("build","cmoc_compiler_opts")
        cc65_compiler_opts = read_config_option("build","cc65_compiler_opts")
        lcc1802_compiler_opts = read_config_option("build","lcc1802_compiler_opts")
        gcc4ti99_compiler_opts = read_config_option("build","gcc4ti99_compiler_opts")
        native_compiler_opts = read_config_option("build","native_compiler_opts")

        native_compiler = read_config_option("build", "native_compiler")
        
        tool_compiler = read_config_option("tools", "tool_compiler")
        
        interactive_clean = read_config_option("clean", "interactive")
        
        vice_path = read_config_option("run", "vice_path")
        vice_rom_path = read_config_option("run", "vice_rom_path")
        
        mame_path = read_config_option("run", "mame_path")
        mame_rom_path = read_config_option("run", "mame_rom_path")
        
        extend_algorithm = read_config_option("extend", "extend_algorithm")
        
        replace_shapes = read_config_option("extend", "replace_shapes")
        
        use_tools = read_config_option("build", "use_tools")
        
        if interactive_clean!="":
            interactive_clean = int(interactive_clean)
        
        if replace_shapes!="":
            replace_shapes = int(replace_shapes)

        if use_tools!="":
            use_tools = int(use_tools)
        
    except Exception as e:
        print("An exception occurred while reading the configuration: " + str(e))
        raise
        # TODO: Ask the user to continue or exit
    else:
        if global_vars.verbose:
            printc(bcolors.OKBLUE, "config.ini OK\n")
            # print("")


def default_config():
    
    global compilation_threads
    global parallelize_multi_build
    global sccz80_compiler_opts
    global z88dk_compiler_opts 
    global z88dk_compiler
    global zsdcc_compiler_opts
    global cmoc_compiler_opts
    global cc65_compiler_opts
    global lcc1802_compiler_opts
    global gcc4ti99_compiler_opts
    global native_compiler_opts

    global native_compiler
    
    global tool_compiler     
    
    global interactive_clean
    
    global vice_path
    global vice_rom_path
    
    global mame_path
    global mame_rom_path
    
    global extend_algorithm
    
    global replace_shapes
    
    global use_tools
    
    
    global_vars.verbose = True 
    compiler_opts = ""
    compilation_threads = 1
    parallelize_multi_build = 0
    zsdcc_compiler_opts = ""
    sccz80_compiler_opts = ""
    z88dk_compiler_opts = ""
    z88dk_compiler = "sccz80"
    cmoc_compiler_opts = ""
    gcc4ti99_compiler_opts = ""
    native_compiler_opts = ""
    native_compiler = "gcc"
    tool_compiler = "gcc"  
    cc65_compiler_opts = "-O -Cl"
    lcc1802_compiler_opts = '"-Wf-volatile" -O "-Wp-D nofloats" "-Wa-D LCCNOLONG" "-Wf-mulcall"' 
    gcc4ti99_compiler_opts = "-O2"
    use_tools = 0
    global_vars.color_terminal = 0


def display_config():
    
    printc(bcolors.BOLD,"[terminal]\n")
    
    print("verbose: " + str(global_vars.verbose))
    print("test: " + str(global_vars.test))
    
    print("color: " + str(global_vars.color_terminal))

    print("")
    
    printc(bcolors.BOLD,"[build]\n")
    print("compilation_threads: " + str(compilation_threads))
    print("parallelize_multi_build: " + str(parallelize_multi_build))

    print("z88dk_compiler: " + z88dk_compiler)
    print("z88dk_compiler_opts: " +  z88dk_compiler_opts)
    print("sccz80_compiler_opts: " + sccz80_compiler_opts)
    print("zsdcc_compiler_opts: " +  zsdcc_compiler_opts)
    print("cmoc_compiler_opts: " +  cmoc_compiler_opts)
    print("cc65_compiler_opts: " +  cc65_compiler_opts)
    print("lcc1802_compiler_opts: " +  lcc1802_compiler_opts)
    print("gcc4ti99_compiler_opts: " +  gcc4ti99_compiler_opts)
    print("native_compiler_opts: " +  native_compiler_opts)

    print("native_compiler: " +  native_compiler)
    print("tool_compiler: " +  tool_compiler)

    print("")
    
    printc(bcolors.BOLD,"[clean]\n")
    print("interactive_clean: " + str(interactive_clean))


    print("")
    printc(bcolors.BOLD,"[run]\n")
    print("vice_path: " +  vice_path)
    print("vice_rom_path: " +  vice_rom_path)
    print("mame_path: " +  mame_path)
    print("mame_rom_path: " +  mame_rom_path)

    print("")
    printc(bcolors.BOLD,"[extend]\n")
    print("extend_algorithm: " +  extend_algorithm)
    print("replace_shapes: " +  str(replace_shapes))

    print("")
    printc(bcolors.BOLD,"[tools]\n")
    print("use_tools: " + str(use_tools))
 

def make_assets_from_tiles(params):
    
    game_dir = params[1]
    
    project_type = project_category(game_dir)
    parent_dir = project_type + "s"    
    
    run_command_verbosely(GNU_MAKE+" GAME_NAME=" + game_dir + " PARENT_DIR=" + parent_dir + " -f ./makefiles.common/auxiliary/Makefile_assets") 




# ---------------------------------------------
if __name__ == "__main__":

    make_test = test_make(False)

    if make_test['gmake']:
        GNU_MAKE = "gmake"
    else:
        # print(make_test['make'])
        GNU_MAKE = "make"

    
    if python_version<2 or (python_version<=2 and python_subversion<7):
        print("Python version not supported")
        exit()
    try:
        read_config()
    except:
        default_config()
        print("WARNING: Using default config")

    if parallelize_multi_build:   
        from multiprocessing import Pool

    if global_vars.verbose:
        print("----------------------------")
        printc(bcolors.OKGREEN, "Cross-Lib `xl` helper script\n")
        print("----------------------------")
        print("Platform: " + platform)
        print("Python:   " + str(python_version) + "." + str(python_subversion))

            
        print("GNU MAKE command: " + GNU_MAKE)
        print("----------------------------")
        print("")

    

    if len(sys.argv)<2:
        print("For more commands, use the non-interactive mode.")
        printc(bcolors.BOLD, "xl help")
        print(" for instructions.")
        # if len(sys.argv)==1:
            # help(sys.argv[1:])
        
        # print("")
        print("")
        print("--------------------------------------------------")
        printc(bcolors.OKCYAN, "Interactive mode\n")
        print("--------------------------------------------------")
        print("")
        
        project_name = generic_input("Insert project to build\n")
        
        if project_name=="" or project_name=="\n":
            project_name="helloworld"
            if global_vars.verbose:
                printc(bcolors.WARNING,"Defaulting to helloworld\n")
        
        print("")
        
        target_name = generic_input("Insert target name\n")
        if target_name=="" or target_name=="\n":
            target_name="ncurses"
            if global_vars.verbose:
                printc(bcolors.WARNING, "Defaulting to ncurses\n")
        
        print("")
        time.sleep(1)
        
        params = ["build", project_name, target_name]
    else:
        params = sys.argv            
        params = full_params(params)
        
    if params[1]=="run":
        run(params[1:])
    elif params[1]=="check":
        check(params[1:])
    elif params[1]=="compilers":
        test(["test","compilers"])
    elif params[1]=="unit-tests":
        test(["test","unit-tests"])
    elif params[1]=="self":
        if(len(params)<3):
            test_self()
        else:
            test_self(params[2])
    elif params[1]=="assets":
        shapes(params[1:])    
        make_assets_from_tiles(params[1:])
    elif params[1]=="split":
        split(params[1:])
    elif params[1]=="config":
        display_config()
    # elif params[1]=="add":
        # add(params[1:])
    # elif params[1]=="remove":
        # remove(params[1:])
    elif params[1]=="string":
        string(params[1:])
    elif params[1]=="commands":
        commands(params[1:])
    elif params[1]=="import":
        import_from_source(params[1:],False)
    elif params[1]=="rotate":
        rip(params[1:],True)
    elif params[1]=="rip":
        rip(params[1:],False)
    elif params[1]=="rebuild":
        rebuild(params[1:])
    elif params[1]=="make":
        shapes(params[1:])
        rebuild(params[1:])    
    elif params[1]=="rename":
        rename(params[1:])
    elif params[1]=="clone":
        clone(params[1:])
    elif params[1]=="show":
        show(params[1:])
    elif params[1]=="test":
        test(params[1:])
    elif params[1]=="tile":
        tile(params[1:])
    elif params[1]=="shapes":
        shapes(params[1:])
    elif params[1]=="extend":
        extend(params[1:])
    elif params[1]=="build":
        build(params[1:])
    elif params[1]=="manual":
        manual(params[1:])
    elif params[1]=="files":
        files()
    elif params[1]=="size":
        size(params[1:],0)
    elif params[1]=="debug":
        size(params[1:],1)
    elif params[1]=="create":
        create(params[1:])
    elif params[1]=="clean":
        if interactive_clean:
            clean(params[1:])
        else:
            clean(params[1:]+["-y"])
    elif params[1]=="reset":
        reset(params[1:])
    elif params[1]=="delete":
        delete(params[1:])
    elif params[1]=="list":
        list(params[1:])
    elif params[1]=="help":
        help(params[1:])
    elif params[1]=="tools":
        tools()
    elif params[1] in list_of_projects("all") + ["examples"] + ["games"] + ["projects"] + ["all"]:
        build(params)
    else:
        manual(params)
