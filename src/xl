#!/usr/bin/env python

from __future__ import print_function

import datetime
import shutil
import os
import sys
import time

from os import walk

sys.path.append("modules")

from modules.strings import *
from modules.import_from_source import *
from modules.tiles import *
from modules.LoggerSingleton import LoggerSingleton
from modules.init import *
from modules.default_values import insert_default_sizes
from modules.params import \
    handle_two_letter_params, full_params, COMMANDS_LIST, get_size_params
from modules.help_functions import help_command, manual
from modules.file_functions import files, convert_makefile, files_in_path, dirs_in_path, built_files_in_path, list_of_projects, list_projects
from modules.tests import *
from modules.split_projects import *
from modules.run import run_command, run
from modules.commands import commands
from modules.input_functions import generic_input, are_you_sure
from modules.option_functions import *
from modules.project_functions import rename, clone, create
from modules.target_defs import *
from modules.shape_functions import *

DEFAULT_COMPILATION_THREADS = 4

# LoggerSingleton.initLogger(__name__)
logger = LoggerSingleton.initLogger('xl', '../logs')

# console_logger = LoggerSingleton.initConsoleLogger('console')

# console_logger.info('Console logger started')

logger.info('Started')

def clean_test(option_config):
    clean(option_config, ["clean"])
    files_after_clean = len(files_in_path("../build"))

    if files_after_clean>1:
        printc(option_config, bcolors.FAIL, "[xl clean]          KO\n")
        return 0
    printc(option_config, bcolors.OKGREEN, "[xl clean]          OK\n")
    return 1


def multiple_project_reset(option_config, mypath):
    projects = []
    for (_, dirnames, _) in walk(mypath):
        projects.extend(dirnames)
        break

    for project_name in projects:
        print("PROJECT: " + project_name)
        reset(option_config, [mypath, project_name])
        print("\n")


def multiple_size_build(mypath,target,xsize,ysize,debug):
    projects = []
    for (_, dirnames, _) in walk(mypath):
        projects.extend(dirnames)
        break

    if use_tools:
        use_tools_str = " USE_TOOLS=1 "
    else:
        use_tools_str = ""

    for project_name in projects:

        if is_project_split(project_name):
            project_type = project_category(project_name)
            create_main(project_name,project_type)
        make_command = \
            GNU_MAKE + " " + target + use_tools_str + " XSIZE=" + xsize +  \
                       " YSIZE=" + ysize + " _DEBUG_FLAG=" + str(debug) + \
                " _NATIVE_CC=" + native_compiler + " " + all_compilers_opts(all_compilers_opts, "","") + \
                " GNU_MAKE=" + GNU_MAKE + \
                " TOOL_CC=" + tool_compiler + \
                " -f " + mypath+"/"+project_name+"/Makefile."+project_name

        run_command(option_config, make_command)
        if is_project_split(project_name):
            delete_main(option_config, project_name,project_type)


def multiple_build(option_config, mypath,target,threads,zsdcc_extra_optimization, reset_flag=False):
    projects = []

    verbose = option_config.terminal_config.verbose

    compilation_threads, \
    compilation_threads_string, \
    parallelize_multi_build, \
    z88dk_compiler, \
    z88dk_compiler_opts, \
    sccz80_compiler_opts, \
    zsdcc_compiler_opts, \
    cmoc_compiler_opts, \
    cc65_compiler_opts, \
    lcc1802_compiler_opts, \
    gcc4ti99_compiler_opts, \
    vbcc_compiler_opts, \
    native_compiler_opts, \
    native_compiler, \
    tool_compiler, \
    use_tools \
    = option_config.build_config.get_opts()

    if use_tools:
        use_tools_str = " USE_TOOLS=1 "
    else:
        use_tools_str = ""

    for (_, dirnames, _) in walk(mypath):
        projects.extend(dirnames)
        break

    projects_to_build = len(projects)

    if verbose:
        print("Building " + str(projects_to_build) + " projects: ", end="")
        for project_name in projects:
            printc(option_config, bcolors.OKCYAN,project_name+" ")
        print("")

    if (parallelize_multi_build==1) and (target in PARALLEL_TARGETS):
        logger.info("Parallelize multi build with %s", threads)
        pool = Pool(processes=int(threads))

        for project_name in projects:
            if verbose:
                print("project name: " + project_name)
            if reset_flag:
                reset(option_config, ["",project_name])
            if is_project_split(project_name):
                project_type = project_category(project_name)
                create_main(project_name,project_type)
            make_command = \
                GNU_MAKE + " " + target + use_tools_str + \
                    " ZSDCC_MAKEFILE_THREADS_OPTS=\'-j " + threads + "'" \
                    + all_compilers_opts(option_config, zsdcc_extra_optimization, "") + \
                    " _NATIVE_CC=" + native_compiler + \
                    " TOOL_CC=" + tool_compiler + " GNU_MAKE=" + GNU_MAKE + \
                    " -f " + mypath+"/"+project_name+"/Makefile."+project_name
            pool.apply_async(run_command, [option_config, make_command])

        pool.close()
        pool.join()

        for project_name in projects:
            if is_project_split(project_name):
                delete_main(option_config, project_name,project_type)
    else:
        for project_name in projects:
            if reset_flag:
                reset(option_config, ["",project_name])
            if verbose:
                print("project name: " + project_name)
            if is_project_split(project_name):
                project_type = project_category(project_name)
                create_main(project_name,project_type)
            make_command = \
                GNU_MAKE + " " + target + use_tools_str + \
                    " ZSDCC_MAKEFILE_THREADS_OPTS=\'-j " + threads + "'" \
                    + all_compilers_opts(option_config, zsdcc_extra_optimization, "") + \
                    " _NATIVE_CC=" + native_compiler + \
                    " TOOL_CC=" + tool_compiler + " GNU_MAKE=" + GNU_MAKE + \
                    " -f " + mypath+"/"+project_name+"/Makefile."+project_name

            run_command(option_config, make_command)
            if is_project_split(project_name):
                delete_main(option_config, project_name,project_type)


# Run a project natively (terminal with ncurses) with a given XSize and YSize
def size(option_config, params,debug):
    verbose = option_config.terminal_config.verbose
    if len(params)<2:
        game_dir = "helloworld"
    else:
        game_dir = params[1]

    project_type = project_category(game_dir)

    parent_dir = project_type + "s"

    target, xsize, ysize = get_size_params(params)

    if verbose:
        print("Project name       : " + game_dir)
        print("Project type       : " + project_type)
        print("XSize: " + xsize)
        print("YSize: " + ysize)
        print("target: " + target)

    parent_and_game_dir = parent_dir + "/" + game_dir

    files_before = len(files_in_path("../build"))-1

    if game_dir not in ["games", "examples", "projects", "all"]:
        if not os.path.exists(parent_and_game_dir):
            print("Project not found!")
            return
        native_compiler = option_config.build_config.native_compiler
        tool_compiler   = option_config.build_config.tool_compiler
        if is_project_split(game_dir):
            if verbose:
                printc(option_config, bcolors.OKBLUE,"Create main.c from split source files\n")
            create_main(game_dir, project_type)
        make_command = \
            GNU_MAKE + " " + target + " XSIZE=" + xsize +  " YSIZE=" + ysize + \
                " _DEBUG_FLAG=" + str(debug) + " " \
                + all_compilers_opts(option_config, "","") + \
                " _NATIVE_CC=" + native_compiler + \
                " TOOL_CC=" + tool_compiler + \
                " -f " + parent_dir+"/"+game_dir+"/Makefile."+game_dir
        run_command(option_config, make_command)

        if is_project_split(game_dir):
            if verbose:
                printc(option_config, bcolors.OKBLUE,"Delete main.c (because of split source files)\n")
            delete_main(option_config, game_dir, project_type)
    else:
        if game_dir in["games","examples","projects"]:
            multiple_size_build(game_dir,target,xsize,ysize,debug)
        elif game_dir in["new"]:
            multiple_size_build("projects",target,xsize,ysize,debug)
        elif game_dir in["builtin","built-in"]:
            multiple_size_build("games",target,xsize,ysize,debug)
            multiple_size_build("examples",target,xsize,ysize,debug)
        elif game_dir=="all":
            multiple_size_build("games",target,xsize,ysize,debug)
            multiple_size_build("examples",target,xsize,ysize,debug)
            multiple_size_build("projects",target,xsize,ysize,debug)
        else:
            return

    files_after = len(files_in_path("../build"))-1

    if verbose:
        print("New binaries built: " + str(files_after-files_before)+"\n")


# Rebuild a project, i.e., also rebuilds assets
def rebuild(option_config, params):
    build(option_config, params, reset_flag=True)


# Generate tools from source code
def tools(option_config):
    compilation_threads = option_config.build_config.compilation_threads
    tool_compiler = option_config.build_config.tool_compiler
    make_command = \
        GNU_MAKE + " -j " + compilation_threads + " tools TOOL_CC=" + tool_compiler + \
        " GNU_MAKE=" + GNU_MAKE + " -f makefiles.common/auxiliary/Makefile_tools"
    run_command(option_config, make_command)


# Build a project (for a target or multiple targets)
def build(option_config, params, reset_flag = False):
    params = insert_default_sizes(params)

    # sized terminal
    if len(params)>=4 and params[2].startswith("terminal") and params[3].isnumeric() \
                      and params[4].isnumeric():
        size(option_config, ["size"] + params[1:],0)
        return

    if len(params)<2:
        game_dir = "helloworld"
    else:
        game_dir = params[1]

    if len(params)>=1 and game_dir=="tools":
        tools(option_config)
    else:

        files_before = len(files_in_path("../build"))-1

        project_type = project_category(game_dir)
        parent_dir = project_type + "s"

        if len(params)<3:
            target = "ncurses"
        else:
            target = params[2]

        if target in ["cc65", "z88dk", "cmoc", "lcc1802", "cc6303", "gcc4ti", "vbcc"]:
            target = target + "_targets"

        compilation_threads, \
        compilation_threads_string, \
        parallelize_multi_build, \
        z88dk_compiler, \
        z88dk_compiler_opts, \
        sccz80_compiler_opts, \
        zsdcc_compiler_opts, \
        cmoc_compiler_opts, \
        cc65_compiler_opts, \
        lcc1802_compiler_opts, \
        gcc4ti99_compiler_opts, \
        vbcc_compiler_opts, \
        native_compiler_opts, \
        native_compiler, \
        tool_compiler, \
        use_tools \
        = option_config.build_config.get_opts()


        # compilation_threads = option_config.build_config.compilation_threads
        if len(params)<4:
            threads = str(compilation_threads)
        else:
            threads = params[3]

        # zsdcc_extra_optimization = option_config.build_config.zsdcc_extra_optimization
        if len(params)>=5 and params[4]=="on":
            zsdcc_extra_optimization = "--max-allocs-per-node200000"
        else:
            zsdcc_extra_optimization = ""

        # compiler_opts = option_config.build_config.compiler_opts
        if len(params)>=6:
            compiler_opts = " " + params[5]
        else:
            compiler_opts = ""

        color_terminal = option_config.terminal_config.color_terminal

        verbose = option_config.terminal_config.verbose

        if verbose:

            print("Project name       : ", end="")
            printc(option_config, bcolors.BOLD, game_dir+"\n")

            print("Target name        : ", end="")
            printc(option_config, bcolors.UNDERLINE, target+"\n")

            print("Project type       : " + project_type)
            print("Number of threads  : " + threads)
            print("Extra optimization : " + zsdcc_extra_optimization)
            print("Compiler's options : " + compiler_opts)

            print("--------------------------")
            print("z88dk_compiler_opts     : " + z88dk_compiler_opts)
            print("zsdcc_compiler_opts     : " + zsdcc_compiler_opts)
            print("cmoc_compiler_opts      : " + cmoc_compiler_opts)
            print("cc65_compiler_opts      : " + cc65_compiler_opts)
            print("lcc1802_compiler_opts   : " + lcc1802_compiler_opts)
            print("gcc4ti99_compiler_opts  : " + gcc4ti99_compiler_opts)
            print("vbcc_compiler_opts      : " + vbcc_compiler_opts)
            print("native_compiler_opts    : " + native_compiler_opts)

            print("")

        parent_and_game_dir = parent_dir + "/" + game_dir

        if os.path.exists(parent_and_game_dir + "/config.ini"):
            print("Local config.ini detected")
            read_config(parent_and_game_dir + "/config.ini")

        if game_dir not in ["games", "examples", "projects", "all"]:
            if reset_flag:
                reset(option_config, params)
            if not os.path.exists(parent_and_game_dir):
                print("Project not found!")
                return
            if use_tools:
                use_tools_str = " USE_TOOLS=1 "
            else:
                use_tools_str = ""

            if is_project_split(game_dir):
                if verbose:
                    printc(option_config, bcolors.OKBLUE,"Create main.c from split source files\n")
                create_main(game_dir, project_type)

            make_command = \
                GNU_MAKE + " " + target + \
                    use_tools_str + \
                    " ZSDCC_MAKEFILE_THREADS_OPTS=\'-j " + threads + "' " \
                    + all_compilers_opts(option_config, zsdcc_extra_optimization, compiler_opts) +  \
                    " _NATIVE_CC=" + native_compiler + \
                    " TOOL_CC=" + tool_compiler + " GNU_MAKE=" + GNU_MAKE + \
                    " -f " + parent_dir+"/"+game_dir+"/Makefile."+game_dir

            run_command(option_config, make_command)

            if is_project_split(game_dir):
                if verbose:
                    printc(option_config, bcolors.OKBLUE,"Delete main.c because of split source files\n")
                delete_main(option_config, game_dir, project_type)

        else:
            if game_dir in ["games","examples","projects"]:
                multiple_build(option_config, game_dir,target,threads,zsdcc_extra_optimization, reset_flag)
            elif game_dir=="new":
                multiple_build(option_config, "projects",target,threads,zsdcc_extra_optimization, reset_flag)
            elif game_dir in ["builtin","built-in"]:
                multiple_build(option_config, "games",target,threads,zsdcc_extra_optimization, reset_flag)
                multiple_build(option_config, "examples",target,threads,zsdcc_extra_optimization, reset_flag)
            elif game_dir=="all":
                multiple_build(option_config, "games",target,threads,zsdcc_extra_optimization, reset_flag)
                multiple_build(option_config, "examples",target,threads,zsdcc_extra_optimization, reset_flag)
                multiple_build(option_config, "projects",target,threads,zsdcc_extra_optimization, reset_flag)
            else:
                return

        files_after = len(files_in_path("../build"))-1

        if verbose:
            printc(option_config, bcolors.OKBLUE, "New binaries built: " + str(files_after-files_before)+"\n")


def slow(option_config, params):

    verbose = option_config.terminal_config.verbose
    game_dir = params[1]

    project_type = project_category(game_dir)
    parent_dir = project_type + "s"

    if len(params)>=4:
        target = params[2]
        slowdown = params[3]
    elif len(params)==3:
        target = NATIVE_TARGET
        slowdown = params[2]
    else:
        printc(option_config, bcolors.FAIL, "Wrong number of arguments")
        sys.exit(-1)
    parent_and_game_dir = parent_dir + "/" + game_dir

    if os.path.exists(parent_and_game_dir + "/config.ini"):
        print("Local config.ini detected")
        read_config(parent_and_game_dir + "/config.ini")

    if not os.path.exists(parent_and_game_dir):
        print("Project not found!")
        return

    if is_project_split(game_dir):
        if verbose:
            printc(option_config, bcolors.OKBLUE,"Create main.c from split source files\n")
        create_main(game_dir, project_type)

    make_command = \
        GNU_MAKE + " " + target + \
            " SLOWDOWN=" + slowdown + \
            all_compilers_opts(option_config, "", "") +  \
            " -f " + parent_dir+"/"+game_dir+"/Makefile."+game_dir

    run_command(option_config, make_command)

    if is_project_split(game_dir):
        if verbose:
            printc(option_config, bcolors.OKBLUE,"Delete main.c because of split source files\n")
        delete_main(option_config, game_dir, project_type)


# Delete temporary project files If a project is specified, it also deletes generated assets.
def reset(option_config, params):
    verbose = option_config.terminal_config.verbose
    par_len = len(params)

    if par_len>1:
        game_dir = params[1]
    else:
        game_dir=""

    if game_dir in ["games","examples","projects"]:
        multiple_project_reset(option_config, game_dir)
        return
    if game_dir=="new":
        multiple_project_reset(option_config, "projects")
        return
    if game_dir in ["builtin","built-in"]:
        multiple_project_reset(option_config, "games")
        multiple_project_reset(option_config, "examples")
        return
    if game_dir=="all":
        multiple_project_reset(option_config, "games")
        multiple_project_reset(option_config, "examples")
        multiple_project_reset(option_config, "projects")
        return

    if len(params)<2:
        make_command = GNU_MAKE + \
                       " clean_generic_no_built_in -f makefiles.common/auxiliary/Makefile_common"
        if verbose:
            print("Delete all non-project-specific temporary files")
        run_command(option_config, make_command)
        return

    game_dir = params[1]

    project_type = project_category(game_dir)

    parent_dir = project_type + "s"

    if verbose:

        print("Project name: " + game_dir)

    parent_and_game_dir = parent_dir + "/" + game_dir

    if not os.path.exists(parent_and_game_dir):
        print("Project not found!")
        return

    if verbose:
        print("Delete all temporary files including generated assets for '"+game_dir+"'")

    make_command = GNU_MAKE + " clean_no_built_in -f " + \
                   parent_dir+"/"+game_dir+"/Makefile."+game_dir

    run_command(option_config,make_command)


# Clean project data
def clean(option_config, params):

    verbose = option_config.terminal_config.verbose

    if len(params)>=2:
        if params[1]=="tools":
            make_command = GNU_MAKE + " clean_tools -f makefiles.common/auxiliary/Makefile_tools"

            run_command(option_config, make_command)
            return
        if params[1]=="log" or params[1]=="logs":
            make_command = GNU_MAKE + " clean_logs -f makefiles.common/auxiliary/Makefile_tools"

            run_command(option_config, make_command)
            return

    if len(params)<2:
        make_command = GNU_MAKE + " clean_generic -f makefiles.common/auxiliary/Makefile_common"

        if verbose:
            print("Delete all built binaries and non-project-specific temporary files")

        run_command(option_config, make_command)
        return

    game_dir = params[1]

    project_type = project_category(game_dir)

    parent_dir = project_type + "s"

    print("Project name: " + game_dir)

    parent_and_game_dir = parent_dir + "/" + game_dir

    if not os.path.exists(parent_and_game_dir):
        print("Project not found!")
        return

    print("Delete all built binaries and temporary files (also specific to '"+ \
          game_dir+"', e.g., generated assets)")

    make_command = GNU_MAKE + " clean -f " + parent_dir+"/"+game_dir+"/Makefile."+game_dir

    run_command(option_config, make_command)


# Delete project
def delete(option_config, params):
    if(len(params)>=2) and params[1]=="tools":
        make_command = GNU_MAKE + " clean_tools"

        run_command(option_config, make_command)
        return

    if len(params)<2:
        game_dir="helloworld"
    else:
        candidate_name = params[1]
        if candidate_name in example_projects or candidate_name in game_projects or \
            candidate_name in COMMANDS_LIST:
            print("invalid name!")
            return
        game_dir = candidate_name

    if (len(params)>2) and (params[2]=="-y"):
        interactive = False
    else:
        interactive = True

    parent_dir = "projects"
    verbose = option_config.terminal_config.verbose
    if verbose:
        print("Project name: " + game_dir)

    parent_and_game_dir = parent_dir + "/" + game_dir
    if verbose:
        print("Remove the project '"+game_dir+ \
              "' with all its files (source, graphics assets, makefile)")
    if (not interactive) or (are_you_sure()=="y"):
        if os.path.exists(parent_and_game_dir):
            if verbose:
                print("Deleting directory " + parent_and_game_dir)
            shutil.rmtree(parent_and_game_dir)

        makefile_name = "Makefile."+game_dir
        if os.path.exists(makefile_name):
            if verbose:
                print("Deleting..." + makefile_name)
            os.remove(makefile_name)
        if verbose:
            print("'" + game_dir + "' deleted")
    else:
        return


def test_projects(option_config, projects, target="stdio"):

    compilation_threads = option_config.build_config.compilation_threads
    verbose = option_config.terminal_config.verbose
    clean_test(option_config)

    if projects in ["examples", "projects", "games"]:
        number_of_projects = len(dirs_in_path("./"+projects))
    elif projects == "all":
        number_of_projects = \
        len(dirs_in_path("./examples")) + \
        len(dirs_in_path("./games")) + \
        len(dirs_in_path("./projects"))
    else:
        number_of_projects = 1
    if verbose:
        print("number of projects: " + str(number_of_projects))
    #multiple_build
    build(option_config, ["build",projects,target,compilation_threads,""])
    built_files = built_files_in_path("../build")

    # TODO: Handle target=*_targets and all
    if target.endswith("_targets") or target=="all":
        if verbose:
            print("Test on the number of binaries for all these targets is not supported")

    if target in TARGETS_WITH_3_BINARIES:
        files_per_project = 3
    elif target in TARGETS_WITH_2_BINARIES:
        files_per_project = 2
    else:
        files_per_project = 1

    if verbose:
        print("Expected binaries per project: " + str(files_per_project))

    if len(built_files)<files_per_project*number_of_projects:
        printc(option_config, bcolors.FAIL, "[xl build]  KO\n")
        print("Built files: " +str(built_files))
        print("Expected number : " + str(number_of_projects))
        print("No. Built files : " + str(len(built_files)))

        # success=0
        return False
    printc(option_config, bcolors.OKGREEN, "[xl build]        OK\n")
    return True


def test_clean_tools(option_config):
    #clean tools
    clean(option_config, ["clean","tools"])

    tools_result_map=test_tools(option_config, silent=True)
    number_of_tools = len(tools_result_map.keys())

    built_tools = 0
    for _, result in tools_result_map.items():
        if result:
            built_tools+=1
    if built_tools==0:
        printc(option_config, bcolors.OKGREEN, "[xl clean tools]    OK\n")
    else:
        printc(option_config, bcolors.FAIL, "[xl clean tools]    KO\n")
    return number_of_tools, built_tools


def test_self(option_config, target = "stdio"):

    option_config.terminal_config.test = 1
    printc(option_config, bcolors.OKCYAN,"----------------------------------------\n")
    printc(option_config, bcolors.OKCYAN, "XL SCRIPT TEST")
    printc(option_config, bcolors.OKCYAN,"\n----------------------------------------\n")
    success = 1
    printc(option_config, bcolors.BOLD,  "target: ")
    printc(option_config, bcolors.OKBLUE,target+"\n")
    printc(option_config, bcolors.OKCYAN,"----------------------------------------\n")
    
    #delete
    delete(option_config, ["delete","_cloned_test_project","-y"])
    printc(option_config, bcolors.OKGREEN, "[xl delete]         OK\n")


    #clean tools
    number_of_tools, built_tools = test_clean_tools(option_config)
    if built_tools>0:
        success = 0

    #tools
    tools(option_config)

    tools_result_map=test_tools(option_config, silent=True)
    built_tools = 0
    for _, result in tools_result_map.items():
        if result:
            built_tools+=1
    if built_tools==number_of_tools:
        printc(option_config, bcolors.OKGREEN, "[xl tools]          OK\n")
    else:
        printc(option_config, bcolors.FAIL, "[xl tools]         KO\n")
        print("built_tools: " + str(built_tools))
        print("number_of_tools: " + str(number_of_tools))
        success = 0

    #clean tools
    number_of_tools, built_tools = test_clean_tools(option_config)
    if built_tools > 0:
        success = 0

    #delete
    delete(option_config, ["delete","_test_project","-y"])
    printc(option_config, bcolors.OKGREEN, "[xl delete]         OK\n")


    #clean
    success = success * clean_test(option_config)

    projects_before_create = list_projects(option_config, ["list"],False)

    project_dirs_before_create = len(dirs_in_path("./projects"))
    initial_dirs = project_dirs_before_create

    # create
    create(option_config, ["create", "_test_project", "test"])
    project_dirs_after_create = len(dirs_in_path("./projects"))

    if project_dirs_after_create!=project_dirs_before_create+1:
        printc(option_config, bcolors.FAIL, "[xl create]         KO\n")
        return 0
    printc(option_config, bcolors.OKGREEN, "[xl create]         OK\n")

    # list
    projects_after_create = list_projects(option_config, ["list"],False)
    if projects_after_create!=projects_before_create+1:
        printc(option_config, bcolors.FAIL,"[xl list]           KO\n")
        success = 0
    printc(option_config, bcolors.OKGREEN,"[xl list]           OK\n")

    # create
    create(option_config, ["create", "_test_project2", "game"])
    printc(option_config, bcolors.OKGREEN, "[xl create]         OK\n")

    # create
    create(option_config, ["create", "_test_project3", "demo"])
    printc(option_config, bcolors.OKGREEN, "[xl create]         OK\n")

    # create
    create(option_config, ["create", "_test_project4", "text"])
    printc(option_config, bcolors.OKGREEN, "[xl create]         OK\n")

    # create
    create(option_config, ["create", "_test_project5", "helloworld"])
    printc(option_config, bcolors.OKGREEN, "[xl create]         OK\n")

    #build
    build(option_config, ["build", "_test_project2", target])
    built_files = built_files_in_path("../build")
    printc(option_config, bcolors.OKGREEN,"[xl build]          OK\n")

    #build
    build(option_config, ["build", "_test_project3", target])
    built_files = built_files_in_path("../build")
    printc(option_config, bcolors.OKGREEN,"[xl build]          OK\n")

    #build
    build(option_config, ["build", "_test_project4", target])
    built_files = built_files_in_path("../build")
    printc(option_config, bcolors.OKGREEN,"[xl build]          OK\n")

    #build
    build(option_config, ["build", "_test_project5", target])
    built_files = built_files_in_path("../build")
    printc(option_config, bcolors.OKGREEN,"[xl build]          OK\n")

    #clean
    success = success * clean_test(option_config)
    if success:
        printc(option_config, bcolors.OKGREEN,"[xl clean]          OK\n")

    #delete
    delete(option_config, ["delete","_test_project2","-y"])
    printc(option_config, bcolors.OKGREEN, "[xl delete]         OK\n")

    #delete
    delete(option_config, ["delete","_test_project3","-y"])
    printc(option_config, bcolors.OKGREEN, "[xl delete]         OK\n")

    #delete
    delete(option_config, ["delete","_test_project4","-y"])
    printc(option_config, bcolors.OKGREEN, "[xl delete]         OK\n")

    #delete
    delete(option_config, ["delete","_test_project5","-y"])
    printc(option_config, bcolors.OKGREEN, "[xl delete]         OK\n")

    #delete
    delete(option_config, ["delete","_foo_test","-y"])

    #rename
    rename(option_config, ["","_test_project", "_foo_test"])
    printc(option_config, bcolors.OKGREEN,"[xl rename]         OK\n")

    #rename
    rename(option_config, ["","_foo_test", "_test_project"])
    printc(option_config, bcolors.OKGREEN,"[xl rename]         OK\n")

    #build
    build(option_config, ["build", "_test_project", target])
    built_files = built_files_in_path("../build")

    if len(built_files)==0:
        print("built binaries: " + str(built_files))

        printc(option_config, bcolors.FAIL, "[xl build]          KO\n")
        success=0
    else:
        printc(option_config, bcolors.OKGREEN, "[xl build]          OK\n")

    dirs_in_proj_before = len(dirs_in_path("./projects/_test_project"))
    if dirs_in_proj_before != 4:
        printc(option_config, bcolors.FAIL, "[xl build]          KO\n")
        success=0

    dirs_in_shapes_before = len(dirs_in_path("./projects/_test_project/shapes"))
    if dirs_in_shapes_before != 1:
        printc(option_config, bcolors.FAIL, "[xl build]          KO\n")
        print(dirs_in_shapes_before)
        print(str(dirs_in_path("./projects/_test_project/shapes")))
        success=0

    extend(option_config, ["extend", "_test_project"])

    dirs_in_proj_after = len(dirs_in_path("./projects/_test_project"))

    if dirs_in_proj_after != 4:
        printc(option_config, bcolors.FAIL, "[xl extend]         KO\n")
        success=0

    dirs_in_shapes_after = len(dirs_in_path("./projects/_test_project/shapes"))

    if dirs_in_shapes_after != 5:
        printc(option_config, bcolors.FAIL, "[xl extend]         KO\n")
        print("no. dirs_in_shapes_after: " + str(dirs_in_shapes_after))
        print("dirs_in_shapes_after: " + str(dirs_in_path("./projects/_test_project/shapes")))
        success=0

    if success:
        printc(option_config, bcolors.OKGREEN, "[xl extend]         OK\n")

    fast_test = option_config.terminal_config.fast_test
    interactive_test = option_config.terminal_config.interactive_test
    if interactive_test:
        # run
        printc(option_config, bcolors.OKCYAN , "\nExit the test program to continue\n")
        run(option_config, ["run", "_test_project", target])

        printc(option_config, bcolors.OKGREEN, "[xl run]            OK\n")

    projects_before_create = list_projects(option_config, ["list"],False)

    project_dirs_before_create = len(dirs_in_path("./projects"))

    # clone
    clone(option_config, ["","_test_project","_cloned_test_project"])
    project_dirs_after_create = len(dirs_in_path("./projects"))

    if project_dirs_after_create!=project_dirs_before_create+1:
        printc(option_config, bcolors.FAIL,
                            "[xl clone]          KO\n")
        return 0
    printc(option_config, bcolors.OKGREEN,
                            "[xl clone]          OK\n")

    #build
    build(option_config, ["build", "_cloned_test_project", target])
    
    if interactive_test:

        # run
        printc(option_config, bcolors.OKCYAN , "\nExit the test program to continue\n")

        run(option_config, ["run", "_cloned_test_project", target])

        printc(option_config, bcolors.OKGREEN, "[xl run]            OK\n")

    # delete
    delete(option_config, ["","_cloned_test_project","-y"])
    printc(option_config, bcolors.OKGREEN, "[xl delete]         OK\n")


    #clean
    success = success * clean_test(option_config)

    #shapes
    tiles(option_config, ["","_test_cloned_test_project_project"])
    # make_assets_from_tiles(["_test_cloned_test_project_project"])
    printc(option_config, bcolors.OKGREEN, "[xl tiles]          OK\n")

    #size
    size(option_config, ["size", "_test_project", "stdio_sized", "12", "12"],True)
    built_files = built_files_in_path("../build")

    if len(built_files)!=1:
        printc(option_config, bcolors.FAIL, "[xl size]           KO\n")
        print(str(built_files))
        success=0
    else:
        printc(option_config, bcolors.OKGREEN, "[xl size]           OK\n")

    dirs_in_proj_before = len(dirs_in_path("./projects/_test_project"))
    if dirs_in_proj_before != 4:
        printc(option_config, bcolors.FAIL, "[xl size]           KO\n")
        print(str(dirs_in_path("./projects/_test_project")))
        success=0

    dirs_in_shapes_before = len(dirs_in_path("./projects/_test_project/shapes"))
    if dirs_in_shapes_before != 5:
        printc(option_config, bcolors.FAIL, "[xl size]           KO\n")
        print(str(dirs_in_path("./projects/_test_project/shapes")))
        success=0

    #reset
    reset(option_config, [""])
    printc(option_config, bcolors.OKGREEN, "[xl reset]          OK\n")

    #size
    size(option_config, ["size", "_test_project", "stdio_sized", "32", "24"],False)
    built_files = built_files_in_path("../build")

    if len(built_files)!=2:
        printc(option_config, bcolors.FAIL, "[xl size]           KO\n")
        print(str(built_files))
        print("Wrong number of built files")
        success=0
    else:
        printc(option_config, bcolors.OKGREEN, "[xl size]           OK\n")

    projects = []
    for (_, dirnames, _) in walk("./projects"):
        projects.extend(dirnames)
        break

    games = []
    for (_, dirnames, _) in walk("./games"):
        games.extend(dirnames)
        break

    examples = []
    for (_, dirnames, _) in walk("./examples"):
        examples.extend(dirnames)
        break

    #reset
    reset(option_config, ["","_test_project"])
    printc(option_config, bcolors.OKGREEN, "[xl reset]          OK\n")

    #delete
    delete(option_config, ["delete","_test_project","-y"])
    project_dirs_after_delete = len(dirs_in_path("./projects"))

    if project_dirs_after_delete != initial_dirs:
        printc(option_config, bcolors.FAIL,    "[xl delete]         KO\n")
        print(project_dirs_before_create)
        print(project_dirs_after_delete)
        success=0
    else:
        printc(option_config, bcolors.OKGREEN, "[xl delete]         OK\n")

    if clean_test(option_config)==0:
        success=0

    if not fast_test:

        if target in TARGETS_WITH_2_BINARIES:
            binary_factor = 2
        elif target in TARGETS_WITH_3_BINARIES:
            binary_factor = 3
        else:
            binary_factor = 1

        # build (all examples)
        build(option_config, ["","examples", target])

        built_files = built_files_in_path("../build")

        if len(built_files)!=binary_factor*len(examples):
            success=0
            printc(option_config, bcolors.FAIL, "[xl build examples] KO\n")
            print(built_files)
            print(examples)
        else:
            printc(option_config, bcolors.OKGREEN, "[xl build examples] OK\n")

        if clean_test(option_config)==0:
            success=0

        # build (all games)
        build(option_config, ["","games", target])

        built_files = built_files_in_path("../build")

        if len(built_files)!=binary_factor*len(games):
            success=0
            printc(option_config, bcolors.FAIL, "[xl build games]    KO\n")
            print(built_files)
            print(games)
            sys.exit()
        else:
            printc(option_config, bcolors.OKGREEN, "[xl build games]    OK\n")

        if clean_test(option_config)==0:
            success=0

    printc(option_config, bcolors.OKCYAN,"----------------------------------------\n")

    return success


def test_all(option_config, params):

    test_compilers(option_config)
    test_tools(option_config)
    test_libraries(option_config)
    test_interpreters(option_config)
    unit_tests(option_config)
    return test_self(option_config, params)

expected_files = {
    "cc65": 8,
    "z88dk": 5,
    "cmoc": 3,
    "lcc1802": 1,
    "z88dk_alt": 38,
    "stdio_alt": 1
    }


def targets_test(option_config, params):

    verbose = option_config.terminal_config.verbose
    success = clean_test(option_config)
    compilation_threads = option_config.build_config.compilation_threads
    native_compiler = option_config.build_config.native_compiler
    if params[1].startswith("z88dk") or params[1]=="cc65":
        parallel = " -j " + compilation_threads
    else:
        parallel = ""

    game_dir = "chase"
    project_type = "game"
    if is_project_split(game_dir):
        if verbose:
            printc(option_config, bcolors.OKBLUE,"Create main.c from split source files\n")
        create_main(game_dir, project_type)
    if params[1] in ("cc65", "z88dk", "cmoc", "lcc1802"):
        make_command = GNU_MAKE + parallel + " test_" + params[1] + "_extra " + \
                       " GNU_MAKE=" + GNU_MAKE + " _NATIVE_CC="+ native_compiler + " " + \
                       all_compilers_opts(option_config, "","") + \
                       " -f makefiles.other/chase/tests/Makefile.tests"
        run_command(option_config, make_command)
    elif params[1]=="z88dk_alt":
        make_command = GNU_MAKE + parallel + " GNU_MAKE=" + GNU_MAKE + \
                       " z88dk_quick_test -f makefiles.other/chase/tests/Makefile.z88dk_quick_tests"
        run_command(option_config, make_command)
    else:
        printc(option_config, bcolors.FAIL, "Parameter not recognized\n")
        if is_project_split(game_dir):
            if verbose:
                printc(option_config, bcolors.OKBLUE,"Delete main.c (because of split source files)\n")
            delete_main(option_config, game_dir, project_type)
        sys.exit(-1)
    if is_project_split("chase"):
        if verbose:
            printc(option_config, bcolors.OKBLUE,"Delete main.c (because of split source files)\n")
        delete_main(option_config, game_dir, project_type)


    built_files = len(files_in_path("../build"))-1
    if verbose:
        print("Number of built files: " + str(built_files))

    if params[1] in expected_files.keys():
        printc(option_config, bcolors.OKCYAN, "Built files: " + str(built_files)+"\n")
        printc(option_config, bcolors.OKBLUE, "Expected files: " + str(expected_files[params[1]])+"\n")
        if built_files != expected_files[params[1]]:
            printc(option_config, bcolors.FAIL, "binaries KO\n")
            success=0

        else:
            printc(option_config, bcolors.OKGREEN, "binaries OK\n")

    # if clean_test()==0:
        # success=0
    return success


# Self-test xl and native build
def test(option_config, params):
    if (len(params)<=1) or ((len(params)==2) and (params[1]=="check")):
        if test_all(option_config, "stdio"):
            printc(option_config, bcolors.OKGREEN, "TEST OK\n")
        else:
            printc(option_config, bcolors.FAIL, "TEST KO\n")
        return
    if params[1]=="self":
        if len(params)<3:
            test_self(option_config)
        else:
            test_self(option_config, params[2])
    elif params[1]=="compilers":
        test_compilers(option_config)
    elif params[1]=="tools":
        test_tools(option_config)
    elif params[1]=="emulators":
        test_emulators(option_config)
    elif params[1]=="cross-compilers" or params[1]=="cross_compilers":
        test_cross_compilers(option_config)
    elif params[1]=="native_compilers" or params[1]=="native-compilers":
        test_native_compilers(option_config)
    elif params[1]=="libraries":
        test_libraries(option_config)
    elif params[1]=="interpreters":
        test_interpreters(option_config)
    elif params[1]=="roms":
        test_roms(option_config)
    elif params[1]=="make":
        test_make(option_config, silent=False)
    elif params[1] in ("unit-tests", "unit_tests", "unit-test", "unit_test", "u"):
        unit_tests(option_config)
    elif params[1] in ("cc65", "z88dk", "cmoc", "lcc1802") or params[1].endswith('_alt'):
        if targets_test(option_config, params):
            printc(option_config, bcolors.OKGREEN, "TEST OK\n")
        else:
            printc(option_config, bcolors.FAIL, "TEST KO\n")
        return
    else:
        projects = []
        for (_, dirnames, _) in walk("./projects"):
            projects.extend(dirnames)
            break

        games = []
        for (_, dirnames, _) in walk("./games"):
            games.extend(dirnames)
            break

        examples = []
        for (_, dirnames, _) in walk("./examples"):
            examples.extend(dirnames)
            break

        if params[1] in projects + games + examples or params[1] in \
           ['examples','games','projects','all']:
            if len(params)>=3:
                par1 = params[1]
                par2 = params[2]
            else:
                par1 = params[1]
                par2 = "stdio"
            if test_projects(option_config, par1,par2):
                printc(option_config, bcolors.OKGREEN, "TEST OK\n")
            else:
                printc(option_config, bcolors.FAIL, "TEST KO\n")
        else:
            test_all(option_config, params[1])
        return


# Self-test xl and native build
def check(option_config, params, silent=False):
    if len(params)<=1:
        tools = test_tools(option_config, silent)
        native_compilers =test_native_compilers(option_config)
        cross_compilers = test_cross_compilers(option_config)
        libraries = test_libraries(option_config)
        make = test_make(option_config, silent=True)
        emulators = test_emulators(option_config)
        roms = test_roms(option_config)

        print("")

        printc(option_config, bcolors.BOLD, "SUMMARY\n")
        tools = True
        xl_run_cross_target = True
        native_target = True
        cross_target = True

        if not make['make'] and not make['gmake']:
            printc(option_config, bcolors.FAIL, "No make command detected!\n")

        if not native_compilers['gcc']:
            tools = False
            native_target = False

        if not native_compilers['g++']:
            xl_run_cross_target = True
            tools = False

        if not libraries['ncurses']:
            printc(option_config, bcolors.WARNING, \
                   "No ncurses library detected -> Native target impacted\n")
            native_target = False

        for _, present in cross_compilers.items():
            if not present:
                cross_target = False

        for _, present in emulators.items():
            if not present:
                xl_run_cross_target = False
                break

        for _, present in roms.items():
            if not present:
                xl_run_cross_target = False
                break

        if not tools:
            printc(option_config, bcolors.WARNING, "'xl tools' may be KO for some targets\n")

        if not native_target:
            printc(option_config, bcolors.WARNING, "'xl build <project>' may be KO (no native build)\n")

        if not cross_target:
            printc(option_config, bcolors.WARNING, "'xl build <project> <target>' may be KO for some targets\n")

        if not xl_run_cross_target:
            printc(option_config, bcolors.WARNING, "'xl run <project> <target>' may be KO for some targets\n")

        if tools and native_target and xl_run_cross_target and cross_target:
            printc(option_config, bcolors.OKCYAN, "No issue found\n")

    elif params[1]=="compilers":
        test_compilers(option_config)
    elif params[1]=="tools":
        test_tools(option_config)
    elif params[1]=="emulators":
        test_emulators(option_config)
    elif params[1]=="cross-compilers" or params[1]=="cross_compilers":
        test_cross_compilers(option_config)
    elif params[1]=="native_compilers" or params[1]=="native-compilers":
        test_native_compilers(option_config)
    elif params[1]=="libraries":
        test_libraries(option_config)
    elif params[1]=="interpreters":
        test_interpreters(option_config)
    elif params[1]=="make":
        test_make(option_config, silent=False)
    elif params[1]=="roms":
        test_roms(option_config)



# It should be able to import from
# - Assembly files that use byte directives with either decimal and hex notation
# - Assembly files that use word directives with ONLY hex notation
def import_from_source(params, rotate = False):
    filename = params[1]

    rip_option = params[len(params)-1]=="-rip"

    xsize = 8
    ysize = 8

    tiles = rip_tiles(filename, xsize, ysize, rip_option, rotate)

    try:
        if(len(params)>=3) and "-" not in params[2]:
            store_tiles(params[2],tiles, xsize, ysize)
    except Exception as exception:
        print("Sorry! Failed to store tiles: \n" + str(exception.args))


# It should be able to import from
# - Assembly files that use byte directives with either decimal and hex notation
# - Assembly files that use word directives with ONLY hex notation
# - BASIC files that use decimal, hex notation or "headless" hex notation (by guessing)
# Remark: This function is like "import_from_source" with the "-rip" option
def rip(params, rotate = False):
    filename = params[1]

    xsize = 8
    ysize = 8

    tiles = rip_tiles(filename, xsize, ysize, True, rotate)

    try:
        if(len(params)>=3) and "-" not in params[2]:
            store_tiles(params[2],tiles, xsize, ysize)
    except Exception as exception:
        print("Sorry! Failed to store tiles: \n" + str(exception.args))


def split(params):
    import_split_tiles(params[1])


# Import a shape as single tile from a text file that describes its shape with characters
def tile(params):

    tile,xsize,ysize = import_tile(params[1])

    if verbose:
        print_shape(option_config, compute_shape(tile,xsize))

    if len(params)>=3:
        store_tile(params[2], tile, xsize, ysize, params[3])
    else:
        printc(option_config, bcolors.OKCYAN, tile+"\n")


# Import as tiles all shapes from files named "shape<number>.txt" inside the directories in the "shapes" directory of a given project
def tiles(option_config, params):
    verbose = option_config.terminal_config.verbose
    project_name = params[1]

    project_cat = project_category(project_name)

    if len(params)>3:   # xsize, ysize parameters
        xsize_str,ysize_str = params[2:]
    elif len(params)==3: # target parameter
        detected_xsize = detect_xsize(params[2])
        detected_ysize = detect_ysize(params[2])
        xsize_str = str(detected_xsize)
        ysize_str = str(detected_ysize)
    else:                # no parameter
        xsize_str = "8"
        ysize_str = "8"
    if verbose:
        print("xsize: " + xsize_str)
        print("ysize: " + ysize_str)
    path_to_files = project_cat + "s/" + params[1] + \
                    "/shapes/" + xsize_str + "x" + ysize_str + "/"
    if verbose:
        print("Path to shape files: " + path_to_files)
    shape_files = files_in_path(path_to_files)
    if verbose:
        print("shape files: ", shape_files)
    for shape_file in shape_files:
        if verbose:
            print("processing file: ", shape_file)

        path_to_shape_file = path_to_files + str(shape_file)
        if verbose:
            print("processing path file: ", path_to_shape_file)
        tile_number_str = shape_file[5:].replace(".txt","")

        print("tile number: " + tile_number_str)

        tile,xsize,ysize = import_tile(path_to_shape_file)

        if str(xsize)!=xsize_str or str(ysize)!=ysize_str:
            print("Shape in file " + path_to_shape_file + " has wrong dimensions!")
            print(tile)
            return
        print(tile)
        if verbose:
            print_shape(option_config, compute_shape(tile,xsize))

        store_tile(project_name, tile, xsize, ysize, tile_number_str)

        print("")


# Show tile shapes of a given project
def show(option_config, params):
    parent_dir = project_category(params[1])+"s"

    if len(params)<4:
        xsize = "8"
        ysize = "8"
    else:
        xsize = params[2]
        ysize = params[3]

    if len(params)>=5:
        index = params[4]
    else:
        index = ""

    if index!="":
        print_shape_from_file(option_config, parent_dir, params[1], xsize, ysize, index)

    else:
        for i in range(NUMBER_OF_TILES):
            print_shape_from_file(option_config, parent_dir, params[1], xsize, ysize, i)


def make_assets_from_tiles(option_config, params):

    game_dir = params[1]

    project_type = project_category(game_dir)
    parent_dir = project_type + "s"

    run_command(option_config, GNU_MAKE+" GAME_NAME=" + game_dir + \
                          " PARENT_DIR=" + parent_dir + \
                          " -f ./makefiles.common/auxiliary/Makefile_assets")


# ---------------------------------------------


if __name__ == "__main__":


    if python_version<2 or (python_version<=2 and python_subversion<7):
        print("Python version not supported")
        logger.error("Python version not supported")
        sys.exit(-1)
    try:
        # print("Reading config")
        # logger.info("(read_config) Read configuration file")
        option_config = read_config()
        # option_config = default_config()

        logger.info("(read_config) Configuration file read")
    except:
        print("Failed to read config.ini")
        logger.warning("Reverting to default configuration")
        option_config = default_config()
        print("WARNING: Using default config")

    make_test = test_make(option_config, silent=True)

    if make_test['gmake']:
        GNU_MAKE = "gmake"
    else:
        GNU_MAKE = "make"

    # parallelize_multi_build = option_config.build_config.parallelize_multi_build
    if option_config.build_config.parallelize_multi_build:
        # print("Parallelize_multi_build is ON")
        logger.info("Parallelize_multi_build is ON")
        from multiprocessing import Pool
    else:
        logger.info("Parallelize_multi_build is OFF")

    # verbose = option_config.terminal_config.verbose
    
    # print(verbose)
    
    
    # color_terminal = option_config.terminal_config.color_terminal
    if option_config.terminal_config.verbose:
        logger.info("Verbose mode ON")
        print("----------------------------")
        # printc(option_config, bcolors.OKGREEN, "Cross-Lib `xl` helper script\n")
        print("----------------------------")
        print("Platform: " + platform)
        print("Python:   " + str(python_version) + "." + str(python_subversion))
        logger.info("Using Python version %s.%s", str(python_version), str(python_subversion))

        print("GNU MAKE command: " + GNU_MAKE)
        print("----------------------------")
        print("")


    if len(sys.argv)<2:
        logger.info("Interactive mode ON")
        print("For more commands, use the non-interactive mode.")
        printc(option_config, bcolors.BOLD, "xl help")
        print(" for instructions.")

        print("")
        print("--------------------------------------------------")
        printc(option_config, bcolors.OKCYAN, "Interactive mode\n")
        print("--------------------------------------------------")
        print("")

        project_name = generic_input("Insert project to build\n")

        if project_name in ("", "\n"):
            project_name="helloworld"
            printc(option_config, bcolors.WARNING,"Defaulting to helloworld\n")

        print("")

        target_name = generic_input("Insert target name\n")
        if target_name in ("", "\n"):
            target_name="ncurses"
            printc(option_config, bcolors.WARNING, "Defaulting to ncurses\n")

        print("")
        time.sleep(1)

        params = ["rebuild", project_name, target_name]
    else:
        logger.info("Interactive mode OFF")
        params = sys.argv
        params = handle_two_letter_params(params)

        params = full_params(params)

    command_name = "build" if params[1] in list_of_projects("all") + \
                   ["examples"] + ["games"] + ["projects"] + ["all"] else params[1]
                   
    logger.info("Command : %s", command_name)
    if params[1]=="run":
        run(option_config, params[1:])
    elif params[1]=="check":
        check(option_config, params[1:])
    elif params[1]=="compilers":
        test(option_config, ["test","compilers"])
    elif params[1]=="unit-tests":
        test(option_config, ["test","unit-tests"])
    elif params[1]=="self":
        if len(params)<3:
            test_self(option_config, )
        else:
            test_self(option_config, params[2])
    elif params[1]=="assets":
        tiles(option_config, params[1:])
        make_assets_from_tiles(option_config, params[1:])
    elif params[1]=="split":
        split(params[1:])
    elif params[1]=="config":
        display_config(option_config)
    elif params[1]=="string":
        string(option_config, params[1:])
    elif params[1]=="commands":
        commands(option_config)
    elif params[1]=="import":
        import_from_source(option_config, params[1:],False)
    elif params[1]=="rotate":
        rip(option_config, params[1:],True)
    elif params[1]=="rip":
        rip(option_config, params[1:],False)
    elif params[1]=="rebuild":
        rebuild(option_config, params[1:])
    elif params[1]=="make":
        tiles(option_config, params[1:])
        rebuild(option_config, params[1:])
    elif params[1]=="rename":
        rename(option_config, params[1:])
    elif params[1]=="clone":
        clone(option_config, params[1:])
    elif params[1]=="show":
        show(option_config, params[1:])
    elif params[1]=="test":
        test(option_config, params[1:])
    elif params[1]=="tile":
        tile(option_config, params[1:])
    elif params[1]=="tiles":
        tiles(option_config, params[1:])
    elif params[1]=="extend":
        extend(option_config, params[1:])
    elif params[1]=="build":
        build(option_config, params[1:])
    elif params[1]=="manual":
        manual(option_config, params[1:])
    elif params[1]=="files":
        files()
    elif params[1]=="size":
        size(option_config, params[1:],0)
    elif params[1]=="debug":
        size(option_config, params[1:],1)
    elif params[1]=="create":
        create(option_config, params[1:])
    elif params[1]=="clean":
        clean(option_config, params[1:])
    elif params[1]=="reset":
        reset(option_config, params[1:])
    elif params[1]=="delete":
        delete(option_config, params[1:])
    elif params[1]=="list":
        list_projects(option_config, params[1:])
    elif params[1]=="help":
        help_command(option_config, params[1:])
    elif params[1]=="tools":
        tools(option_config, )
    elif params[1]=="slow":
        slow(option_config, params[1:])
    elif params[1] in list_of_projects("all") + \
                      ["examples"] + ["games"] + ["projects"] + ["all"]:
        build(option_config, params)
    else:
        manual(option_config, params)

    logger.info('Finished')

    os.system('mv ../logs/log.log ../logs/log_' + \
              datetime.datetime.now().strftime("%Y-%m-%d_%H_%M_%S")+'.log 2>/dev/null' )
