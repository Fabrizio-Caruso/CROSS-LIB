
# INTRODUCTION
Cross-Lib (https://github.com/Fabrizio-Caruso/CROSS-LIB/) is a free open source tool for retro-coding for more than 200 8-bit systems from the ‘80s (computers, consoles, calculators, arcade boards, etc.) 
such as Commodore 64, Commodore VIC 20, other Commodore computers, Thomson Mo5 and To7, Apple ][, Atari 800, Amstrad CPC, Sinclair ZX 81, Sinclair ZX Spectrum, 
MSX, Oric-1, Oric Atmos, BBC Micro, TRS-80 CoCo, Dragon 32, etc. as well as consoles such as GameBoy, Sega Master System, GameGear, Nintendo NES, etc. 
and other devices such as Texas Instruments calculators such as the TI 83, etc. with main CPU architectures such as  Zilog 80, MOS 6502, Intel 8080, Motorola 6803, Motorola 6809 and RCA 1802. 
Cross-Lib also supports several quite rare systems such as the Philips VG-5000, the Jupiter Ace, the Alice Matra, etc. 
A partial list of the supported systems is at the page: 
https://github.com/Fabrizio-Caruso/CROSS-LIB/blob/master/docs/STATUS.md. 
and some very rare and exotic systems such as for example several computers for Eastern Europe such as the yugoslav Galaksija, the Hungarian Homlab-2, 
several computers from the Eastern German Robotron series such as the Robotron KC 85, etc. 
I have chosen the name Cross-Lib as a contraction for “cross-compilable library”. Therefore Cross-Lib is (above all) a C software library that can be compiled by several cross-compilers for almost 
all 8-bit consoles and computers from the ‘80s. It allows writing universal games for more than 200 different vintage machines (mostly 8-bit but not limited to 8-bit).


Nowadays, there are several tool that allow to code for retro-systems very easily on a modern PC.
Historically, 8-bit systems were programmed directly on the system mostly in Assembly, or for simpler programs in interpreted BASIC.
Today cross-development simplifies a lot developers’ tasks (modern editors, simplified debugging, efficient and quick compilation, etc.). Programming for these machines is still often done in Assembly in order to maximally exploit the hardware resources of these machines at the cost of not having portable code.
Most retro-developers want to exploit the machine optimally.

The problem with the portability of C code comes from the diversity of the machines and from the fact that ANSI C does not provide a standard library for graphics, sounds, input, etc.
A partial solution is given by some dev-kits such as CC65, Z88DK, LCC1802 (for the RCA 1802 architecture), CMOC (for the Motorola 6890), etc. 
By using one of these dev-kits, we can exploit their cross-compatible libraries for input and output.
On the other hand we still have some problems:
1. Each dev-kit only covers a subset of the 8-bit architectures.
2. The libraries provided by the dev-kits do not always cover all graphics features, sound and input on its supported machines.

Cross-Lib allows you to do certain things that you cannot do with other tools:
1. cover many more vintage 8-bit architectures, including very exotic ones;
2. writing 100% WORA ("write once, run anywhere") code;
3. using WORA graphics resources, i.e., you can define graphics elements (“tiles”) once for (nearly) all systems;
4. using a simplified tool-chain to create, compile and test the games.


On the other hand Cross-Lib is not a compiler. It uses several compilers to build the binary files (executables, disk images, tape images, cartridge images, etc.) 
for retro-consoles and retro-computers.
Cross-Lib is also a set of tools (scripts) for the build process and automatic graphics asset adaptation to all systems.
By providing an abstraction layer for all 8-bit systems, Cross-Lib is making some compromises with respect to what one could do for a specific system if we wanted 
to code just for that system. In particular graphics is limited by what is possible on all systems. Also sound effects are very limited.
There are several dev-kits for multiple systems but very few support WORA development. 

Cross-Lib is the only WORA dev-kit that allows to code for nearly all 8-bit architectures and systems. On the other hand, 
Cross-Lib does not provide APIs for sprites nor any other high level APIs. The reason is that Cross-Lib covers all systems, 
including the ones that do not have hardware sprites or not even real graphics at all. 
The only way to implement sprites with Cross-Lib is to use pre-shifted tiles.



# COMPILERS

Cross-Lib is supposed to be used with C compilers but which ones? 

A native compiler (for example GCC) can be used to build native binaries that can be run, for instance, under Windows. Today the support for native compilation is limited to the text terminal, which means no graphics other than ASCII on the host machine.

Currently Cross-Lib fully supports the following cross-compilers and dev-kits with graphics and sound effects:
- CC65 [cc65] for most systems based on the MOS 6502 architecture; 
- Z88DK [z88dk] for systems based on the Zilog 80 and Intel 8080 architectures;
- CMOC [cmoc] for systems that use the Motorola 6809;
- LCC1802 [lcc1802] for systems that use the COSMAC RCA 1802 ;
- GCC for TI [ti] for the Texas Instruments TI99/4A based on the 16-bit TMS9900.

Cross-Lib also supports other compilers (currently without graphics and sound effects) such as 
ACK [ack] for 8088/8086, 
Intel 8080 CP/M, 386/68K/PPC/MIPS Linux and PDP11, 
XTC68 [xtc69] for the Sinclair QL, 
VBCC [vbcc] for the BBC Micro, BBC Master, the Amiga and others, 
CC6303 [cc6303] for the Motorola 6803; 
several versions of modded GCC to target vintage computers (Atari ST [st], Olivetti M20 [m20]).

Cross-Lib only supports a large sub-set of ANSI C89 because most available cross-compilers for 8-bit architectures only implement a sub-set of C89.
Therefore we write in C (a sub-set of ANSI C C89) with Cross-Lib APIs for graphics, sounds, input and other functions that allow us to write universal code for cases where there is no uniquely defined standard C equivalent.

In particular we must avoid:
- "float" and "double", 
- copies and parameters by value of "struct" objects,
- any use of the heap.


# INSTALLATION

Cross-Lib does not require any real installation. It is enough to download the repository files (from the GitHub page(  or to clone the repository with:
git clone https://www.github.com/Fabrizio-Caruso/CROSS-LIB/

On the other hand it requires:
- a POSIX environment (e.g., Windows with Cygwin, Linux or FreeBSD);
- Makefile (GNU Make);
- Python 2.7 or Python 3.*;
- [optional but required for the Apple //] JAVA;
- [optional] GCC compiler with ncurses libraries;
- [optional] any compiler necessary to build for a desired target architecture (e.g., CC65, Z88DK, etc.).

Once you have Cross-Lib with its dependencies in a POSIX environment, you should move to the "src" directory.
Inside "src" you will find the following directories 
- "cross-lib", which contains the library code;
- "games" with built-in games;
- "examples" with built-in examples;
- "projects" with user-defined projetcs.


If you have correctly installed Makefile, Python and (native) GCC in a any POSIX environment and nothing else, 
it is already possible to minimally use Cross-Lib to build the XChase game with:
"xl chase gcc", which will build Chase in turn-based mode for the native console.


# HOW TO USE THE XL SCRIPT

If one of the supported compilers, it can be used with the "xl" Python script inside the "src" directory.
If GCC with ncurses is installed, a native version of the games and examples can be built with:
"xl build <project name>" or just "xl <project name>"
For example 
"xl snake" 
builds the "snake" game for the native console.

If a cross compiler (CC65, Z88DK, CMOC, CC6303, LCC1802, etc) is installed, the games and examples can be built for the corresponding systems.
For example, if CC65 is installed, 
"xl horde apple2" 
builds the "horde" game for the Apple ][.

The "xl" script takes many commands. In particular you can see a list of the available commands with "xl commands".
You can get an explanation of each command with examples with 
"xl help <command name>".

If we want to create a new project, we need to use 
"xl create <project name>", 
which will create a project with a trivial "hello world" example inside the "projects" directory.
We can start with a template code for a game if we pass an additional parameter: "xl create <project name> game".

 
# HOW TO CODE WITH THE EXAMPLES

Coding with Cross-Lib is like normal coding with ANSI C89 with the only difference that all input/output is done through Cross-Lib APIs.

Cross-Lib comes with many examples in the src/examples/ directory as well as a few games in src/games.
Both of which can be used to learn how to code with Cross-Lib.

We could start to look at src/examples/helloworld/, whose main.c files contains: 

#include "cross_lib.h"

int main(void)
{        
    _XL_INIT_GRAPHICS();

    _XL_CLEAR_SCREEN();

    _XL_SET_TEXT_COLOR(_XL_WHITE);

    _XL_PRINT_CENTERED("HELLO WORLD");

    while(1){};
    
    return EXIT_SUCCESS;
}

We remark that all Cross-Lib specific functions start with the _XL_ prefix: 
1. _XL_INIT_GRAPHICS() required to initialize the display ;
2. _XL_CLEAR_SCREEN()  which cleans the content of the screen ;
3. _XL_SET_TEXT_COLOR(_XL_WHITE) which defines the color to be used by the text and characters ;
4. _XL_PRINT_CENTERED("HELLO WORLD") which displays "HELLO WORLD" on the center of the screen.

If we want to use one of the examples or even games as a starting point we can clone the project with:
xl clone <existing project to clone> <new project name>

Or we can start from (almost) scratch with
xl create <new project name>

Once we have a new project, we can build it with
xl <project> <target>

or

xl <project>
if we want to build the project for the native terminal.

We can run the project for the native terminal with:
xl run <project>

For example we could do the following operations:
xl clone helloworld myhelloworld [to clone helloworld and create myhellworld]
We modify the project myhelloworld (found inside ./src/projects/myhelloworld/)
xl build myhelloworld (or equivalently xl myhelloworld) [to build a native binary of the new project]
xl run myhelloworld [to run the new project]


# CODING WITH ABSTRACTIONS

In order to code with Cross-Lib for all targets at the same time, Cross-Lib uses several abstractions.

Sound is currently only limited to few sound effects that are rendered somehow similarly across multiple targets.

Input is only limited to 4 directions and a single fire button. On each target this will be mapped to either 5 keys (usually I J K L SPACE)
or the main joystick/controller/gamepad.

Graphics is only tile-based and it is performed by either displaying "tiles", whose shape can be freely defined or 
by "characters" (letters, digits and the space character).
Each concrete target will interpret tiles in two different ways depending on whether the target can or cannot assign free shapes to tiles.
ASCII-only targets will be able to assign ASCII shapes to characters, whereas targets with real graphics will assign a "freely defined" shape to the tile.



# GRAPHICS

As graphics is only tile-based. The actual drawings boil down to the shapes of each tile. The definition of these shapes is not done in the C code.
Instead it is done inside the <project>/tiles directory, which contains sub-directories with files with tile definitions for the ASCII case and for the different tile shapes, 
e.g., 8x8 (for most targets), 7x8 (for Apple //), 6x8 (for Oric and NTSC COMX-35), etc... 

In the aforementioned files the shapes are described by either ASCII codes for ASCII-only targets or sequences of bytes for graphics-enabled targets.

These files can be:
1. either edited manually or 
2. automatically imported from several programs such as CharPad (with "xl import <file> <project>") or 
3. automatically ripped from BASIC or Assembly listings (with "xl rip <file> <project>") or
4. generated by some simple "pictorial" text files with drawings made of "#" and "." characters 
(with "xl shapes <project> <x_size> <y_size> or "xl tile <file> <project> <tile number>".

You can see how to use these commands by running "xl help <command name>".




