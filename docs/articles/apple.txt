# INTRODUCTION

The goal of this article is three-fold:
1. I present the Cross-Lib framework, its goals, its architecture.
2. I give a short description of how it is used.
3. I present the 6 "universal" games I have written with it.

By "universal" here I mean that these games will run on about 200 different systems (consoles, computers, arcade boards, pocket calculators, etc.) despite using the very same game code.

A detailed description of Cross-Lib is not in the scope of this article.
For more details we refer to the GitHub page: http://www.github.com/Fabrizio-Caruso/CROSS-LIB/

# WHAT IS CROSS-LIB?
Cross-Lib (https://github.com/Fabrizio-Caruso/CROSS-LIB/) is a free open source tool for retro-coding for more than 200 8-bit systems from the ‘80s (computers, consoles, calculators, arcade boards, etc.) 
such as Commodore 64, Commodore VIC 20, other Commodore computers, Thomson Mo5 and To7, Apple ][, Atari 800, Amstrad CPC, Sinclair ZX 81, Sinclair ZX Spectrum, 
MSX, Oric-1, Oric Atmos, BBC Micro, TRS-80 CoCo, Dragon 32, etc. as well as consoles such as GameBoy, Sega Master System, GameGear, Nintendo NES, etc. 
and other devices such as Texas Instruments calculators such as the TI 83, etc. with main CPU architectures such as  Zilog 80, MOS 6502, Intel 8080, Motorola 6803, Motorola 6809 and RCA 1802. 
Cross-Lib also supports several quite rare systems such as the Philips VG-5000, the Jupiter Ace, the Alice Matra, etc. 
A partial list of the supported systems is at the page: 
https://github.com/Fabrizio-Caruso/CROSS-LIB/blob/master/docs/STATUS.md. 
and some very rare and exotic systems such as for example several computers for Eastern Europe such as the yugoslav Galaksija, the Hungarian Homlab-2, 
several computers from the Eastern German Robotron series such as the Robotron KC 85, etc. 

Cross-Lib is made of:
1. A "universal" C library (e.g., a collection of C APIs);
2. Scripts to manage game projects (e.g., build, create, etc.) and manipulate graphics assets (e.g., import, create, etc.)

Historically, 8-bit systems were programmed directly on the system mostly in Assembly, or for simpler programs in interpreted BASIC.
Today cross-development simplifies a lot developers’ tasks (modern editors, simplified debugging, efficient and quick compilation, etc.). 

The problem with the portability of C code comes from the diversity of the machines and from the fact that ANSI C does not provide a standard library for graphics, sounds, input, etc.
A partial solution is already given by some dev-kits such as CC65, Z88DK, LCC1802 (for the RCA 1802 architecture), CMOC (for the Motorola 6890), etc. 
By using one of these dev-kits, we can exploit their cross-compatible libraries for input and output.
On the other hand we still have some problems:
1. Each dev-kit only covers a subset of the 8-bit architectures.
2. The libraries provided by the dev-kits do not always cover all graphics features, sound and input on its supported machines.

Cross-Lib allows you to do certain things that you cannot do with other tools:
1. cover many more vintage 8-bit architectures, including very exotic ones;
2. writing 100% WORA ("write once, run anywhere") code;
3. using WORA graphics resources, i.e., you can define graphics elements (“tiles”) once for several totally different systems;
4. using a simplified tool-chain to create, compile and test the games.

On the other hand Cross-Lib is not a compiler. It uses several compilers to build the binary files (executables, disk images, tape images, cartridge images, etc.) 
for retro-consoles and retro-computers.

By providing an abstraction layer for all 8-bit systems, Cross-Lib is making some compromises with respect to what one could do for a specific system if we wanted 
to code just for that system. In particular, graphics is limited by what is possible on all systems. Also sound effects are very limited.

Cross-Lib is the only WORA dev-kit that allows to code for nearly all 8-bit architectures and systems.


# COMPILERS

Cross-Lib is supposed to be used with C compilers but which ones? 

A native compiler (for example GCC) can be used to build native binaries that can be run, for instance, under Windows. Today the support for native compilation is limited to the text terminal, which means no graphics other than ASCII on the host machine.

Currently Cross-Lib fully supports the following cross-compilers and dev-kits with graphics and sound effects:
- CC65 [cc65] for most systems based on the MOS 6502 architecture; 
- Z88DK [z88dk] for systems based on the Zilog 80 and Intel 8080 architectures;
- CMOC [cmoc] for systems that use the Motorola 6809;
- LCC1802 [lcc1802] for systems that use the COSMAC RCA 1802 ;
- GCC for TI [ti] for the Texas Instruments TI99/4A based on the 16-bit TMS9900.

Cross-Lib also supports other compilers (currently without graphics and sound effects) such as 
ACK [ack] for 8088/8086, 
Intel 8080 CP/M, 386/68K/PPC/MIPS Linux and PDP11, 
XTC68 [xtc69] for the Sinclair QL, 
VBCC [vbcc] for the BBC Micro, BBC Master, the Amiga and others, 
CC6303 [cc6303] for the Motorola 6803; 
several versions of modded GCC to target vintage computers (Atari ST [st], Olivetti M20 [m20]).

Cross-Lib only supports a large sub-set of ANSI C89 because most available cross-compilers for 8-bit architectures only implement a sub-set of C89.
Therefore we write in C (a sub-set of ANSI C C89) with Cross-Lib APIs for graphics, sounds, input and other functions that allow us to write universal code for cases where there is no uniquely defined standard C equivalent.

In particular we must avoid:
- "float" and "double", 
- copies and parameters by value of "struct" objects,
- any use of the heap.


# INSTALLATION

Cross-Lib does not require any real installation. 
It is enough to download the repository files (from the GitHub page)  or to clone the repository with:
git clone https://www.github.com/Fabrizio-Caruso/CROSS-LIB/

On the other hand it requires:
- a POSIX environment (e.g., Windows with Cygwin, Linux or FreeBSD);
- Make (GNU Make);
- Python 2.7 or Python 3.*;
- [optional but required for the Apple //] JAVA;
- [optional] GCC compiler with ncurses libraries;
- [optional] any compiler necessary to build for a desired target architecture (e.g., CC65, Z88DK, etc.).

Once you have Cross-Lib with its dependencies in a POSIX environment, you should move to the "src" directory.
Inside "src" you will find the following directories 
- "cross-lib", which contains the library code;
- "games" with built-in games;
- "examples" with built-in examples;
- "projects" with user-defined projetcs.


If you have correctly installed just Makefile, Python and (native) GCC in a POSIX environment, 
it should already be possible to minimally use Cross-Lib to build the Chase game by running the following command inside the "src" directory:
"xl chase gcc", which will build Chase in turn-based mode for the native console.


# HOW TO USE THE XL SCRIPT

If just one of the supported compilers is installed, Cross-Lib can be used with the "xl" Python script inside the "src" directory.
If GCC with ncurses is installed, a native version of the games and examples can be built with:
"xl build <project name>" or just "xl <project name>"
For example 
"xl snake" 
builds the "snake" game for the native console.

If a cross compiler (CC65, Z88DK, CMOC, CC6303, LCC1802, etc) is installed, the games and examples can be built for the corresponding systems.
For example, if CC65 is installed, 
"xl horde apple2" 
builds the "horde" game for the Apple //.

The "xl" script takes many commands. In particular you can see a list of the available commands with "xl commands".
You can get an explanation of each command with examples with 
"xl help <command name>".

If we want to create a new project, we need to use 
"xl create <project name>", 
which will create a project with a trivial "hello world" example inside the "projects" directory.
We can start with a template code for a game if we pass an additional parameter: "xl create <project name> game".

 
# HELLO WORLD

Coding with Cross-Lib is like normal coding in C (with ANSI C89) with the only addition that all input/output is done through Cross-Lib APIs.

Cross-Lib comes with many examples in the src/examples/ directory as well as a few games in the src/games directory.
Both of which can be used to learn how to code with Cross-Lib.

We could start to look at src/examples/helloworld/, whose main.c files contains: 

#include "cross_lib.h"

int main(void)
{        
    _XL_INIT_GRAPHICS();

    _XL_CLEAR_SCREEN();

    _XL_SET_TEXT_COLOR(_XL_WHITE);

    _XL_PRINT_CENTERED("HELLO WORLD");

    while(1){};
    
    return EXIT_SUCCESS;
}

We remark that all Cross-Lib specific functions start with the _XL_ prefix: 
1. _XL_INIT_GRAPHICS() required to initialize the display ;
2. _XL_CLEAR_SCREEN()  which cleans the content of the screen ;
3. _XL_SET_TEXT_COLOR(_XL_WHITE) which defines the color to be used by the text and characters ;
4. _XL_PRINT_CENTERED("HELLO WORLD") which displays "HELLO WORLD" on the center of the screen.

If we want to use one of the examples or games as a starting point we can clone the project with:
xl clone <existing project to clone> <new project name>

Or we can start from (almost) scratch with
xl create <new project name>

Once we have a new project, we can build it with
xl <project> <target>

or

xl <project>
if we want to build the project for the native terminal.

We can run the project for the native terminal with:
xl run <project>

For example we could run these commands:
xl clone helloworld myhelloworld [to clone helloworld and create myhellworld]
We modify the project myhelloworld (found inside ./src/projects/myhelloworld/)
xl build myhelloworld (or equivalently xl myhelloworld) [to build a native binary of the new project]
xl run myhelloworld [to run the new project]
xl build myhelloworld apple2 [to build the same project for the Apple //]


# CODING WITH ABSTRACTIONS

In order to code with Cross-Lib for all targets at the same time, Cross-Lib uses several abstractions.

Graphics is only tile-based. In the code, tiles are abstract as their exact shape will depend on the target type.
The code only sees the macros _TILE_0, _TILE_1, _TILE_2, etc. that contain uint_8t values (which depend on the target).
Each concrete target will interpret tiles in different ways depending on whether the target can or cannot assign free shapes to tiles and 
on the number of pixels that define tiles on that system.

Sound is currently only limited to few sound effects that are rendered somehow similarly across multiple targets.

Input is only limited to 4 directions and a single fire button. On each target this will be mapped to either 5 keys (usually I J K L SPACE)
or the main joystick/controller/gamepad.

Running "xl manual" will output a manual with all commands.


# MAIN DEVELOPMENT FLOW

Producing "universal" games with Cross-Lib for the developer boils down to these main steps:
- Creating or cloning a project (with xl create or xl clone);
- Writing the abstract game code in ANSI C with Cross-Lib APIs for input/output;
- Manually creating or automatically importing abstract assets (with commands such as e.g., xl shapes, xl import, xl rip, xl tile);
- Running the xl script to build the project for one or multiple targets (with xl build).

The "xl build <project> <target>" command (or its equivalent short form "xl <project> <target>") 
executes one or several Makefile targets, which generally:
- generate a concrete asset file from the abstract asset files
- compile the source code
- link the source code with the asset files
- if necessary a tool is used to create a usable disk/floppy/rom/cartridge image




# GRAPHICS

Graphics is performed by either displaying "tiles", whose shape can be freely defined or by "characters" (letters, digits and the space character).
Characters and tiles have the same size. Characters are used for the text, whereas tiles are used for graphics.

ASCII-only targets will be able to only assign ASCII shapes to tiles, whereas targets with real graphics will assign a "freely defined" shape to the tile.

Currently each tile only has one tile-specific foreground color and a common background color.
The definition of their shapes is not done in the C code.
Instead it is done inside the <project>/tiles directory, which contains sub-directories with files with tile definitions for the ASCII case and 
for the graphics-enabled targets, e.g., 8x8 (for most targets), 7x8 (for Apple //), 6x8 (for Oric and NTSC COMX-35), etc... 

In the aforementioned files the shapes are described by either ASCII codes for ASCII-only targets or sequences of bytes for graphics-enabled targets.

These files can be:
1. either edited manually or 
2. automatically imported from several programs such as CharPad (with "xl import <file> <project>") or 
3. automatically ripped from BASIC or Assembly listings (with "xl rip <file> <project>") or
4. generated by some simple "pictorial" text files with drawings made of "#" and "." characters 
(with "xl shapes <project> <x_size> <y_size> or "xl tile <file> <project> <tile number>".

You can see how to use these commands by running "xl help <command name>".

In the code tile graphics is primarily performed by these commands that display a tile or delete it:
void _XL_DRAW_TILE(uint8_t x, uint8_t y, uint8_t tile_number, uint8_t tile_color);
void _XL_DELETE(uint8_t x, uint8_t y);


# SOUND

Sound is even more limited than graphics and it is limited to a few predefined effects.
The sound commands have this form:
void _XL_<effect name>_SOUND(void);

For example:
XL_EXPLOSION_SOUND() produces an explosion sound (or something vaguely similar to it depending on the target)


# INPUT

Input is limited to four directions and a single fire button.
The input APIs are:
uint8_t _XL_INPUT(void);
uint8_t _XL_LEFT(uint8_t input);
uint8_t _XL_RIGHT(uint8_t input);
uint8_t _XL_UP(uint8_t input);
uint8_t _XL_DOWN(uint8_t input);
uint8_t _XL_FIRE(uint8_t input);


# GRAPHICS, SOUNDS AND INPUT IN ONE EXAMPLE

Inside the src/examples/animate directory you can find the following example that could be used as a blueprint for a simple game.
This trivial example has graphics, input and sound.
When compiled for any of the possible systems, it will produce the very same program but the exact tile shapes and sounds will depend on the target.
For example it can be compiled for the native console with:
xl animate
or for the Apple // with
xl animate apple2


#include "cross_lib.h"

#define MIN_X 1
#define MAX_X (XSize-2)
#define MIN_Y 1
#define MAX_Y (YSize-2)
#define DOWN_TILE  _TILE_0
#define UP_TILE    _TILE_1 
#define RIGHT_TILE _TILE_2
#define LEFT_TILE  _TILE_3 
#define FIRE_TILE  _TILE_4

int main(void)
{ 
 uint8_t x;
 uint8_t y;
 uint8_t input;
 uint8_t tile;

 _XL_INIT_GRAPHICS();
 _XL_INIT_SOUND();
 _XL_INIT_INPUT();

 _XL_CLEAR_SCREEN();

 x = XSize/2;
 y = YSize/2;
 tile = DOWN_TILE;
 hile(1)
 {
        _XL_SET_TEXT_COLOR(_XL_WHITE);
        _XL_PRINTD(0,0,3,x);
        _XL_PRINTD(5,0,3,y);
        
        input = _XL_INPUT();
        if(_XL_UP(input))
        {
            _XL_DELETE(x,y);
            tile = UP_TILE;
            --y;
        }
        else if (_XL_DOWN(input))
        {
            _XL_DELETE(x,y);
            tile = DOWN_TILE;
            ++y;
        }
        else if (_XL_LEFT(input))
        {
            _XL_DELETE(x,y);
            tile = LEFT_TILE;
            --x;
        }
        else if(_XL_RIGHT(input))
        {
            _XL_DELETE(x,y);
            tile = RIGHT_TILE;
            ++x;
        }
        else if(_XL_FIRE(input))
        {
            _XL_DRAW(x,y,FIRE_TILE,_XL_WHITE);
            _XL_EXPLOSION_SOUND();
            _XL_SLOW_DOWN(16*_XL_SLOW_DOWN_FACTOR);  
        }
        
        if((y>=MIN_Y)&&(y<=MAX_Y)&&(x>=MIN_X)&&(x<=MAX_X))
        {
            _XL_DRAW(x,y,tile,_XL_WHITE);
        }
        else
        {
            _XL_DELETE(x,y);
            _XL_ZAP_SOUND();
            _XL_SLOW_DOWN(16*_XL_SLOW_DOWN_FACTOR);  
            x = XSize/2;
            y = YSize/2;
        }    
        _XL_SLOW_DOWN(4*_XL_SLOW_DOWN_FACTOR);    
    }
    return EXIT_SUCCESS;
}


# THE GAMES

Cross-Lib comes with some games I have written with it. As for January 2023, it includes six games:
- Cross Verbix
- Cross Horde
- Cross Snake
- Cross Bomber
- Cross Shoot
- Cross Chase
which are also refered to as Verbix, Horde, Snake, Bomber, Shoot, Chase.

## VERBIX

Verbix is a Scrabble-like game that looks a bit like Tetrix.
In this game you have to form valid 5-letter English words on the bottom row before the tower of letters reaches the top level.
You can rotate the bottom row or any of the columns by moving in the 4 directions. You press fire to confirm the word.

    Cross Horde is a zombie shooter with several different enemies, levels, power-ups and special items to pick.
    Cross Snake is my personal re-interpretation of Nibbler (arcade game) to which I have added more game elements. It has 50 secrets and several items to discover.
    Cross Bomber is a mini-game and clone of Air Attack (aka Blitz).
    Cross Shoot is a shooter somehow similar to Robotron. It has many items and secrets to discover.
    Cross Chase is somehow similar to Gnome Robots. The main difference is that it is a real-time game and that it has several items and power-ups to pick.

