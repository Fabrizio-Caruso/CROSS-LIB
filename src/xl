#!/usr/bin/env python

from __future__ import print_function

import datetime
import shutil
import os
import sys
import time

from os import walk

sys.path.append("modules")

from modules.strings import *
from modules.import_from_source import *
from modules.tiles import *
from modules.LoggerSingleton import LoggerSingleton
from modules.init import *
from modules.default_values import insert_default_sizes
from modules.params import \
    handle_two_letter_params, full_params, COMMANDS_LIST, get_size_params
from modules.help_functions import help_command, manual
from modules.file_functions import *
from modules.tests import *
from modules.split_projects import *
from run import run_command

C64_EMULATOR = "x64"
VIC20_EMULATOR = "xvic"
PLUS4_EMULATOR = "xplus4"
PET_EMULATOR = "xpet"

MAME_EMULATOR = "mame"

# platform = sys.platform

# if(platform in ["cygwin", "msys"]):
    # NATIVE_EXTENSION="exe"
# else:
    # NATIVE_EXTENSION="out"


# compilation_threads = None
# parallelize_multi_build = None
# z88dk_compiler_opts = None
# z88dk_compiler = None
# sccz80_compiler_opts = None
# zsdcc_compiler_opts = None
# cmoc_compiler_opts = None
# cc65_compiler_opts = None
# lcc1802_compiler_opts = None
# gcc4ti99_compiler_opts = None
# vbcc_compiler_opts = None
# native_compiler_opts = None
# native_compiler = None
# tool_compiler = None
# interactive_clean = None
# vice_path = None
# vice_rom_path = None
# mame_path = None
# mame_rom_path = None
# extend_algorithm = None
# replace_shapes = None
# use_tools = None
# config = None


# LoggerSingleton.initLogger(__name__)
logger = LoggerSingleton.initLogger('xl', '../logs')

# console_logger = LoggerSingleton.initConsoleLogger('console')

# console_logger.info('Console logger started')

logger.info('Started')

class TerminalConfig():
    def __init__(
        self,
        verbose,
        color_terminal,
        test
        ):
        # terminal
        self.verbose = verbose
        self.color_terminal = color_terminal
        self.test = test


class RomConfig():
    def __init__(
        self,
        vice_path,
        vice_rom_path,
        mame_path,
        mame_rom_path
        ):
        self.vice_path = vice_path
        self.vice_rom_path = vice_rom_path
        self.mame_path = mame_path
        self.mame_rom_path = mame_rom_path

class ExtendConfig():
    def __init__(
        self,
        extend_algorithm,
        replace_shapes
        ):
        self.extend_algorithm = extend_algorithm
        self.replace_shapes = replace_shapes


class BuildConfig():
    def __init__(
        self,
        compilation_threads,
        parallelize_multi_build,
        z88dk_compiler,
        z88dk_compiler_opts,
        sccz80_compiler_opts,
        zsdcc_compiler_opts,
        cmoc_compiler_opts,
        cc65_compiler_opts,
        lcc1802_compiler_opts,
        gcc4ti99_compiler_opts,
        vbcc_compiler_opts,
        native_compiler_opts,
        native_compiler,
        tool_compiler,
        use_tools
        ):

        # build
        self.compilation_threads     = compilation_threads
        self.parallelize_multi_build = parallelize_multi_build
        self.z88dk_compiler          = z88dk_compiler
        self.z88dk_compiler_opts     = z88dk_compiler_opts
        self.sccz80_compiler_opts    = sccz80_compiler_opts
        self.zsdcc_compiler_opts     = zsdcc_compiler_opts
        self.cmoc_compiler_opts      = cmoc_compiler_opts
        self.cc65_compiler_opts      = cc65_compiler_opts
        self.lcc1802_compiler_opts   = lcc1802_compiler_opts
        self.gcc4ti99_compiler_opts  = gcc4ti99_compiler_opts
        self.vbcc_compiler_opts      = vbcc_compiler_opts
        self.native_compiler_opts    = native_compiler_opts
        self.native_compiler         = native_compiler
        self.tool_compiler           = tool_compiler
        self.use_tools               = use_tools

    def get_opts(self):
        return \
            self.compilation_threads, \
            self.parallelize_multi_build, \
            self.z88dk_compiler, \
            self.z88dk_compiler_opts, \
            self.sccz80_compiler_opts, \
            self.zsdcc_compiler_opts, \
            self.cmoc_compiler_opts, \
            self.cc65_compiler_opts, \
            self.lcc1802_compiler_opts, \
            self.gcc4ti99_compiler_opts, \
            self.vbcc_compiler_opts, \
            self.native_compiler_opts, \
            self.native_compiler, \
            self.tool_compiler, \
            self.use_tools

class CleanConfig:
    def __init__(
        self,
        interactive_clean
    ):
        self.interactive_clean = interactive_clean
        


class OptionConfig:
    def __init__(
        self,
        
        terminal_config,
        build_config, 
        clean_config,
        rom_config,
        extend_config,  

    ):
        self.terminal_config = terminal_config
               
        self.build_config = build_config
               
        # clean
        self.clean_config = clean_config

        # rom
        self.rom_config = rom_config

        # extend
        self.extend_config = extend_config

        # tools
        # self.use_tools = use_tools

def clean_test(option_config):
    clean(option_config, ["clean","-y"])
    files_after_clean = len(files_in_path("../build"))

    if files_after_clean>1:
        printc(option_config, bcolors.FAIL, "[xl clean]          KO\n")
        return 0
    printc(option_config, bcolors.OKGREEN, "[xl clean]          OK\n")
    return 1


def all_compilers_opts(option_config, zsdcc_extra_optimization, compiler_opts):

    compilation_threads, \
    parallelize_multi_build, \
    z88dk_compiler, \
    z88dk_compiler_opts, \
    sccz80_compiler_opts, \
    zsdcc_compiler_opts, \
    cmoc_compiler_opts, \
    cc65_compiler_opts, \
    lcc1802_compiler_opts, \
    gcc4ti99_compiler_opts, \
    vbcc_compiler_opts, \
    native_compiler_opts, \
    native_compiler, \
    tool_compiler, \
    use_tools \
    = option_config.build_config.get_opts()
    
    if z88dk_compiler in ('zsdcc','sdcc'):
        compiler_selection = " -compiler=sdcc "
        compiler_opts = compiler_opts + " " + zsdcc_compiler_opts
    elif z88dk_compiler in ('ez80clang', 'clang'):
        compiler_selection = " -compiler=ez80clang "
    else:
        compiler_selection = ""
        compiler_opts = compiler_opts + " " + sccz80_compiler_opts


    return " ZSDCC_MAKEFILE_COMPILATION_OPTS='" + zsdcc_compiler_opts + " " + \
                                                  zsdcc_extra_optimization + "'" + \
           " Z88DK_MAKEFILE_COMPILATION_OPTS='" + z88dk_compiler_opts + compiler_opts + \
                                                  compiler_selection + "'" + \
           " GCC4TI99_MAKEFILE_COMPILATION_OPTS='" + gcc4ti99_compiler_opts + "'" + \
           " VBCC_MAKEFILE_COMPILATION_OPTS='" + vbcc_compiler_opts + "'" + \
           " NATIVE_MAKEFILE_COMPILATION_OPTS='" + native_compiler_opts + "'" + \
           " CMOC_MAKEFILE_COMPILATION_OPTS='" + cmoc_compiler_opts + "'" + \
           " CC65_MAKEFILE_COMPILATION_OPTS='" + cc65_compiler_opts + "'" + \
           " LCC1802_MAKEFILE_COMPILATION_OPTS='" + lcc1802_compiler_opts + "'"


def generic_input(string):
    if sys.version_info[0] < 3:
        return raw_input(string)
    return input(string)

def are_you_sure():
    return generic_input("Are you sure [Y/N]? ").lower()


def multiple_project_reset(option_config, mypath):
    projects = []
    for (_, dirnames, _) in walk(mypath):
        projects.extend(dirnames)
        break

    for project_name in projects:
        print("PROJECT: " + project_name)
        reset(option_config, [mypath, project_name])
        print("\n")


def multiple_size_build(mypath,target,xsize,ysize,debug):
    projects = []
    for (_, dirnames, _) in walk(mypath):
        projects.extend(dirnames)
        break

    if use_tools:
        use_tools_str = " USE_TOOLS=1 "
    else:
        use_tools_str = ""

    for project_name in projects:

        if is_project_split(project_name):
            project_type = project_category(project_name)
            create_main(project_name,project_type)
        make_command = \
            GNU_MAKE + " " + target + use_tools_str + " XSIZE=" + xsize +  \
                       " YSIZE=" + ysize + " _DEBUG_FLAG=" + str(debug) + \
                " _NATIVE_CC=" + native_compiler + " " + all_compilers_opts(all_compilers_opts, "","") + \
                " GNU_MAKE=" + GNU_MAKE + \
                " TOOL_CC=" + tool_compiler + \
                " -f " + mypath+"/"+project_name+"/Makefile."+project_name

        run_command(option_config, make_command)
        if is_project_split(project_name):
            delete_main(option_config, project_name,project_type)

#TODO: cc65 targets
#TODO: cmoc targets
#TODO: lcc1802 targets
#TODO: mc10 (6303)
#TODO: c128 (complicated because of c1541)
#TODO: cpc (complicated because of nocart)
PARALLEL_TARGETS = \
    [
    'stdio',

    'apple2',
    'apple2enh',
    'atari',
    'atari_lynx',
    'atari5200',
    'atari7800',
    'c16',
    'c64',
    'cbm610',
    'cbm510',
    'creativision',
    'gamate',
    'oric',
    'nes',
    'pet',
    'pce',
    'supervision',
    'vic20',

    'ncurses',
    'terminal',
    'terminal8x8',
    'terminal8x6',
    'terminal7x8',
    'terminal6x9',
    'terminal6x8',

    'ace',
    'agon',
    'aquarius',
    'aussie',
    'bit90',
    'camputers_lynx',
    'cpm',
    'coleco',
    'eg2k',
    'einstein',
    'gb',
    'gal',
    'gl6000sl',
    'gamegear',
    'hector',
    'hectorhr',
    'kaypro',
    'kaypro83',
    'kc85',
    'lambda',
    'laser500',
    'm5',
    'm5_rom',
    'm5_keyboard',
    'm5_keyboard_rom',
    'm100',
    'mc1000',
    'mc1000_mono',
    'microbee',
    'msx',
    'mtx500',
    'mtx512',
    'mz',
    'mz2500',
    'newbrain',
    'nc100',
    'nc200',
    'pc8201',
    'pc88',
    'pv1000',
    'pv1000_no_gfx',
    'px4',
    'px8',
    'samcoupe',
    'sc3000',
    'sc3000_rom',
    'sg1000',
    'sms',
    'spectrum',
    'svi',
    't200',
    'trs80',
    'vg5k',
    'vz200',
    'x1',
    'zx81',
    'zx81_wrx',
    'zx81_8x6',
    'zx81_wrx64',
    'zx81_8x6_wrx64',
    'zx81_wrx128',
    'zx81_8x6_wrx128',
    'z9001',
    'kc',
    'z1013',
    'zx80',
    'zxn'
    ]

def multiple_build(option_config, mypath,target,threads,zsdcc_extra_optimization, reset_flag=False):
    projects = []

    verbose = option_config.terminal_config.verbose

    compilation_threads, \
    parallelize_multi_build, \
    z88dk_compiler, \
    z88dk_compiler_opts, \
    sccz80_compiler_opts, \
    zsdcc_compiler_opts, \
    cmoc_compiler_opts, \
    cc65_compiler_opts, \
    lcc1802_compiler_opts, \
    gcc4ti99_compiler_opts, \
    vbcc_compiler_opts, \
    native_compiler_opts, \
    native_compiler, \
    tool_compiler, \
    use_tools \
    = option_config.build_config.get_opts()

    if use_tools:
        use_tools_str = " USE_TOOLS=1 "
    else:
        use_tools_str = ""

    for (_, dirnames, _) in walk(mypath):
        projects.extend(dirnames)
        break

    projects_to_build = len(projects)

    # files_before = len(files_in_path("../build"))-1
    if verbose:
        print("Building " + str(projects_to_build) + " projects: ", end="")
        for project_name in projects:
            printc(option_config, bcolors.OKCYAN,project_name+" ")
        print("")

    if (parallelize_multi_build==1) and (target in PARALLEL_TARGETS):
        logger.info("Parallelize multi build with %s", threads)
        pool = Pool(processes=int(threads))

        for project_name in projects:
            if verbose:
                print("project name: " + project_name)
            if reset_flag:
                reset(option_config, ["",project_name])
            if is_project_split(project_name):
                project_type = project_category(project_name)
                create_main(project_name,project_type)
            make_command = \
                GNU_MAKE + " " + target + use_tools_str + \
                    " ZSDCC_MAKEFILE_THREADS_OPTS=\'-j " + threads + "'" \
                    + all_compilers_opts(option_config, zsdcc_extra_optimization, "") + \
                    " _NATIVE_CC=" + native_compiler + \
                    " TOOL_CC=" + tool_compiler + " GNU_MAKE=" + GNU_MAKE + \
                    " -f " + mypath+"/"+project_name+"/Makefile."+project_name
            pool.apply_async(run_command, [option_config, make_command])

        pool.close()
        pool.join()

        for project_name in projects:
            if is_project_split(project_name):
                delete_main(option_config, project_name,project_type)
    else:
        for project_name in projects:
            if reset_flag:
                reset(option_config, ["",project_name])
            print("project name: " + project_name)
            if is_project_split(project_name):
                project_type = project_category(project_name)
                create_main(project_name,project_type)
            make_command = \
                GNU_MAKE + " " + target + use_tools_str + \
                    " ZSDCC_MAKEFILE_THREADS_OPTS=\'-j " + threads + "'" \
                    + all_compilers_opts(option_config, zsdcc_extra_optimization, "") + \
                    " _NATIVE_CC=" + native_compiler + \
                    " TOOL_CC=" + tool_compiler + " GNU_MAKE=" + GNU_MAKE + \
                    " -f " + mypath+"/"+project_name+"/Makefile."+project_name

            run_command(option_config, make_command)
            if is_project_split(project_name):
                delete_main(option_config, project_name,project_type)


# Run a project natively (terminal with ncurses) with a given XSize and YSize
def size(option_config, params,debug):
    verbose = option_config.terminal_config.verbose
    if len(params)<2:
        game_dir = "helloworld"
    else:
        game_dir = params[1]

    project_type = project_category(game_dir)

    parent_dir = project_type + "s"

    target, xsize, ysize = get_size_params(params)

    if verbose:
        print("Project name       : " + game_dir)
        print("Project type       : " + project_type)
        print("XSize: " + xsize)
        print("YSize: " + ysize)
        print("target: " + target)

    parent_and_game_dir = parent_dir + "/" + game_dir

    files_before = len(files_in_path("../build"))-1


    if game_dir not in ["games", "examples", "projects", "all"]:
        if not os.path.exists(parent_and_game_dir):
            print("Project not found!")
            return
        native_compiler = option_config.build_config.native_compiler
        tool_compiler   = option_config.build_config.tool_compiler
        if is_project_split(game_dir):
            printc(option_config, bcolors.OKBLUE,"Create main.c from split source files\n")
            create_main(game_dir, project_type)
        make_command = \
            GNU_MAKE + " " + target + " XSIZE=" + xsize +  " YSIZE=" + ysize + \
                " _DEBUG_FLAG=" + str(debug) + " " \
                + all_compilers_opts(option_config, "","") + \
                " _NATIVE_CC=" + native_compiler + \
                " TOOL_CC=" + tool_compiler + \
                " -f " + parent_dir+"/"+game_dir+"/Makefile."+game_dir
        run_command(option_config, make_command)

        if is_project_split(game_dir):
            printc(option_config, bcolors.OKBLUE,"Delete main.c (because of split source files)\n")
            delete_main(option_config, game_dir, project_type)
    else:
        if game_dir in["games","examples","projects"]:
            multiple_size_build(game_dir,target,xsize,ysize,debug)
        elif game_dir in["new"]:
            multiple_size_build("projects",target,xsize,ysize,debug)
        elif game_dir in["builtin","built-in"]:
            multiple_size_build("games",target,xsize,ysize,debug)
            multiple_size_build("examples",target,xsize,ysize,debug)
        elif game_dir=="all":
            multiple_size_build("games",target,xsize,ysize,debug)
            multiple_size_build("examples",target,xsize,ysize,debug)
            multiple_size_build("projects",target,xsize,ysize,debug)
        else:
            return

    files_after = len(files_in_path("../build"))-1

    if verbose:
        print("New binaries built: " + str(files_after-files_before)+"\n")


# Rebuild a project, i.e., also rebuilds assets
def rebuild(option_config, params):
    build(option_config, params, reset_flag=True)


def convert_makefile(option_config, dir,old_type,old_name,new_name):

    dest_path = "projects/"+dir
    source_game_dir = old_name
    target_game_dir = new_name
    source_parent_dir = old_type
    target_parent_dir = "projects"

    if option_config.terminal_config.verbose:
        print("- dir: " + dir)
        print("- old_type: " + old_type)
        print("- old_name: " + old_name)
        print("- new_game: " + new_name)

    fin = open("./"+dest_path+"/Makefile."+source_game_dir, "rt")
    data = fin.read()
    data = data.replace('CROSS-' + source_game_dir.upper(),'CROSS-'+target_game_dir.upper())
    data = data.replace('GAME_NAME := ' + source_game_dir, 'GAME_NAME := '+target_game_dir)
    data = data.replace('PARENT_DIR = ' + source_parent_dir + "s", \
           'PARENT_DIR = ' + target_parent_dir)

    data = data.replace('include ./' + old_type + "s/" + source_game_dir, \
           'include ./projects/' + target_game_dir)
    fin.close()
    fin = open("./"+dest_path+"/Makefile."+target_game_dir, "wt")
    fin.write(data)
    fin.close()

    os.remove("./"+dest_path+"/Makefile."+source_game_dir)


# Rename a project
def rename(option_config, params):
    if len(params)<2:
        source_game_dir = "helloworld"
    else:
        source_game_dir = params[1]

    if len(params)<3:
        print("ERROR: You need to provide more paramaters")
        return

    target_game_dir = params[2]

    source_project_type = project_category(source_game_dir)

    if source_project_type != "project":
        return

    target_project_type = "project"
    target_parent_dir = target_project_type + "s"
    target_parent_dir_and_game_dir = target_parent_dir + "/" + target_game_dir

    if option_config.terminal_config.verbose:

        print("source_project_type: " + source_project_type)

    convert_makefile(option_config, source_game_dir, source_project_type, source_game_dir, target_game_dir)

    os.rename(target_parent_dir + "/" +source_game_dir, target_parent_dir_and_game_dir)


# Clone a project to create a new one
def clone(option_config, params):
    verbose = option_config.terminal_config.verbose
    if len(params)<2:
        source_game_dir = "helloworld"
    else:
        source_game_dir = params[1]

    if len(params)<3:
        return

    target_game_dir = params[2]


    source_project_type = project_category(source_game_dir)
    if verbose:
        print("source project category: " + source_project_type)
    source_parent_dir = source_project_type + "s"
    source_parent_and_game_dir = source_parent_dir + "/" + source_game_dir

    target_project_type = "project"
    target_parent_dir = target_project_type + "s"
    target_parent_dir_and_game_dir = target_parent_dir + "/" + target_game_dir

    if verbose:
        print("Source project name    : " + source_game_dir)
        print("Source Project type    : " + source_project_type)
        print("Path to source project : " + source_parent_and_game_dir)
        print("")
        print("Target project name    : " + target_game_dir)
        print("target Project type    : " + target_project_type)
        print("Path to target project : " + target_parent_dir_and_game_dir)

    source_path = source_parent_and_game_dir
    if verbose:
        print("source_path: " + source_path)
    dest_path = target_parent_dir_and_game_dir
    if verbose:
        print("dest_path: " + dest_path)

    if not os.path.exists(dest_path+"/tiles"):
        if verbose:
            print("Copying tiles...")
        shutil.copytree(source_path, dest_path)

    if not os.path.exists(dest_path+"/generated_assets"):
        if verbose:
            print("Create empty generated_assets directory...")
        os.makedirs(dest_path+"/generated_assets")

    convert_makefile(option_config, target_game_dir, source_project_type, source_game_dir, target_game_dir)


# Generate tools from source code
def tools(option_config):
    compilation_threads = option_config.build_config.compilation_threads
    tool_compiler = option_config.build_config.tool_compiler
    make_command = \
        GNU_MAKE + " -j " + compilation_threads + " tools TOOL_CC=" + tool_compiler + \
        " GNU_MAKE=" + GNU_MAKE + " -f makefiles.common/auxiliary/Makefile_tools"
    run_command(option_config, make_command)


# Build a project (for a target or multiple targets)
def build(option_config, params, reset_flag = False):
    params = insert_default_sizes(params)

    # sized terminal
    if len(params)>=4 and params[2].startswith("terminal") and params[3].isnumeric() \
                      and params[4].isnumeric():
        size(option_config, ["size"] + params[1:],0)
        return

    if len(params)<2:
        game_dir = "helloworld"
    else:
        game_dir = params[1]

    if len(params)>=1 and game_dir=="tools":
        tools(option_config)
    else:

        files_before = len(files_in_path("../build"))-1

        project_type = project_category(game_dir)
        parent_dir = project_type + "s"

        if len(params)<3:
            target = "ncurses"
        else:
            target = params[2]

        if target in ["cc65", "z88dk", "cmoc", "lcc1802", "cc6303", "gcc4ti", "vbcc"]:
            target = target + "_targets"

        compilation_threads, \
        parallelize_multi_build, \
        z88dk_compiler, \
        z88dk_compiler_opts, \
        sccz80_compiler_opts, \
        zsdcc_compiler_opts, \
        cmoc_compiler_opts, \
        cc65_compiler_opts, \
        lcc1802_compiler_opts, \
        gcc4ti99_compiler_opts, \
        vbcc_compiler_opts, \
        native_compiler_opts, \
        native_compiler, \
        tool_compiler, \
        use_tools \
        = option_config.build_config.get_opts()


        # compilation_threads = option_config.build_config.compilation_threads
        if len(params)<4:
            threads = str(compilation_threads)
        else:
            threads = params[3]

        # zsdcc_extra_optimization = option_config.build_config.zsdcc_extra_optimization
        if len(params)>=5 and params[4]=="on":
            zsdcc_extra_optimization = "--max-allocs-per-node200000"
        else:
            zsdcc_extra_optimization = ""

        # compiler_opts = option_config.build_config.compiler_opts
        if len(params)>=6:
            compiler_opts = " " + params[5]
        else:
            compiler_opts = ""

        color_terminal = option_config.terminal_config.color_terminal

        verbose = option_config.terminal_config.verbose
        
        # z88dk_compiler_opts = option_config.build_config.z88dk_compiler_opts
        # zsdcc_compiler_opts = option_config.build_config.zsdcc_compiler_opts
        # cmoc_compiler_opts = option_config.build_config.cmoc_compiler_opts
        # cc65_compiler_opts = option_config.build_config.cc65_compiler_opts
        # lcc1802_compiler_opts = option_config.build_config.lcc1802_compiler_opts
        # gcc4ti99_compiler_opts = option_config.build_config.gcc4ti99_compiler_opts
        # vbcc_compiler_opts = option_config.build_config.vbcc_compiler_opts
        # native_compiler_opts = option_config.build_config.native_compiler_opts
        
        if verbose:

            print("Project name       : ", end="")
            printc(option_config, bcolors.BOLD, game_dir+"\n")

            print("Target name        : ", end="")
            printc(option_config, bcolors.UNDERLINE, target+"\n")

            print("Project type       : " + project_type)
            print("Number of threads  : " + threads)
            print("Extra optimization : " + zsdcc_extra_optimization)
            print("Compiler's options : " + compiler_opts)

            print("--------------------------")
            print("z88dk_compiler_opts     : " + z88dk_compiler_opts)
            print("zsdcc_compiler_opts     : " + zsdcc_compiler_opts)
            print("cmoc_compiler_opts      : " + cmoc_compiler_opts)
            print("cc65_compiler_opts      : " + cc65_compiler_opts)
            print("lcc1802_compiler_opts   : " + lcc1802_compiler_opts)
            print("gcc4ti99_compiler_opts  : " + gcc4ti99_compiler_opts)
            print("vbcc_compiler_opts      : " + vbcc_compiler_opts)
            print("native_compiler_opts    : " + native_compiler_opts)

            print("")

        parent_and_game_dir = parent_dir + "/" + game_dir

        if os.path.exists(parent_and_game_dir + "/config.ini"):
            print("Local config.ini detected")
            read_config(parent_and_game_dir + "/config.ini")

        if game_dir not in ["games", "examples", "projects", "all"]:
            # use_tools = option_config.build_config.use_tools
            if reset_flag:
                reset(option_config, params)
            if not os.path.exists(parent_and_game_dir):
                print("Project not found!")
                return
            if use_tools:
                use_tools_str = " USE_TOOLS=1 "
            else:
                use_tools_str = ""

            if is_project_split(game_dir):
                printc(option_config, bcolors.OKBLUE,"Create main.c from split source files\n")
                create_main(game_dir, project_type)

            make_command = \
                GNU_MAKE + " " + target + \
                    use_tools_str + \
                    " ZSDCC_MAKEFILE_THREADS_OPTS=\'-j " + threads + "' " \
                    + all_compilers_opts(option_config, zsdcc_extra_optimization, compiler_opts) +  \
                    " _NATIVE_CC=" + native_compiler + \
                    " TOOL_CC=" + tool_compiler + " GNU_MAKE=" + GNU_MAKE + \
                    " -f " + parent_dir+"/"+game_dir+"/Makefile."+game_dir

            run_command(option_config, make_command)

            if is_project_split(game_dir):
                printc(option_config, bcolors.OKBLUE,"Delete main.c because of split source files\n")
                delete_main(option_config, game_dir, project_type)

        else:
            if game_dir in ["games","examples","projects"]:
                multiple_build(option_config, game_dir,target,threads,zsdcc_extra_optimization, reset_flag)
            elif game_dir=="new":
                multiple_build(option_config, "projects",target,threads,zsdcc_extra_optimization, reset_flag)
            elif game_dir in ["builtin","built-in"]:
                multiple_build(option_config, "games",target,threads,zsdcc_extra_optimization, reset_flag)
                multiple_build(option_config, "examples",target,threads,zsdcc_extra_optimization, reset_flag)
            elif game_dir=="all":
                multiple_build(option_config, "games",target,threads,zsdcc_extra_optimization, reset_flag)
                multiple_build(option_config, "examples",target,threads,zsdcc_extra_optimization, reset_flag)
                multiple_build(option_config, "projects",target,threads,zsdcc_extra_optimization, reset_flag)
            else:
                return

        files_after = len(files_in_path("../build"))-1

        if verbose:
            printc(option_config, bcolors.OKBLUE, "New binaries built: " + str(files_after-files_before)+"\n")



def slow(option_config, params):

    game_dir = params[1]


    project_type = project_category(game_dir)
    parent_dir = project_type + "s"


    target = params[2]

    slowdown = params[3]


    parent_and_game_dir = parent_dir + "/" + game_dir

    if os.path.exists(parent_and_game_dir + "/config.ini"):
        print("Local config.ini detected")
        read_config(parent_and_game_dir + "/config.ini")

    if not os.path.exists(parent_and_game_dir):
        print("Project not found!")
        return

    if is_project_split(game_dir):
        printc(option_config, bcolors.OKBLUE,"Create main.c from split source files\n")
        create_main(game_dir, project_type)

    make_command = \
        GNU_MAKE + " " + target + \
            " SLOWDOWN=" + slowdown + \
            all_compilers_opts(option_config, "", "") +  \
            " -f " + parent_dir+"/"+game_dir+"/Makefile."+game_dir

    run_command(option_config, make_command)

    if is_project_split(game_dir):
        printc(option_config, bcolors.OKBLUE,"Delete main.c because of split source files\n")
        delete_main(option_config, game_dir, project_type)


# Create a new project
def create(option_config, params):
    verbose = option_config.terminal_config.verbose
    if len(params)<2:
        game_dir = "helloworld"
    else:
        game_dir = params[1]
    game_dir_capital = game_dir.upper()
    game_dir_capital_without_special_chars = \
        only_upper_digits_and_space(game_dir.upper().replace("-"," ").replace("_"," "))

    game_dir = no_space(game_dir)

    if game_dir in example_projects or game_dir in game_projects or game_dir in COMMANDS_LIST:
        print("invalid name!")
        return

    if len(params)<3:
        project_type = "helloworld"
    else:
        if params[2]=="game" or params[2]=="arcade":
            project_type = "arcade_game"
        elif params[2]=="text":
            project_type = "text_game"
        elif params[2]=="test":
            project_type = "test"
        else:
            if params[2] in ["apis","show_apis","example","show","demo"]:
                project_type = "demo"
            else:
                project_type = "helloworld"

    parent_dir = "projects"

    if verbose:
        print("New project name: " + game_dir)
        print("Project type: " + project_type)

    parent_and_game_dir = parent_dir + "/" + game_dir

    if not os.path.exists(parent_and_game_dir):
        if verbose:
            print("Creating project dir...")
        os.makedirs(parent_and_game_dir)

    source_path = "./template_projects/"+project_type+"_code.template"
    if verbose:
        print("source_path: " + source_path)
    dest_path = parent_and_game_dir
    if verbose:
        print("dest_path: " + dest_path)

    if not os.path.exists(dest_path+"/tiles"):
        if verbose:
            print("Copying tiles...")
        shutil.copytree(source_path+"/tiles", dest_path+"/tiles")

    if not os.path.exists(dest_path+"/shapes"):
        if verbose:
            print("Copying shapes...")
        if not os.path.exists(source_path+"/shapes"):
            os.makedirs(dest_path+"/shapes")
        else:
            shutil.copytree(source_path+"/shapes", dest_path+"/shapes")

    if not os.path.exists(dest_path+"/generated_assets"):
        if verbose:
            print("Create empty generated_assets directory...")
        os.makedirs(dest_path+"/generated_assets")

    if not os.path.exists(dest_path+"/config"):
        if verbose:
            print("Create empty config directory...")
        os.makedirs(dest_path+"/config")

    file_names = ["main.c"]

    for file_name in file_names:
        if verbose:
            print("Copying file_name: " + file_name)
        shutil.copy(source_path+"/"+file_name, dest_path)

    # Replace _GAME_NAME_CAPITAL with the capitalized game name without special characters
    fin = open("./"+dest_path+"/main.c", "rt")
    data = fin.read()
    data = data.replace('_GAME_NAME_CAPITAL',game_dir_capital_without_special_chars)
    fin.close()
    fin = open("./"+dest_path+"/main.c", "wt")
    #overrite the input file with the resulting data
    fin.write(data)

    templated_makefile_path = "./template_projects"

    shutil.copy(templated_makefile_path+"/"+"Makefile_game.template", \
                "./"+dest_path+"/Makefile."+game_dir)

    shutil.copy(templated_makefile_path+"/"+"/config/project_config.mk.template", \
                "./"+dest_path+"/config/project_config.mk")
    shutil.copy(templated_makefile_path+"/"+"/config/game_config.mk.template", \
                "./"+dest_path+"/config/game_config.mk")


    #read input file
    fin = open("./"+dest_path+"/Makefile."+game_dir, "rt")
    #read file contents to string
    data = fin.read()
    #replace all occurrences of the required string
    data = data.replace('_GAME_NAME_CAPITAL',game_dir_capital)
    data = data.replace('_GAME_NAME_', game_dir)
    data = data.replace('_PARENT_DIR_', parent_dir)
    #close the input file
    fin.close()
    #open the file in write mode
    fin = open("./"+dest_path+"/Makefile."+game_dir, "wt")
    #overrite the input file with the resulting data
    fin.write(data)
    #close the file
    fin.close()


# Delete temporary project files If a project is specified, it also deletes generated assets.
def reset(option_config, params):
    verbose = option_config.terminal_config.verbose
    par_len = len(params)

    if par_len>1:
        game_dir = params[1]
    else:
        game_dir=""

    if game_dir in ["games","examples","projects"]:
        multiple_project_reset(option_config, game_dir)
        return
    if game_dir=="new":
        multiple_project_reset(option_config, "projects")
        return
    if game_dir in ["builtin","built-in"]:
        multiple_project_reset(option_config, "games")
        multiple_project_reset(option_config, "examples")
        return
    if game_dir=="all":
        multiple_project_reset(option_config, "games")
        multiple_project_reset(option_config, "examples")
        multiple_project_reset(option_config, "projects")
        return

    if (len(params)==2) and (params[par_len-1]=='-y'): #(params[1]=='-y'):
        make_command = GNU_MAKE + \
                       " clean_generic_no_built_in -f makefiles.common/auxiliary/Makefile_common"

        if verbose:
            print("Delete all non-project-specific temporary files")

        run_command(option_config, make_command)
        return

    if len(params)<2:
        make_command = GNU_MAKE + \
            " clean_generic_no_built_in -f makefiles.common/auxiliary/Makefile_common"
        if verbose:
            print("Delete all non-project-specific temporary files")
        if are_you_sure()=="y":
            run_command(option_config, make_command)
            return
        return

    game_dir = params[1]

    project_type = project_category(game_dir)

    parent_dir = project_type + "s"

    if verbose:

        print("Project name: " + game_dir)

    parent_and_game_dir = parent_dir + "/" + game_dir

    if not os.path.exists(parent_and_game_dir):
        print("Project not found!")
        return

    if verbose:

        print("Delete all temporary files including generated assets for '"+game_dir+"'")

    # if (not interactive) or (are_you_sure()=="y"):
    make_command = GNU_MAKE + " clean_no_built_in -f " + \
                   parent_dir+"/"+game_dir+"/Makefile."+game_dir

    run_command(option_config,make_command)


# Clean project data
def clean(option_config, params):

    verbose = option_config.terminal_config.verbose

    if len(params)>=2:
        if params[1]=="tools":
            make_command = GNU_MAKE + " clean_tools -f makefiles.common/auxiliary/Makefile_tools"

            run_command(option_config, make_command)
            return
        if params[1]=="log" or params[1]=="logs":
            make_command = GNU_MAKE + " clean_logs -f makefiles.common/auxiliary/Makefile_tools"

            run_command(option_config, make_command)
            return

    if len(params)<2:
        make_command = GNU_MAKE + " clean_generic -f makefiles.common/auxiliary/Makefile_common"

        if verbose:
            print("Delete all built binaries and non-project=specific temporary files")
        if are_you_sure()=="y":
            run_command(option_config, make_command)
            return
        return
    if (len(params)==2) and (params[1]=='-y'):
        make_command = GNU_MAKE + " clean_generic -f makefiles.common/auxiliary/Makefile_common"

        if verbose:
            print("Delete all built binaries and non-project-specific temporary files")

        run_command(option_config, make_command)
        return

    game_dir = params[1]

    project_type = project_category(game_dir)

    parent_dir = project_type + "s"

    print("Project name: " + game_dir)

    parent_and_game_dir = parent_dir + "/" + game_dir

    if not os.path.exists(parent_and_game_dir):
        print("Project not found!")
        return

    print("Delete all built binaries and temporary files (also specific to '"+ \
          game_dir+"', e.g., generated assets)")

    # if (not interactive) or (are_you_sure()=="y"):
    make_command = GNU_MAKE + " clean -f " + parent_dir+"/"+game_dir+"/Makefile."+game_dir

    run_command(option_config, make_command)


# Delete project
def delete(option_config, params):
    if(len(params)>=2) and params[1]=="tools":
        make_command = GNU_MAKE + " clean_tools"

        run_command(option_config, make_command)
        return

    if len(params)<2:
        game_dir="helloworld"
    else:
        candidate_name = params[1]
        if candidate_name in example_projects or candidate_name in game_projects or \
            candidate_name in COMMANDS_LIST:
            print("invalid name!")
            return
        game_dir = candidate_name

    if (len(params)>2) and (params[2]=="-y"):
        interactive = False
    else:
        interactive = True

    parent_dir = "projects"
    verbose = option_config.terminal_config.verbose
    if verbose:
        print("Project name: " + game_dir)

    parent_and_game_dir = parent_dir + "/" + game_dir
    if verbose:
        print("Remove the project '"+game_dir+ \
              "' with all its files (source, graphics assets, makefile)")
    if (not interactive) or (are_you_sure()=="y"):
        if os.path.exists(parent_and_game_dir):
            if verbose:
                print("Deleting directory " + parent_and_game_dir)
            shutil.rmtree(parent_and_game_dir)

        makefile_name = "Makefile."+game_dir
        if os.path.exists(makefile_name):
            if verbose:
                print("Deleting..." + makefile_name)
            os.remove(makefile_name)
        if verbose:
            print("'" + game_dir + "' deleted")
    else:
        return


def built_files_in_path(mypath):
    files = []
    for (_, _, filenames) in walk(mypath):
        built_files = []
        for filename in filenames:
            if not filename.startswith('.'):
                built_files.append(filename)

        files.extend(built_files)
        break
    return files


def list_of_projects(project_category):
    # print("category: " + project_category)
    if project_category in ["examples", "projects", "games"]:
        res = dirs_in_path("./"+project_category)
    else:
        res = dirs_in_path("./examples")+dirs_in_path("./games")+dirs_in_path("./projects")
    # print(res)
    return res


def test_projects(option_config, projects, target="stdio"):

    compilation_threads = option_config.build_config.compilation_threads
    verbose = option_config.terminal_config.verbose
    clean_test(option_config)

    if projects in ["examples", "projects", "games"]:
        number_of_projects = len(dirs_in_path("./"+projects))
    elif projects == "all":
        number_of_projects = \
        len(dirs_in_path("./examples")) + \
        len(dirs_in_path("./games")) + \
        len(dirs_in_path("./projects"))
    else:
        number_of_projects = 1
    if verbose:
        print("number of projects: " + str(number_of_projects))
    #multiple_build
    build(option_config, ["build",projects,target,compilation_threads,""])
    built_files = built_files_in_path("../build")

    # TODO: Handle target=*_targets and all
    if target.endswith("_targets") or target=="all":
        if verbose:
            print("Test on the number of binaries for all these targets is not supported")

    if target in TARGETS_WITH_3_BINARIES:
        files_per_project = 3
    elif target in TARGETS_WITH_2_BINARIES:
        files_per_project = 2
    else:
        files_per_project = 1

    if verbose:
        print("Expected binaries per project: " + str(files_per_project))

    if len(built_files)<files_per_project*number_of_projects:
        printc(option_config, bcolors.FAIL, "[xl build]  KO\n")
        print("Built files: " +str(built_files))
        print("Expected number : " + str(number_of_projects))
        print("No. Built files : " + str(len(built_files)))

        # success=0
        return False
    printc(option_config, bcolors.OKGREEN, "[xl build]        OK\n")
    return True


def test_clean_tools(option_config):
    #clean tools
    clean(option_config, ["clean","tools"])

    tools_result_map=test_tools(False)
    number_of_tools = len(tools_result_map.keys())

    built_tools = 0
    for _, result in tools_result_map.items():
        if result:
            built_tools+=1
    if built_tools==0:
        printc(option_config, bcolors.OKGREEN, "[xl clean tools]    OK\n")
    else:
        printc(option_config, bcolors.FAIL, "[xl clean tools]    KO\n")
    return number_of_tools, built_tools


def test_self(option_config, target = "stdio"):

    option_config.terminal_config.test = 1
    printc(option_config, bcolors.OKCYAN,"----------------------------------------\n")
    printc(option_config, bcolors.OKCYAN, "XL SCRIPT TEST")
    printc(option_config, bcolors.OKCYAN,"\n----------------------------------------\n")
    success = 1
    printc(option_config, bcolors.BOLD,  "target: ")
    printc(option_config, bcolors.OKBLUE,target+"\n")
    printc(option_config, bcolors.OKCYAN,"----------------------------------------\n")

    
    #delete
    delete(option_config, ["delete","_cloned_test_project","-y"])
    printc(option_config, bcolors.OKGREEN, "[xl delete]         OK\n")


    #clean tools
    number_of_tools, built_tools = test_clean_tools(option_config)
    if built_tools>0:
        success = 0

    #tools
    tools(option_config)

    tools_result_map=test_tools(False)
    built_tools = 0
    for _, result in tools_result_map.items():
        if result:
            built_tools+=1
    if built_tools==number_of_tools:
        printc(option_config, bcolors.OKGREEN, "[xl tools]          OK\n")
    else:
        printc(option_config, bcolors.FAIL, "[xl tools]         KO\n")
        print("built_tools: " + str(built_tools))
        print("number_of_tools: " + str(number_of_tools))
        success = 0

    #clean tools
    number_of_tools, built_tools = test_clean_tools(option_config)
    if built_tools > 0:
        success = 0

    #delete
    delete(option_config, ["delete","_test_project","-y"])
    printc(option_config, bcolors.OKGREEN, "[xl delete]         OK\n")


    #clean
    success = success * clean_test(option_config)

    projects_before_create = list_projects(option_config, ["list"],False)

    project_dirs_before_create = len(dirs_in_path("./projects"))
    initial_dirs = project_dirs_before_create

    # create
    create(option_config, ["create", "_test_project", "test"])
    project_dirs_after_create = len(dirs_in_path("./projects"))

    if project_dirs_after_create!=project_dirs_before_create+1:
        printc(option_config, bcolors.FAIL, "[xl create]         KO\n")
        return 0
    printc(option_config, bcolors.OKGREEN, "[xl create]         OK\n")

    # list
    projects_after_create = list_projects(option_config, ["list"],False)
    if projects_after_create!=projects_before_create+1:
        printc(option_config, bcolors.FAIL,"[xl list]           KO\n")
        success = 0
    printc(option_config, bcolors.OKGREEN,"[xl list]           OK\n")

    # create
    create(option_config, ["create", "_test_project2", "game"])
    printc(option_config, bcolors.OKGREEN, "[xl create]         OK\n")

    # create
    create(option_config, ["create", "_test_project3", "demo"])
    printc(option_config, bcolors.OKGREEN, "[xl create]         OK\n")

    # create
    create(option_config, ["create", "_test_project4", "text"])
    printc(option_config, bcolors.OKGREEN, "[xl create]         OK\n")

    # create
    create(option_config, ["create", "_test_project5", "helloworld"])
    printc(option_config, bcolors.OKGREEN, "[xl create]         OK\n")

    #build
    build(option_config, ["build", "_test_project2", target])
    built_files = built_files_in_path("../build")
    printc(option_config, bcolors.OKGREEN,"[xl build]          OK\n")

    #build
    build(option_config, ["build", "_test_project3", target])
    built_files = built_files_in_path("../build")
    printc(option_config, bcolors.OKGREEN,"[xl build]          OK\n")

    #build
    build(option_config, ["build", "_test_project4", target])
    built_files = built_files_in_path("../build")
    printc(option_config, bcolors.OKGREEN,"[xl build]          OK\n")

    #build
    build(option_config, ["build", "_test_project5", target])
    built_files = built_files_in_path("../build")
    printc(option_config, bcolors.OKGREEN,"[xl build]          OK\n")

    #clean
    success = success * clean_test(option_config)
    if success:
        printc(option_config, bcolors.OKGREEN,"[xl clean]          OK\n")

    #delete
    delete(option_config, ["delete","_test_project2","-y"])
    printc(option_config, bcolors.OKGREEN, "[xl delete]         OK\n")

    #delete
    delete(option_config, ["delete","_test_project3","-y"])
    printc(option_config, bcolors.OKGREEN, "[xl delete]         OK\n")

    #delete
    delete(option_config, ["delete","_test_project4","-y"])
    printc(option_config, bcolors.OKGREEN, "[xl delete]         OK\n")

    #delete
    delete(option_config, ["delete","_test_project5","-y"])
    printc(option_config, bcolors.OKGREEN, "[xl delete]         OK\n")

    #delete
    delete(option_config, ["delete","_foo_test","-y"])

    #rename
    rename(option_config, ["","_test_project", "_foo_test"])
    printc(option_config, bcolors.OKGREEN,"[xl rename]         OK\n")

    #rename
    rename(option_config, ["","_foo_test", "_test_project"])
    printc(option_config, bcolors.OKGREEN,"[xl rename]         OK\n")

    #build
    build(option_config, ["build", "_test_project", target])
    built_files = built_files_in_path("../build")

    if len(built_files)==0:
        print("built binaries: " + str(built_files))

        printc(option_config, bcolors.FAIL, "[xl build]          KO\n")
        success=0
    else:
        printc(option_config, bcolors.OKGREEN, "[xl build]          OK\n")

    dirs_in_proj_before = len(dirs_in_path("./projects/_test_project"))
    if dirs_in_proj_before != 4:
        printc(option_config, bcolors.FAIL, "[xl build]          KO\n")
        success=0

    dirs_in_shapes_before = len(dirs_in_path("./projects/_test_project/shapes"))
    if dirs_in_shapes_before != 1:
        printc(option_config, bcolors.FAIL, "[xl build]          KO\n")
        print(dirs_in_shapes_before)
        print(str(dirs_in_path("./projects/_test_project/shapes")))
        success=0

    extend(option_config, ["extend", "_test_project"])

    dirs_in_proj_after = len(dirs_in_path("./projects/_test_project"))

    if dirs_in_proj_after != 4:
        printc(option_config, bcolors.FAIL, "[xl extend]         KO\n")
        success=0

    dirs_in_shapes_after = len(dirs_in_path("./projects/_test_project/shapes"))

    if dirs_in_shapes_after != 5:
        printc(option_config, bcolors.FAIL, "[xl extend]         KO\n")
        print("no. dirs_in_shapes_after: " + str(dirs_in_shapes_after))
        print("dirs_in_shapes_after: " + str(dirs_in_path("./projects/_test_project/shapes")))
        success=0

    if success:
        printc(option_config, bcolors.OKGREEN, "[xl extend]         OK\n")

    option_config.terminal_config.test = 0

    # run
    printc(option_config, bcolors.OKCYAN , "\nExit the test program to continue\n")
    run(option_config, ["run", "_test_project", target])

    printc(option_config, bcolors.OKGREEN, "[xl run]            OK\n")

    option_config.terminal_config.test = 1

    projects_before_create = list_projects(option_config, ["list"],False)

    project_dirs_before_create = len(dirs_in_path("./projects"))

    # clone
    clone(option_config, ["","_test_project","_cloned_test_project"])
    project_dirs_after_create = len(dirs_in_path("./projects"))

    if project_dirs_after_create!=project_dirs_before_create+1:
        printc(option_config, bcolors.FAIL,
                            "[xl clone]          KO\n")
        return 0
    printc(option_config, bcolors.OKGREEN,
                            "[xl clone]          OK\n")

    #build
    build(option_config, ["build", "_cloned_test_project", target])
    

    option_config.terminal_config.test = 0

    # run
    printc(option_config, bcolors.OKCYAN , "\nExit the test program to continue\n")

    run(option_config, ["run", "_cloned_test_project", target])

    printc(option_config, bcolors.OKGREEN, "[xl run]            OK\n")
    option_config.terminal_config.test = 1

    # delete
    delete(option_config, ["","_cloned_test_project","-y"])
    printc(option_config, bcolors.OKGREEN, "[xl delete]         OK\n")


    #clean
    success = success * clean_test(option_config)

    #shapes
    shapes(option_config, ["","_test_cloned_test_project_project"])
    # make_assets_from_tiles(["_test_cloned_test_project_project"])
    printc(option_config, bcolors.OKGREEN, "[xl shapes]         OK\n")

    #size
    size(option_config, ["size", "_test_project", "stdio_sized", "12", "12"],True)
    built_files = built_files_in_path("../build")

    if len(built_files)!=1:
        printc(option_config, bcolors.FAIL, "[xl size]           KO\n")
        print(str(built_files))
        success=0
    else:
        printc(option_config, bcolors.OKGREEN, "[xl size]           OK\n")

    dirs_in_proj_before = len(dirs_in_path("./projects/_test_project"))
    if dirs_in_proj_before != 4:
        printc(option_config, bcolors.FAIL, "[xl size]           KO\n")
        print(str(dirs_in_path("./projects/_test_project")))
        success=0

    dirs_in_shapes_before = len(dirs_in_path("./projects/_test_project/shapes"))
    if dirs_in_shapes_before != 5:
        printc(option_config, bcolors.FAIL, "[xl size]           KO\n")
        print(str(dirs_in_path("./projects/_test_project/shapes")))
        success=0

    #reset
    reset(option_config, ["","-y"])
    printc(option_config, bcolors.OKGREEN, "[xl reset]          OK\n")

    #size
    size(option_config, ["size", "_test_project", "stdio_sized", "32", "24"],False)
    built_files = built_files_in_path("../build")

    if len(built_files)!=2:
        printc(option_config, bcolors.FAIL, "[xl size]           KO\n")
        print(str(built_files))
        print("Wrong number of built files")
        success=0
    else:
        printc(option_config, bcolors.OKGREEN, "[xl size]           OK\n")

    projects = []
    for (_, dirnames, _) in walk("./projects"):
        projects.extend(dirnames)
        break

    games = []
    for (_, dirnames, _) in walk("./games"):
        games.extend(dirnames)
        break

    examples = []
    for (_, dirnames, _) in walk("./examples"):
        examples.extend(dirnames)
        break

    #reset
    reset(option_config, ["","_test_project"])
    printc(option_config, bcolors.OKGREEN, "[xl reset]          OK\n")

    #delete
    delete(option_config, ["delete","_test_project","-y"])
    project_dirs_after_delete = len(dirs_in_path("./projects"))

    if project_dirs_after_delete != initial_dirs:
        printc(option_config, bcolors.FAIL,    "[xl delete]         KO\n")
        print(project_dirs_before_create)
        print(project_dirs_after_delete)
        success=0
    else:
        printc(option_config, bcolors.OKGREEN, "[xl delete]         OK\n")

    if clean_test(option_config)==0:
        success=0

    # build (all examples)
    build(option_config, ["","examples","stdio"])

    built_files = built_files_in_path("../build")

    if len(built_files)!=len(examples):
        success=0
        printc(option_config, bcolors.FAIL, "[xl build]          KO\n")
        print(built_files)
        print(examples)
    else:
        printc(option_config, bcolors.OKGREEN, "[xl build examples] OK\n")

    if clean_test(option_config)==0:
        success=0

    build(option_config, ["","games","stdio"])

    built_files = built_files_in_path("../build")

    if len(built_files)!=len(games):
        success=0
        printc(option_config, bcolors.FAIL, "[xl build]          KO\n")
        print(built_files)
        print(games)
        sys.exit()
    else:
        printc(option_config, bcolors.OKGREEN, "[xl build games]    OK\n")

    if clean_test(option_config)==0:
        success=0

    printc(option_config, bcolors.OKCYAN,"----------------------------------------\n")

    return success


def test_all(option_config, params):

    test_compilers()
    test_tools()
    test_libraries()
    test_interpreters()
    unit_tests(option_config)
    return test_self(option_config, params)

expected_files = {
    "cc65_extra": 8,
    "z88dk_extra": 5,
    "cmoc_extra": 3,
    "lcc1802_extra": 1,
    "stdio_extra": 1,
    "z88dk_extra_alt": 38
    }


def targets_test(option_config, params):

    verbose = option_config.terminal_config.verbose
    success = clean_test(option_config)
    compilation_threads = option_config.build_config.compilation_threads
    native_compiler = option_config.build_config.native_compiler
    if params[1].startswith("z88dk_extra"):
        parallel = " -j " + compilation_threads
    else:
        parallel = ""

    game_dir = "chase"
    project_type = "game"
    if is_project_split(game_dir):
        printc(option_config, bcolors.OKBLUE,"Create main.c from split source files\n")
        create_main(game_dir, project_type)
    if params[1].endswith("_extra"):
        make_command = GNU_MAKE + parallel + " test_" + params[1] + " " + \
                       " GNU_MAKE=" + GNU_MAKE + " _NATIVE_CC="+ native_compiler + " " + \
                       all_compilers_opts(option_config, "","") + \
                       " -f makefiles.other/chase/tests/Makefile.tests"
        run_command(option_config, make_command)
    elif params[1]=="z88dk_extra_alt":
        # parallel = ""
        make_command = GNU_MAKE + parallel + " GNU_MAKE=" + GNU_MAKE + \
                       " z88dk_quick_test -f makefiles.other/chase/tests/Makefile.z88dk_quick_tests"
        run_command(option_config, make_command)
    else:
        printc(option_config, bcolors.FAIL, "Parameter not recognized\n")
        if is_project_split(game_dir):
            print("Delete main.c (because of split source files)\n")
            delete_main(option_config, game_dir, project_type)
        sys.exit(-1)
    if is_project_split("chase"):
        printc(option_config, bcolors.OKBLUE,"Delete main.c (because of split source files)\n")
        delete_main(option_config, game_dir, project_type)


    built_files = len(files_in_path("../build"))-1
    if verbose:
        print("Number of built files: " + str(built_files))

    if params[1] in expected_files.keys():
        if verbose:
            printc(option_config, bcolors.OKCYAN, "Built files: " + str(built_files)+"\n")
            printc(option_config, bcolors.OKBLUE, "Expected files: " + str(expected_files[params[1]])+"\n")
        if built_files != expected_files[params[1]]:
            printc(option_config, bcolors.FAIL, "binaries KO\n")
            success=0

        else:
            printc(option_config, bcolors.OKGREEN, "binaries OK\n")

    # if clean_test()==0:
        # success=0
    return success


# Self-test xl and native build
def test(option_config, params):
    if (len(params)<=1) or ((len(params)==2) and (params[1]=="check")):
        if test_all(option_config, "stdio"):
            printc(option_config, bcolors.OKGREEN, "TEST OK\n")
        else:
            printc(option_config, bcolors.FAIL, "TEST KO\n")
        return
    if params[1]=="self":
        if len(params)<3:
            test_self(option_config)
        else:
            test_self(option_config, params[2])
    elif params[1]=="compilers":
        test_compilers()
    elif params[1]=="tools":
        test_tools()
    elif params[1]=="emulators":
        test_emulators()
    elif params[1]=="cross-compilers" or params[1]=="cross_compilers":
        test_cross_compilers()
    elif params[1]=="native_compilers" or params[1]=="native-compilers":
        test_native_compilers()
    elif params[1]=="libraries":
        test_libraries()
    elif params[1]=="interpreters":
        test_interpreters()
    elif params[1]=="roms":
        test_roms()
    elif params[1]=="make":
        test_make()
    elif params[1] in ("unit-tests", "unit_tests", "unit-test", "unit_test", "u"):
        unit_tests(option_config, verbose=True)
    elif params[1].endswith('extra') or params[1].endswith('extra_alt'):
        if targets_test(option_config, params):
            printc(option_config, bcolors.OKGREEN, "TEST OK\n")
        else:
            printc(option_config, bcolors.FAIL, "TEST KO\n")
        return
    else:
        projects = []
        for (_, dirnames, _) in walk("./projects"):
            projects.extend(dirnames)
            break

        games = []
        for (_, dirnames, _) in walk("./games"):
            games.extend(dirnames)
            break

        examples = []
        for (_, dirnames, _) in walk("./examples"):
            examples.extend(dirnames)
            break

        # print(projects + games + examples)
        # quit()
        if params[1] in projects + games + examples or params[1] in \
           ['examples','games','projects','all']:
            # print("KO")
            # quit()
            if len(params)>=3:
                par1 = params[1]
                par2 = params[2]
            else:
                par1 = params[1]
                par2 = "stdio"
            if test_projects(option_config, par1,par2):
                printc(option_config, bcolors.OKGREEN, "TEST OK\n")
            else:
                printc(option_config, bcolors.FAIL, "TEST KO\n")
        else:
            # print("OK")
            # quit()
            test_all(option_config, params[1])
        return


# Self-test xl and native build
def check(params):
    if len(params)<=1:
        tools = test_tools()
        # interpreters = test_interpreters()
        native_compilers =test_native_compilers()
        cross_compilers = test_cross_compilers()
        libraries = test_libraries()
        make = test_make()
        emulators = test_emulators()
        roms = test_roms()

        print("")

        printc(option_config, bcolors.BOLD, "SUMMARY\n")
        tools = True
        xl_run_cross_target = True
        native_target = True
        cross_target = True


        if not make['make'] and not make['gmake']:
            printc(option_config, bcolors.FAIL, "No make command detected!\n")

        if not native_compilers['gcc']:
            tools = False
            native_target = False

        if not native_compilers['g++']:
            xl_run_cross_target = True
            tools = False

        if not libraries['ncurses']:
            printc(option_config, bcolors.WARNING, \
                   "No ncurses library detected -> Native target impacted\n")
            native_target = False

        for _, present in cross_compilers.items():
            if not present:
                cross_target = False

        for _, present in emulators.items():
            if not present:
                xl_run_cross_target = False
                break

        for _, present in roms.items():
            if not present:
                xl_run_cross_target = False
                break

        if not tools:
            printc(option_config, bcolors.WARNING, "'xl tools' may be KO for some targets\n")

        if not native_target:
            printc(option_config, bcolors.WARNING, "'xl build <project>' may be KO (no native build)\n")

        if not cross_target:
            printc(option_config, bcolors.WARNING, "'xl build <project> <target>' may be KO for some targets\n")

        if not xl_run_cross_target:
            printc(option_config, bcolors.WARNING, "'xl run <project> <target>' may be KO for some targets\n")

        if tools and native_target and xl_run_cross_target and cross_target:
            printc(option_config, bcolors.OKCYAN, "No issue found\n")


    elif params[1]=="compilers":
        test_compilers()
    elif params[1]=="tools":
        test_tools()
    elif params[1]=="emulators":
        test_emulators()
    elif params[1]=="cross-compilers" or params[1]=="cross_compilers":
        test_cross_compilers()
    elif params[1]=="native_compilers" or params[1]=="native-compilers":
        test_native_compilers()
    elif params[1]=="libraries":
        test_libraries()
    elif params[1]=="interpreters":
        test_interpreters()
    elif params[1]=="make":
        test_make()
    elif params[1]=="roms":
        test_roms()





# List all projects
def list_projects(option_config, params, print_projects=True):

    if len(params)<2:
        project_dirs = ["examples", "games", "projects"]
    elif params[1]=="all":
        project_dirs = ["examples", "games", "projects"]
    elif params[1] in ["games", "examples", "projects"]:
        project_dirs = [params[1]]
    elif params[1] in ["new"]:
        project_dirs = ["projects"]
    elif params[1] in ["built-in", "builtin"]:
        project_dirs = ["games", "examples"]
    else:
        return

    count = 0

    for mypath in project_dirs:
        if print_projects:
            printc(option_config, bcolors.BOLD, "["+mypath+"]\n")
        for (_, dirnames, _) in walk(mypath):
            # projects.extend(dirnames)
            for project in dirnames:
                if print_projects:
                    print("  "+str(project))
                count+=1
            break
        if print_projects:
            print("")

    if option_config.terminal_config.verbose:
        print("Projects found: " + str(count))
        print("")

    return count


def run_native(option_config, params, target):

    command_prefix = "../build/X" + params[1] + "_" + target

    if len(params)>=4:
        xsize = params[2]
        ysize = params[3]
        command_string = command_prefix + "_" + xsize + "X" + ysize + "." + NATIVE_EXTENSION
    else:
        command_string = command_prefix + "." + NATIVE_EXTENSION
    run_command(option_config, command_string)


def run_stdio(option_config, params):
    command_prefix = "../build/X" + params[1] + "_stdio"

    if len(params)>=4:
        xsize = params[3]
        ysize = params[4]
        command_string = command_prefix + "_" + xsize + "X" + ysize + "." + NATIVE_EXTENSION
    else:
        command_string = command_prefix + "." + NATIVE_EXTENSION
    run_command(option_config, command_string)


DEFAULT_TARGET_MAP = {\
                     "vic20":"vic20_exp_16k", \
                     "c16":"c16_16k", \
                     "plus4":"c16_32k", \
                     "pet":"pet_16k", \
                     "msx": "msx_16k" \
                     }

VICE_TARGETS = ["c64",
                "vic20", 
                "vic20_unexpanded", 
                "vic20_exp_3k", 
                "vic20_exp_8k", 
                "vic20_exp_16k",
                "c16", 
                "plus4", 
                "c16_16k", 
                "c16_32k",
                "pet", 
                "pet_8k", 
                "pet_16k"
               ]

MAME_TARGETS = ["msx", "msx_16k"]


# Run a project by using an emulator if necessary. Only few emulators are supported.
def run(option_config, params):

    if len(params)==2:
        run_native(option_config, params, "ncurses")

    if len(params)>=3:
        params = insert_default_sizes(params)

        target = params[2]
        if target in DEFAULT_TARGET_MAP:
            target = DEFAULT_TARGET_MAP[target]
            if option_config.terminal_config.verbose:
                print("defaulting to target: " + target)

        if target=="stdio":
            run_stdio(option_config, params)
        elif target=="ncurses":
            run_native(option_config, params[0:2]+params[3:], "ncurses")
        elif target=="terminal":
            run_native(option_config, params[0:2]+params[3:], "terminal8x8")
        elif target.startswith("terminal"):
            run_native(option_config, params[0:2]+params[3:], target)

        # e.g. xl run bomber 20 30
        elif(len(params)>=3 and params[2].isnumeric() and params[3].isnumeric()):
            run_native(option_config, params, "ncurses")

        # TODO: replace this with a check on prefixes
        elif target in VICE_TARGETS:
            
            extension = "prg"
            rom_directory = option_config.rom_config.vice_rom_path
            if target=="c64":
                rom_directory += "c64"

                emulator = C64_EMULATOR
            elif target.startswith("vic20"):
                rom_directory += "vic20"

                if target=="vic20_exp_3k":
                    emulator = VIC20_EMULATOR + " -memory 3k"
                elif target=="vic20_unexpanded":
                    emulator = VIC20_EMULATOR + " -memory none"
                else:
                    emulator = VIC20_EMULATOR + " -memory 24k"
            elif target.startswith("c16") or target=="plus4":
                rom_directory += "plus4"

                emulator = PLUS4_EMULATOR
            elif target.startswith("pet"):
                rom_directory += "pet"
                emulator = PET_EMULATOR
            else:
                print("'xl run' does not support this target")
                return
            command_string = option_config.rom_config.vice_path + emulator + " -directory " + \
                             rom_directory + " -autostartprgmode 1  ../build/X" + \
                             params[1] + "_" + target + "." + extension

            run_command(option_config, command_string)

        elif target in MAME_TARGETS:
            emulator = MAME_EMULATOR

            if target.startswith("msx"):
                extension = "rom"
                mame_sub_target = "canonv20"
                command_string = option_config.rom_config.mame_path + emulator + " " + mame_sub_target + \
                " -rompath " + option_config.rom_config.mame_rom_path + \
                " -window -uimodekey DEL  -skip_gameinfo  -cart1 ../build/X" + \
                params[1] + "_" + target + "." + extension
                run_command(option_config, command_string)
        else:
            print("'xl run' does not support this target")
            return


# It should be able to import from
# - Assembly files that use byte directives with either decimal and hex notation
# - Assembly files that use word directives with ONLY hex notation
def import_from_source(params, rotate = False):
    filename = params[1]

    rip_option = params[len(params)-1]=="-rip"

    xsize = 8
    ysize = 8

    tiles = rip_tiles(filename, xsize, ysize, rip_option, rotate)

    try:
        if(len(params)>=3) and "-" not in params[2]:
            store_tiles(params[2],tiles, xsize, ysize)
    except Exception as exception:
        print("Sorry! Failed to store tiles: \n" + str(exception.args))


# It should be able to import from
# - Assembly files that use byte directives with either decimal and hex notation
# - Assembly files that use word directives with ONLY hex notation
# - BASIC files that use decimal, hex notation or "headless" hex notation (by guessing)
# Remark: This function is like "import_from_source" with the "-rip" option
def rip(params, rotate = False):
    filename = params[1]

    xsize = 8
    ysize = 8

    tiles = rip_tiles(filename, xsize, ysize, True, rotate)

    try:
        if(len(params)>=3) and "-" not in params[2]:
            store_tiles(params[2],tiles, xsize, ysize)
    except Exception as exception:
        print("Sorry! Failed to store tiles: \n" + str(exception.args))

# Show all generated files
def files():
    make_command = "ls -ls ../build"
    os.system(make_command)


def split(params):

    import_split_tiles(params[1])



# Import a shape as single tile from a text file that describes its shape with characters
def tile(params):

    tile,xsize,ysize = import_tile(params[1])



    if verbose:
        print_shape(option_config, compute_shape(tile,xsize))

    if len(params)>=3:
        store_tile(params[2], tile, xsize, ysize, params[3])
    else:
        printc(option_config, bcolors.OKCYAN, tile+"\n")

# replace_shapes:
# 0 -> write in _shapes directory,
# 1 -> write in shapes directory but avoid overwriting existing shapes or tiles
def write_shapes(option_config, project, shapes, xsize,ysize):
    verbose = option_config.terminal_config.verbose
    replace_shapes = option_config.extend_config.replace_shapes
    path = path_to_shapes(project,xsize,ysize)
    if not replace_shapes:
        path = path.replace("shapes","_shapes")
    if verbose:
        print("Writing shapes in: " + path)
    if os.path.exists(path):
        if verbose:
            print("Directory exists")
    else:
        if verbose:
            print("Directory does not exist")
        os.makedirs(path)
    for tile_number, shape in shapes.items():
        #print(tile_number,shape)
        path_to_shape = path+"shape"+tile_number+".txt"
        if verbose:
            print("Path to shape file: " + path_to_shape)
        path_to_tile = path.replace("shapes","tiles")+"tile"+tile_number+".txt"
        if verbose:
            print("Path to tile file: " + path_to_tile)
        if replace_shapes and (os.path.exists(path_to_shape) or \
           os.path.exists(path_to_tile)):
            if os.path.exists(path_to_shape):
                if verbose:
                    print("shape "+ tile_number +" already exists")
            elif os.path.exists(path_to_tile):
                if verbose:
                    print("tile "+ tile_number +" already exists")
        else:
            with open(path_to_shape,"w") as file:
                for row in shape:
                    if verbose:
                        print(row)
                    file.write(row+"\n")
        if verbose:
            print("")


# Extand 8x8 shapes by reshaping them into shapes with other dimensions
def extend(option_config, params):
    verbose = option_config.terminal_config.verbose
    extend_algorithm = option_config.extend_config.extend_algorithm
    project = params[1]

    path_to_8x8_files = path_to_shapes(project,8,8)
    if verbose:
        print("Path to shape files: " + path_to_8x8_files)
        print("")
    shape_files = files_in_path(path_to_8x8_files)

    dict7x8 = {}
    dict6x8 = {}
    dict8x6 = {}
    dict6x9 = {}
    for shape_file in shape_files:
        path_to_shape_file = path_to_8x8_files + "/" + shape_file

        if verbose:
            print("shape file: " + shape_file)

        tile_number_str = shape_file[5:].replace(".txt","")

        if verbose:
            print("---tile number: " + tile_number_str)

            print("")

        tile,xsize,ysize = read_shape(path_to_shape_file)
        if xsize!=8 or ysize!=8:
            print("Shape in file " + path_to_shape_file + " has wrong dimensions!")
            print(tile)
            return

        if verbose:
            print(tile)

        if verbose:
            print("")
            print("7x8")
        shape7x8 = convert(tile,7,8,extend_algorithm)
        if verbose:
            display_shape(option_config, shape7x8)
        dict7x8[tile_number_str]=shape7x8

        if verbose:
            print("")
            print("6x8")
        shape6x8 = convert(tile,6,8,extend_algorithm)
        if verbose:
            display_shape(option_config, shape6x8)
        dict6x8[tile_number_str]=shape6x8

        if verbose:
            print("")
            print("8x6")
        shape8x6 = convert(tile,8,6,extend_algorithm)
        if verbose:
            display_shape(option_config, shape8x6)
        dict8x6[tile_number_str]=shape8x6

        if verbose:
            print("")
            print("6x9")
        shape6x9 = convert(tile,6,9,extend_algorithm)
        if verbose:
            display_shape(option_config, shape6x9)
        dict6x9[tile_number_str]=shape6x9
        if verbose:
            print("")
    # print(str(dict7x8))
    write_shapes(option_config, project,dict7x8,7,8)
    write_shapes(option_config, project,dict6x8,6,8)
    write_shapes(option_config, project,dict8x6,8,6)
    write_shapes(option_config, project,dict6x9,6,9)
    return


# Import as tiles all shapes from files named "shape<number>.txt" inside the directories in the "shapes" directory of a given project
def shapes(option_config, params):
    verbose = option_config.terminal_config.verbose
    project_name = params[1]

    project_cat = project_category(project_name)

    if len(params)>3:   # xsize, ysize parameters
        xsize_str,ysize_str = params[2:]
    elif len(params)==3: # target parameter
        detected_xsize = detect_xsize(params[2])
        detected_ysize = detect_ysize(params[2])
        xsize_str = str(detected_xsize)
        ysize_str = str(detected_ysize)
        # if verbose:
            # print("Detected xsize: " + xsize_str)
            # print("Detected ysize: " + ysize_str)
    else:                # no parameter
        xsize_str = "8"
        ysize_str = "8"
    if verbose:
        print("xsize: " + xsize_str)
        print("ysize: " + ysize_str)
    path_to_files = project_cat + "s/" + params[1] + \
                    "/shapes/" + xsize_str + "x" + ysize_str + "/"
    if verbose:
        print("Path to shape files: " + path_to_files)
    shape_files = files_in_path(path_to_files)
    if verbose:
        print("shape files: ", shape_files)
    for shape_file in shape_files:
        if verbose:
            print("processing file: ", shape_file)

        path_to_shape_file = path_to_files + str(shape_file)
        if verbose:
            print("processing path file: ", path_to_shape_file)
        tile_number_str = shape_file[5:].replace(".txt","")

        print("tile number: " + tile_number_str)

        tile,xsize,ysize = import_tile(path_to_shape_file)

        if str(xsize)!=xsize_str or str(ysize)!=ysize_str:
            print("Shape in file " + path_to_shape_file + " has wrong dimensions!")
            print(tile)
            return
        print(tile)
        if verbose:
            print_shape(option_config, compute_shape(tile,xsize))

        store_tile(project_name, tile, xsize, ysize, tile_number_str)

        print("")


# Show tile shapes of a given project
def show(option_config, params):
    parent_dir = project_category(params[1])+"s"

    if len(params)<4:
        xsize = "8"
        ysize = "8"
    else:
        xsize = params[2]
        ysize = params[3]

    if len(params)>=5:
        index = params[4]
    else:
        index = ""

    if index!="":
        print_shape_from_file(option_config, parent_dir, params[1], xsize, ysize, index)

    else:
        for i in range(NUMBER_OF_TILES):
            print_shape_from_file(option_config, parent_dir, params[1], xsize, ysize, i)

# ---------------------------------------------


# ---------------------------------------------
#  System               Value
# ---------------------------------------------
#  Linux                linux or linux2 (*)
#  Windows              win32
#  Windows/Cygwin       cygwin
#  Windows/MSYS2        msys
#  Mac OS X             darwin
#  OS/2                 os2
#  OS/2 EMX             os2emx
#  RiscOS               riscos
#  AtheOS               atheos
#  FreeBSD 7            freebsd7
#  FreeBSD 8            freebsd8
#  FreeBSD N            freebsdN
#  OpenBSD 6            openbsd6
# ---------------------------------------------

def read_config_option(config, section, option):
    if config.has_option(section,option):
        return config.get(section,option)
    return ""

def read_config(config_file="./config.ini"):
    try:
        import configparser
    except ImportError:
        # Python 2.x fallback
        print("Python 2.x configuration")
        import ConfigParser as configparser

    config = configparser.ConfigParser()

    try:
        config.read(config_file)

        # test = read_config_option(config,"terminal","test")
        # if test!="":
            # test=int(test)
        # else:
            # test=0
        # if test:
            # print("Test Mode ON")

        verbose = read_config_option(config,"terminal","verbose")
        if verbose!="":
            verbose=int(verbose)
        else:
            verbose=0
        if verbose:
            print("----------------------------")
            print("Verbose Mode ON")

        # print("Extracting color_terminal")
        color_terminal = read_config_option(config,"terminal","color")
        # print("DONE Extracting color_terminal")

        logger.info("Color terminal: %s", str(color_terminal))

        terminal_config = TerminalConfig(verbose=verbose, color_terminal=color_terminal, test=0)


        if verbose:
            print("Config file found with: " + str(config.sections()))
            # print("")

        compilation_threads = read_config_option(config,"build","threads")


        if compilation_threads in ("auto", "automaic"):
            if verbose:
                print("----------------------------")
            import multiprocessing
            compilation_threads = str(multiprocessing.cpu_count())
            if verbose:
                print("Detected " + compilation_threads + " threads...")
                print("----------------------------")

        logger.info("Compilation threads: %s", str(compilation_threads))

        parallelize_multi_build = read_config_option(config,"build","parallelize_multi_build")

        if parallelize_multi_build!="":
            parallelize_multi_build=int(parallelize_multi_build)
        else:
            parallelize_multi_build=0

        z88dk_compiler_opts = read_config_option(config,"build","z88dk_compiler_opts")
        z88dk_compiler = read_config_option(config,"build","z88dk_compiler")
        sccz80_compiler_opts = read_config_option(config,"build","sccz80_compiler_opts")
        zsdcc_compiler_opts = read_config_option(config,"build","zsdcc_compiler_opts")
        cmoc_compiler_opts = read_config_option(config,"build","cmoc_compiler_opts")
        cc65_compiler_opts = read_config_option(config,"build","cc65_compiler_opts")
        lcc1802_compiler_opts = read_config_option(config,"build","lcc1802_compiler_opts")
        gcc4ti99_compiler_opts = read_config_option(config,"build","gcc4ti99_compiler_opts")
        vbcc_compiler_opts = read_config_option(config,"build","vbcc_compiler_opts")
        native_compiler_opts = read_config_option(config,"build","native_compiler_opts")

        native_compiler = read_config_option(config,"build", "native_compiler")

        tool_compiler = read_config_option(config,"tools", "tool_compiler")

        interactive_clean = read_config_option(config,"clean", "interactive")

        vice_path = read_config_option(config,"run", "vice_path")
        vice_rom_path = read_config_option(config,"run", "vice_rom_path")

        mame_path = read_config_option(config,"run", "mame_path")
        mame_rom_path = read_config_option(config,"run", "mame_rom_path")


        rom_config = RomConfig(vice_path=vice_path, vice_rom_path=vice_rom_path, mame_path=mame_path, mame_rom_path=mame_rom_path)
        
        extend_algorithm = read_config_option(config,"extend", "extend_algorithm")
        replace_shapes = read_config_option(config,"extend", "replace_shapes")
        

        use_tools = read_config_option(config,"build", "use_tools")

        if interactive_clean!="":
            interactive_clean = int(interactive_clean)
        logger.info("Interactive clean: %s", str(interactive_clean))

        clean_config = CleanConfig(interactive_clean)

        if replace_shapes!="":
            replace_shapes = int(replace_shapes)

        extend_config = ExtendConfig(extend_algorithm=extend_algorithm, replace_shapes=replace_shapes)


        if use_tools!="":
            use_tools = int(use_tools)

        build_config = BuildConfig( \
            compilation_threads,
            parallelize_multi_build,
            z88dk_compiler,
            z88dk_compiler_opts,
            sccz80_compiler_opts,
            zsdcc_compiler_opts,
            cmoc_compiler_opts,
            cc65_compiler_opts,
            lcc1802_compiler_opts,
            gcc4ti99_compiler_opts,
            vbcc_compiler_opts,
            native_compiler_opts,
            native_compiler,
            tool_compiler,
            use_tools
            )

        option_config = OptionConfig(terminal_config, build_config, clean_config, rom_config, extend_config)

        if verbose:
            if color_terminal:
                print("Color terminal ON\n")
                # printc(option_config, bcolors.OKCYAN, "Color terminal ON\n")
            else:
                print("Color terminal OFF")

        return option_config
    except Exception as e:
        print("An exception occurred while reading the configuration: " + str(e))
        logger.debug("Error while reading configuration file")
        exc_type, exc_obj, exc_tb = sys.exc_info()
        fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
        print(f"exc_type: {exc_type}, fname: {fname}, exc_tb.tb_lineno: {exc_tb.tb_lineno}")


def default_config():

    verbose = True
    compilation_threads = 1
    parallelize_multi_build = 0
    zsdcc_compiler_opts = ""
    sccz80_compiler_opts = ""
    z88dk_compiler_opts = ""
    z88dk_compiler = "sccz80"
    cmoc_compiler_opts = ""
    native_compiler_opts = ""
    native_compiler = "gcc"
    tool_compiler = "gcc"
    cc65_compiler_opts = "-O -Cl"
    lcc1802_compiler_opts = '"-Wf-volatile" -O "-Wp-D nofloats" "-Wa-D LCCNOLONG" "-Wf-mulcall"'
    gcc4ti99_compiler_opts = "-O2"
    vbcc_compiler_opts = "-O1"
    use_tools = 0
    color_terminal = 0


def display_config(option_config):

    printc(option_config, bcolors.BOLD,"[terminal]\n")

    verbose = option_config.terminal_config.verbose
    color_terminal = option_config.terminal_config.color_terminal
    
    print("verbose: " + str(verbose))

    print("color: " + str(color_terminal))

    print("")


    compilation_threads, \
    parallelize_multi_build, \
    z88dk_compiler, \
    z88dk_compiler_opts, \
    sccz80_compiler_opts, \
    zsdcc_compiler_opts, \
    cmoc_compiler_opts, \
    cc65_compiler_opts, \
    lcc1802_compiler_opts, \
    gcc4ti99_compiler_opts, \
    vbcc_compiler_opts, \
    native_compiler_opts, \
    native_compiler, \
    tool_compiler, \
    use_tools \
    = option_config.build_config.get_opts()

    printc(option_config, bcolors.BOLD,"[build]\n")
    print("compilation_threads: " + str(compilation_threads))
    print("parallelize_multi_build: " + str(parallelize_multi_build))

    print("z88dk_compiler: " + z88dk_compiler)
    print("z88dk_compiler_opts: " +  z88dk_compiler_opts)
    print("sccz80_compiler_opts: " + sccz80_compiler_opts)
    print("zsdcc_compiler_opts: " +  zsdcc_compiler_opts)
    print("cmoc_compiler_opts: " +  cmoc_compiler_opts)
    print("cc65_compiler_opts: " +  cc65_compiler_opts)
    print("lcc1802_compiler_opts: " +  lcc1802_compiler_opts)
    print("gcc4ti99_compiler_opts: " +  gcc4ti99_compiler_opts)
    print("vbcc_compiler_opts: " +  vbcc_compiler_opts)
    print("native_compiler_opts: " +  native_compiler_opts)

    print("native_compiler: " +  native_compiler)
    print("use_tools: " + str(use_tools))


    print("")
    printc(option_config, bcolors.BOLD,"[tools]\n")
    print("tool_compiler: " +  tool_compiler)

    print("")

    printc(option_config, bcolors.BOLD,"[clean]\n")
    print("interactive_clean: " + str(option_config.clean_config.interactive_clean))


    print("")
    printc(option_config, bcolors.BOLD,"[run]\n")
    print("vice_path: " +  option_config.rom_config.vice_path)
    print("vice_rom_path: " +  option_config.rom_config.vice_rom_path)
    print("mame_path: " +  option_config.rom_config.mame_path)
    print("mame_rom_path: " +  option_config.rom_config.mame_rom_path)

    print("")
    printc(option_config, bcolors.BOLD,"[extend]\n")
    print("extend_algorithm: " +  option_config.extend_config.extend_algorithm)
    print("replace_shapes: " +  str(option_config.extend_config.replace_shapes))



def make_assets_from_tiles(params):

    game_dir = params[1]

    project_type = project_category(game_dir)
    parent_dir = project_type + "s"

    run_command(option_config, GNU_MAKE+" GAME_NAME=" + game_dir + \
                          " PARENT_DIR=" + parent_dir + \
                          " -f ./makefiles.common/auxiliary/Makefile_assets")


# ---------------------------------------------


if __name__ == "__main__":

    make_test = test_make(False)

    if make_test['gmake']:
        GNU_MAKE = "gmake"
    else:
        GNU_MAKE = "make"

    if python_version<2 or (python_version<=2 and python_subversion<7):
        print("Python version not supported")
        logger.error("Python version not supported")
        sys.exit(-1)
    try:
        # print("Reading config")
        logger.info("(read_config) Read configuration file")
        option_config = read_config()
        # terminal_config, rom_config, extend_config, build_config, clean_config = read_config()
        logger.info("(read_config) Configuration file read")
    except:
        logger.warning("Reverting to default configuration")
        option_config = default_config()
        # terminal_config, rom_config, extend_config, build_config, clean_config  = default_config()
        print("WARNING: Using default config")

    # parallelize_multi_build = option_config.build_config.parallelize_multi_build
    if option_config.build_config.parallelize_multi_build:
        # print("Parallelize_multi_build is ON")
        logger.info("Parallelize_multi_build is ON")
        from multiprocessing import Pool
    else:
        logger.info("Parallelize_multi_build is OFF")

    # verbose = option_config.terminal_config.verbose
    
    # print(verbose)
    
    
    # color_terminal = option_config.terminal_config.color_terminal
    if option_config.terminal_config.verbose:
        logger.info("Verbose mode ON")
        print("----------------------------")
        # printc(option_config, bcolors.OKGREEN, "Cross-Lib `xl` helper script\n")
        print("----------------------------")
        print("Platform: " + platform)
        print("Python:   " + str(python_version) + "." + str(python_subversion))
        logger.info("Using Python version %s.%s", str(python_version), str(python_subversion))

        print("GNU MAKE command: " + GNU_MAKE)
        print("----------------------------")
        print("")


    if len(sys.argv)<2:
        logger.info("Interactive mode ON")
        print("For more commands, use the non-interactive mode.")
        printc(option_config, bcolors.BOLD, "xl help")
        print(" for instructions.")

        print("")
        print("--------------------------------------------------")
        printc(option_config, bcolors.OKCYAN, "Interactive mode\n")
        print("--------------------------------------------------")
        print("")

        project_name = generic_input("Insert project to build\n")

        if project_name in ("", "\n"):
            project_name="helloworld"
            printc(option_config, bcolors.WARNING,"Defaulting to helloworld\n")

        print("")

        target_name = generic_input("Insert target name\n")
        if target_name in ("", "\n"):
            target_name="ncurses"
            printc(option_config, bcolors.WARNING, "Defaulting to ncurses\n")

        print("")
        time.sleep(1)

        params = ["rebuild", project_name, target_name]
    else:
        logger.info("Interactive mode OFF")
        params = sys.argv
        params = handle_two_letter_params(params)

        params = full_params(params)

    command_name = "build" if params[1] in list_of_projects("all") + \
                   ["examples"] + ["games"] + ["projects"] + ["all"] else params[1]
                   
    logger.info("Command : %s", command_name)
    if params[1]=="run":
        run(option_config, params[1:])
    elif params[1]=="check":
        check(option_config, params[1:])
    elif params[1]=="compilers":
        test(option_config, ["test","compilers"])
    elif params[1]=="unit-tests":
        test(option_config, ["test","unit-tests"])
    elif params[1]=="self":
        if len(params)<3:
            test_self(option_config, )
        else:
            test_self(option_config, params[2])
    elif params[1]=="assets":
        shapes(option_config, params[1:])
        make_assets_from_tiles(option_config, params[1:])
    elif params[1]=="split":
        split(params[1:])
    elif params[1]=="config":
        display_config(option_config)
    elif params[1]=="string":
        string(option_config, params[1:])
    elif params[1]=="commands":
        commands(option_config)
    elif params[1]=="import":
        import_from_source(option_config, params[1:],False)
    elif params[1]=="rotate":
        rip(option_config, params[1:],True)
    elif params[1]=="rip":
        rip(option_config, params[1:],False)
    elif params[1]=="rebuild":
        rebuild(option_config, params[1:])
    elif params[1]=="make":
        shapes(option_config, params[1:])
        rebuild(option_config, params[1:])
    elif params[1]=="rename":
        rename(option_config, params[1:])
    elif params[1]=="clone":
        clone(option_config, params[1:])
    elif params[1]=="show":
        show(option_config, params[1:])
    elif params[1]=="test":
        test(option_config, params[1:])
    elif params[1]=="tile":
        tile(option_config, params[1:])
    elif params[1]=="shapes":
        shapes(option_config, params[1:])
    elif params[1]=="extend":
        extend(option_config, params[1:])
    elif params[1]=="build":
        build(option_config, params[1:])
    elif params[1]=="manual":
        manual(option_config, params[1:])
    elif params[1]=="files":
        files()
    elif params[1]=="size":
        size(option_config, params[1:],0)
    elif params[1]=="debug":
        size(option_config, params[1:],1)
    elif params[1]=="create":
        create(option_config, params[1:])
    elif params[1]=="clean":
        interactive_clean = option_config.clean_config.interactive_clean

        if interactive_clean:
            clean(option_config, params[1:])
        else:
            clean(option_config, params[1:]+["-y"])
    elif params[1]=="reset":
        reset(option_config, params[1:])
    elif params[1]=="delete":
        delete(option_config, params[1:])
    elif params[1]=="list":
        list_projects(option_config, params[1:])
    elif params[1]=="help":
        help_command(option_config, params[1:])
    elif params[1]=="tools":
        tools(option_config, )
    elif params[1]=="slow":
        slow(option_config, params[1:])
    elif params[1] in list_of_projects("all") + \
                      ["examples"] + ["games"] + ["projects"] + ["all"]:
        build(option_config, params)
    else:
        manual(option_config, params)

    logger.info('Finished')

    os.system('mv ../logs/log.log ../logs/log_' + \
              datetime.datetime.now().strftime("%Y-%m-%d_%H_%M_%S")+'.log 2>/dev/null' )
