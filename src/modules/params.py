
DEBUG_TARGET  = "ncurses_debug"
NATIVE_TARGET = "ncurses"

from collections import OrderedDict
from import_from_source import printc, bcolors

COMMANDS_DESCRIPTIONS = OrderedDict( \
    {
    # "add": "adds targets to a project", \
    "assets": "builds assets from tile and/or shape files", \
    "build": "builds a project", \
    "check": "it checks dependencies", \
    "clean": "cleans binary files generated by a project", \
    "clone": "clones a project", \
    "commands" :"list all commands",  \
    "compilers": "check present compilers", \
    "config": "displays the configuration", \
    "create": "creates a new project",  \
    "debug": "builds the native version of a project in debug mode", \
    "delete": "completely deletes a project", \
    "extend": "generates non-8x8 shapes from 8x8 shapes", \
    "files": "shows all generated binary files", \
    "help": "provides help on a command or topic", \
    "import": "imports tiles from (Assembly/BASIC) files", \
    "list": "lists all projects", \
    "make": "build project using shape files", \
    "manual": "prints the manual", \
    "rebuild": "generates assets and builds a project", \
    # "remove": "removes targets from a project", \
    "rename": "renames a project", \
    "reset": "deletes graphics assets", \
    "rip": "rips Assembly or BASIC listings to produce tiles", \
    "rotate": "rips Assembly or BASIC listings to produce rotated tiles", \
    "run": "runs a project", \
    "self": "test xl script", \
    "shapes": "generates tiles from shapes", \
    "show": "shows tiles of a project as shapes", \
    "size": "builds the native version of a project with a given size", \
    "slow": "builds a project for a target with a given slowdown", \
    "split": "splits a shape file in left and right shape", \
    "string": "produces case-sensitive strings as Cross-Lib characters macros", \
    "test": "runs some tests", \
    "tile": "converts a shape file into a tile", \
    "tools": "builds the tools", \
    "unit-tests": "run unit-tests",
    })

COMMANDS_LIST = COMMANDS_DESCRIPTIONS.keys()


SHORT_COMMANDS_LIST = OrderedDict( \
    { \
        "c": "clean", \
        "d": "debug", \
        "f": "files", \
        "h": "help", \
        "l": "list", \
        "m": "make", \
        "r": "rebuild", \
        "s": "slow", \
        "t": "test", \
        "u": "unit-tests", \
        "x": "run",
    })


def full_params(params):
    full_command = SHORT_COMMANDS_LIST.get(params[1])
    if full_command is not None:
        return ["", full_command] + params[2:]
    return params


def handle_two_letter_params(params):
    command = params[1]
    if (len(command)==2) and command not in COMMANDS_LIST and command not in SHORT_COMMANDS_LIST:
        first_short_command = params[1][0]
        second_short_command = params[1][1]
        first_command = SHORT_COMMANDS_LIST[first_short_command]
        second_command = SHORT_COMMANDS_LIST[second_short_command]
        new_params = ['', first_command, second_command]
        if len(params)>2:
            new_params.extend(params[2:])
        # print("Interpreting two-letter command as: " + str(new_params))
        return new_params
    return params
    

def get_size_params(params):
    if len(params)<5:
        xsize = params[2]
        ysize = params[3]
        target = NATIVE_TARGET
    else:
        xsize = params[3]
        ysize = params[4]
        target = params[2]

    if target == 'terminal':
        target = 'terminal8x8'

    if target in [NATIVE_TARGET,'stdio'] or target.startswith('terminal'):
        target = target + '_sized'
        
    return target, xsize, ysize


# Show all commands
def commands(option_config):
    # Show full length commands
    for command, description in COMMANDS_DESCRIPTIONS.items():
        printc(option_config, bcolors.BOLD, command)
        spaces = " " * (10-len(command))
        print(spaces + " -> " + description)

    # Show short-hands
    print("")
    for short_command in SHORT_COMMANDS_LIST.items():
        printc(option_config, bcolors.BOLD, short_command[0])
        print(" -> ",end="")
        printc(option_config, bcolors.BOLD, short_command[1]+"\n")