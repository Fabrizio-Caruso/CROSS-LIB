#!/usr/bin/env python

from __future__ import print_function

import datetime
import shutil
import os
import sys
import time

from os import walk

sys.path.append("modules")

from modules.strings import *
from modules.import_from_source import *
from modules.tiles import *
from modules.LoggerSingleton import LoggerSingleton
from modules.init import *
from modules.default_values import insert_default_sizes
from modules.params import \
    handle_two_letter_params, full_params, COMMANDS_LIST, get_size_params
from modules.help_functions import help_command, manual
from modules.file_functions import *

C64_EMULATOR = "x64"
VIC20_EMULATOR = "xvic"
PLUS4_EMULATOR = "xplus4"
PET_EMULATOR = "xpet"

MAME_EMULATOR = "mame"

platform = sys.platform

if(platform in ["cygwin", "msys"]):
    NATIVE_EXTENSION="exe"
else:
    NATIVE_EXTENSION="out"


# compilation_threads = None
# parallelize_multi_build = None
# z88dk_compiler_opts = None
# z88dk_compiler = None
# sccz80_compiler_opts = None
# zsdcc_compiler_opts = None
# cmoc_compiler_opts = None
# cc65_compiler_opts = None
# lcc1802_compiler_opts = None
# gcc4ti99_compiler_opts = None
# vbcc_compiler_opts = None
# native_compiler_opts = None
# native_compiler = None
# tool_compiler = None
# interactive_clean = None
# vice_path = None
# vice_rom_path = None
# mame_path = None
# mame_rom_path = None
# extend_algorithm = None
# replace_shapes = None
# use_tools = None
# config = None


# LoggerSingleton.initLogger(__name__)
logger = LoggerSingleton.initLogger('xl', '../logs')

# console_logger = LoggerSingleton.initConsoleLogger('console')

# console_logger.info('Console logger started')

logger.info('Started')

class TerminalConfig():
    def __init__(
        self,
        verbose,
        test,
        color
        ):
        # terminal
        self.verbose = verbose
        self.test = test
        self.color = color


class RomConfig():
    def __init__(
        self,
        vice_path,
        vice_rom_path,
        mame_path,
        mame_rom_path
        ):
        self.vice_path = vice_path
        self.vice_rom_path = vice_rom_path
        self.mame_path = mame_path
        self.mame_rom_path = mame_rom_path

class ExtendConfig():
    def __init__(
        self,
        extend_algorithm,
        replace_shapes
        ):
        self.extend_algorithm = extend_algorithm
        self.replace_shapes = replace_shapes


class BuildConfig():
    def __init__(
        self,
        z88dk_compiler_opts,
        z88dk_compiler,
        sccz80_compiler_opts,
        zsdcc_compiler_opts,    
        cmoc_compiler_opts,
        cc65_compiler_opts,
        lcc1802_compiler_opts,
        gcc4ti99_compiler_opts,
        vbcc_compiler_opts,
        native_compiler_opts,
        native_compiler,
        use_tools
        ):

        # build
        self.compilation_threads     = compilation_threads
        self.parallelize_multi_build = parallelize_multi_build
        self.z88dk_compiler          = z88dk_compiler
        self.z88dk_compiler_opts     = z88dk_compiler_opts
        self.sccz80_compiler_opts    = sccz80_compiler_opts
        self.zsdcc_compiler_opts     = zsdcc_compiler_opts
        self.cmoc_compiler_opts      = cmoc_compiler_opts
        self.cc65_compiler_opts      = cc65_compiler_opts
        self.lcc1802_compiler_opts   = lcc1802_compiler_opts
        self.gcc4ti99_compiler_opts  = gcc4ti99_compiler_opts
        self.vbcc_compiler_opts      = vbcc_compiler_opts
        self.native_compiler_opts    = native_compiler_opts
        self.native_compiler         = native_compiler
        self.tool_compiler           = tool_compiler
        
        self.use_tools               = use_tools


class CleanConfig:
    def __init__(
        self,
        interactive_clean
    ):
        self.interactive_clean = interactive_clean
        


class Config:
    def __init__(
        self,
        
        terminal_config,
        build_config, 
        clean_config,
        rom_config,
        extend_config,  

    ):
        self.terminal_config = terminal_config
               
        self.build_config = build_config
               
        # clean
        self.clean_config = clean_config

        # rom
        self.rom_config = rom_config

        # extend
        self.extend_config = extend_config

        # tools
        # self.use_tools = use_tools



def all_compilers_opts(zsdcc_extra_optimization, compiler_opts):

    if z88dk_compiler in ('zsdcc','sdcc'):
        compiler_selection = " -compiler=sdcc "
        compiler_opts = compiler_opts + " " + zsdcc_compiler_opts
    elif z88dk_compiler in ('ez80clang', 'clang'):
        compiler_selection = " -compiler=ez80clang "
    else:
        compiler_selection = ""
        compiler_opts = compiler_opts + " " + sccz80_compiler_opts


    return " ZSDCC_MAKEFILE_COMPILATION_OPTS='" + zsdcc_compiler_opts + " " + \
                                                  zsdcc_extra_optimization + "'" + \
           " Z88DK_MAKEFILE_COMPILATION_OPTS='" + z88dk_compiler_opts + compiler_opts + \
                                                  compiler_selection + "'" + \
           " GCC4TI99_MAKEFILE_COMPILATION_OPTS='" + gcc4ti99_compiler_opts + "'" + \
           " VBCC_MAKEFILE_COMPILATION_OPTS='" + vbcc_compiler_opts + "'" + \
           " NATIVE_MAKEFILE_COMPILATION_OPTS='" + native_compiler_opts + "'" + \
           " CMOC_MAKEFILE_COMPILATION_OPTS='" + cmoc_compiler_opts + "'" + \
           " CC65_MAKEFILE_COMPILATION_OPTS='" + cc65_compiler_opts + "'" + \
           " LCC1802_MAKEFILE_COMPILATION_OPTS='" + lcc1802_compiler_opts + "'"


def run_command_verbosely(command_string):
    logger.info("Running command: %s", command_string)
    if global_vars.verbose:
        print("Going to run: ")
        printc(bcolors.BOLD, command_string+"\n")
    else:
        command_string+= " > /dev/null 2>&1"

    os.system(command_string)


def generic_input(string):
    if sys.version_info[0] < 3:
        return raw_input(string)
    return input(string)

def are_you_sure():
    return generic_input("Are you sure [Y/N]? ").lower()


def multiple_project_reset(mypath):
    projects = []
    for (_, dirnames, _) in walk(mypath):
        projects.extend(dirnames)
        break

    for project_name in projects:
        print("PROJECT: " + project_name)
        reset([mypath, project_name])
        print("\n")


def multiple_size_build(mypath,target,xsize,ysize,debug):
    projects = []
    for (_, dirnames, _) in walk(mypath):
        projects.extend(dirnames)
        break

    if use_tools:
        use_tools_str = " USE_TOOLS=1 "
    else:
        use_tools_str = ""

    for project_name in projects:

        if is_project_split(project_name):
            project_type = project_category(project_name)
            create_main(project_name,project_type)
        make_command = \
            GNU_MAKE + " " + target + use_tools_str + " XSIZE=" + xsize +  \
                       " YSIZE=" + ysize + " _DEBUG_FLAG=" + str(debug) + \
                " _NATIVE_CC=" + native_compiler + " " + all_compilers_opts("","") + \
                " GNU_MAKE=" + GNU_MAKE + \
                " TOOL_CC=" + tool_compiler + \
                " -f " + mypath+"/"+project_name+"/Makefile."+project_name

        run_command_verbosely(make_command)
        if is_project_split(project_name):
            delete_main(project_name,project_type)

#TODO: cc65 targets
#TODO: cmoc targets
#TODO: lcc1802 targets
#TODO: mc10 (6303)
#TODO: c128 (complicated because of c1541)
#TODO: cpc (complicated because of nocart)
PARALLEL_TARGETS = \
    [
    'stdio',

    'apple2',
    'apple2enh',
    'atari',
    'atari_lynx',
    'atari5200',
    'atari7800',
    'c16',
    'c64',
    'cbm610',
    'cbm510',
    'creativision',
    'gamate',
    'oric',
    'nes',
    'pet',
    'pce',
    'supervision',
    'vic20',

    'ncurses',
    'terminal',
    'terminal8x8',
    'terminal8x6',
    'terminal7x8',
    'terminal6x9',
    'terminal6x8',

    'ace',
    'agon',
    'aquarius',
    'aussie',
    'bit90',
    'camputers_lynx',
    'cpm',
    'coleco',
    'eg2k',
    'einstein',
    'gb',
    'gal',
    'gl6000sl',
    'gamegear',
    'hector',
    'hectorhr',
    'kaypro',
    'kaypro83',
    'kc85',
    'lambda',
    'laser500',
    'm5',
    'm5_rom',
    'm5_keyboard',
    'm5_keyboard_rom',
    'm100',
    'mc1000',
    'mc1000_mono',
    'microbee',
    'msx',
    'mtx500',
    'mtx512',
    'mz',
    'mz2500',
    'newbrain',
    'nc100',
    'nc200',
    'pc8201',
    'pc88',
    'pv1000',
    'pv1000_no_gfx',
    'px4',
    'px8',
    'samcoupe',
    'sc3000',
    'sc3000_rom',
    'sg1000',
    'sms',
    'spectrum',
    'svi',
    't200',
    'trs80',
    'vg5k',
    'vz200',
    'x1',
    'zx81',
    'zx81_wrx',
    'zx81_8x6',
    'zx81_wrx64',
    'zx81_8x6_wrx64',
    'zx81_wrx128',
    'zx81_8x6_wrx128',
    'z9001',
    'kc',
    'z1013',
    'zx80',
    'zxn'
    ]

def multiple_build(mypath,target,threads,zsdcc_extra_optimization, reset_flag=False):
    projects = []

    if use_tools:
        use_tools_str = " USE_TOOLS=1 "
    else:
        use_tools_str = ""

    for (_, dirnames, _) in walk(mypath):
        projects.extend(dirnames)
        break

    projects_to_build = len(projects)

    # files_before = len(files_in_path("../build"))-1
    if global_vars.verbose:
        print("Building " + str(projects_to_build) + " projects: ", end="")
        for project_name in projects:
            printc(bcolors.OKCYAN,project_name+" ")
        print("")

    if (parallelize_multi_build==1) and (target in PARALLEL_TARGETS):
        logger.info("Parallelize multi build with %s", threads)
        pool = Pool(processes=int(threads))

        for project_name in projects:
            if reset_flag:
                reset(["",project_name])
            if is_project_split(project_name):
                project_type = project_category(project_name)
                create_main(project_name,project_type)
            make_command = \
                GNU_MAKE + " " + target + use_tools_str + \
                    " ZSDCC_MAKEFILE_THREADS_OPTS=\'-j " + threads + "'" \
                    + all_compilers_opts(zsdcc_extra_optimization, "") + \
                    " _NATIVE_CC=" + native_compiler + \
                    " TOOL_CC=" + tool_compiler + " GNU_MAKE=" + GNU_MAKE + \
                    " -f " + mypath+"/"+project_name+"/Makefile."+project_name
            pool.apply_async(run_command_verbosely, [make_command])

        pool.close()
        pool.join()

        for project_name in projects:
            if is_project_split(project_name):
                delete_main(project_name,project_type)
    else:
        for project_name in projects:
            if reset_flag:
                reset(["",project_name])
            print("project name: " + project_name)
            if is_project_split(project_name):
                project_type = project_category(project_name)
                create_main(project_name,project_type)
            make_command = \
                GNU_MAKE + " " + target + use_tools_str + \
                    " ZSDCC_MAKEFILE_THREADS_OPTS=\'-j " + threads + "'" \
                    + all_compilers_opts(zsdcc_extra_optimization, "") + \
                    " _NATIVE_CC=" + native_compiler + \
                    " TOOL_CC=" + tool_compiler + " GNU_MAKE=" + GNU_MAKE + \
                    " -f " + mypath+"/"+project_name+"/Makefile."+project_name

            run_command_verbosely(make_command)
            if is_project_split(project_name):
                delete_main(project_name,project_type)


# Run a project natively (terminal with ncurses) with a given XSize and YSize
def size(params,debug):

    if len(params)<2:
        game_dir = "helloworld"
    else:
        game_dir = params[1]

    project_type = project_category(game_dir)

    parent_dir = project_type + "s"

    target, xsize, ysize = get_size_params(params)

    if global_vars.verbose:
        print("Project name       : " + game_dir)
        print("Project type       : " + project_type)
        print("XSize: " + xsize)
        print("YSize: " + ysize)
        print("target: " + target)

    parent_and_game_dir = parent_dir + "/" + game_dir

    files_before = len(files_in_path("../build"))-1


    if game_dir not in ["games", "examples", "projects", "all"]:
        if not os.path.exists(parent_and_game_dir):
            print("Project not found!")
            return

        if is_project_split(game_dir):
            printc(bcolors.OKBLUE,"Create main.c from split source files\n")
            create_main(game_dir, project_type)
        make_command = \
            GNU_MAKE + " " + target + " XSIZE=" + xsize +  " YSIZE=" + ysize + \
                " _DEBUG_FLAG=" + str(debug) + " " \
                + all_compilers_opts("","") + \
                " _NATIVE_CC=" + native_compiler + \
                " TOOL_CC=" + tool_compiler + \
                " -f " + parent_dir+"/"+game_dir+"/Makefile."+game_dir
        run_command_verbosely(make_command)

        if is_project_split(game_dir):
            printc(bcolors.OKBLUE,"Delete main.c (because of split source files)\n")
            delete_main(game_dir, project_type)
    else:
        if game_dir in["games","examples","projects"]:
            multiple_size_build(game_dir,target,xsize,ysize,debug)
        elif game_dir in["new"]:
            multiple_size_build("projects",target,xsize,ysize,debug)
        elif game_dir in["builtin","built-in"]:
            multiple_size_build("games",target,xsize,ysize,debug)
            multiple_size_build("examples",target,xsize,ysize,debug)
        elif game_dir=="all":
            multiple_size_build("games",target,xsize,ysize,debug)
            multiple_size_build("examples",target,xsize,ysize,debug)
            multiple_size_build("projects",target,xsize,ysize,debug)
        else:
            return

    files_after = len(files_in_path("../build"))-1

    if global_vars.verbose:
        print("New binaries built: " + str(files_after-files_before)+"\n")


# Rebuild a project, i.e., also rebuilds assets
def rebuild(params):
    build(params, reset_flag=True)


def convert_makefile(dir,old_type,old_name,new_name):

    dest_path = "projects/"+dir
    source_game_dir = old_name
    target_game_dir = new_name
    source_parent_dir = old_type
    target_parent_dir = "projects"

    if global_vars.verbose:
        print("- dir: " + dir)
        print("- old_type: " + old_type)
        print("- old_name: " + old_name)
        print("- new_game: " + new_name)

    fin = open("./"+dest_path+"/Makefile."+source_game_dir, "rt")
    data = fin.read()
    data = data.replace('CROSS-' + source_game_dir.upper(),'CROSS-'+target_game_dir.upper())
    data = data.replace('GAME_NAME := ' + source_game_dir, 'GAME_NAME := '+target_game_dir)
    data = data.replace('PARENT_DIR = ' + source_parent_dir + "s", \
           'PARENT_DIR = ' + target_parent_dir)

    data = data.replace('include ./' + old_type + "s/" + source_game_dir, \
           'include ./projects/' + target_game_dir)
    fin.close()
    fin = open("./"+dest_path+"/Makefile."+target_game_dir, "wt")
    fin.write(data)
    fin.close()

    os.remove("./"+dest_path+"/Makefile."+source_game_dir)


# Rename a project
def rename(params):
    if len(params)<2:
        source_game_dir = "helloworld"
    else:
        source_game_dir = params[1]

    if len(params)<3:
        print("ERROR: You need to provide more paramaters")
        return

    target_game_dir = params[2]

    source_project_type = project_category(source_game_dir)

    if source_project_type != "project":
        return

    target_project_type = "project"
    target_parent_dir = target_project_type + "s"
    target_parent_dir_and_game_dir = target_parent_dir + "/" + target_game_dir

    if global_vars.verbose:

        print("source_project_type: " + source_project_type)

    convert_makefile(source_game_dir, source_project_type, source_game_dir, target_game_dir)

    os.rename(target_parent_dir + "/" +source_game_dir, target_parent_dir_and_game_dir)


# Clone a project to create a new one
def clone(params):
    if len(params)<2:
        source_game_dir = "helloworld"
    else:
        source_game_dir = params[1]

    if len(params)<3:
        return

    target_game_dir = params[2]


    source_project_type = project_category(source_game_dir)
    if global_vars.verbose:
        print("source project category: " + source_project_type)
    source_parent_dir = source_project_type + "s"
    source_parent_and_game_dir = source_parent_dir + "/" + source_game_dir

    target_project_type = "project"
    target_parent_dir = target_project_type + "s"
    target_parent_dir_and_game_dir = target_parent_dir + "/" + target_game_dir

    if global_vars.verbose:
        print("Source project name    : " + source_game_dir)
        print("Source Project type    : " + source_project_type)
        print("Path to source project : " + source_parent_and_game_dir)
        print("")
        print("Target project name    : " + target_game_dir)
        print("target Project type    : " + target_project_type)
        print("Path to target project : " + target_parent_dir_and_game_dir)

    # if not os.path.exists(target_parent_dir_and_game_dir):
        # print("Creating project dir...")
        # os.makedirs(target_parent_dir_and_game_dir)

    source_path = source_parent_and_game_dir
    if global_vars.verbose:
        print("source_path: " + source_path)
    dest_path = target_parent_dir_and_game_dir
    if global_vars.verbose:
        print("dest_path: " + dest_path)

    if not os.path.exists(dest_path+"/tiles"):
        if global_vars.verbose:
            print("Copying tiles...")
        shutil.copytree(source_path, dest_path)

    if not os.path.exists(dest_path+"/generated_assets"):
        if global_vars.verbose:
            print("Create empty generated_assets directory...")
        os.makedirs(dest_path+"/generated_assets")

    convert_makefile(target_game_dir, source_project_type, source_game_dir, target_game_dir)


# Generate tools from source code
def tools():
    make_command = \
        GNU_MAKE + " -j " + compilation_threads + " tools TOOL_CC=" + tool_compiler + \
        " GNU_MAKE=" + GNU_MAKE + " -f makefiles.common/auxiliary/Makefile_tools"
    run_command_verbosely(make_command)


def create_main(game_dir, project_type):
    parent_dir_path = "./" + project_type + "s/"
    project_dir_path = parent_dir_path + game_dir + "/"
    split_dir_path = project_dir_path + "split_files/"

    # run_command_verbosely("cat " + split_dir_path + "*.c > " + project_dir_path + "main.c")
    os.system("cat " + split_dir_path + "*.c > " + project_dir_path + "main.c")


def delete_main(game_dir, project_type):
    parent_dir_path = "./" + project_type + "s/"
    project_dir_path = parent_dir_path + game_dir + "/"
    run_command_verbosely("rm -rf " + project_dir_path + "main.c")

# TODO: This should be replaced by a real check on the existence of the split_files directory
# SPLIT_PROJECTS = ['chase','shoot','snake']

def is_project_split(game_dir):
    project_type = project_category(game_dir)
    parent_dir_path = "./" + project_type + "s/"
    project_dir_path = parent_dir_path + game_dir + "/"

    # return game_dir in SPLIT_PROJECTS
    return os.path.isdir(project_dir_path+"split_files")


# Build a project (for a target or multiple targets)
def build(params, reset_flag = False):
    params = insert_default_sizes(params)

    # sized terminal
    if len(params)>=4 and params[2].startswith("terminal") and params[3].isnumeric() \
                      and params[4].isnumeric():
        size(["size"] + params[1:],0)
        return

    if len(params)<2:
        game_dir = "helloworld"
    else:
        game_dir = params[1]

    if len(params)>=1 and game_dir=="tools":
        tools()
    else:

        files_before = len(files_in_path("../build"))-1

        project_type = project_category(game_dir)
        parent_dir = project_type + "s"

        if len(params)<3:
            target = "ncurses"
        else:
            target = params[2]

        if target in ["cc65", "z88dk", "cmoc", "lcc1802", "cc6303", "gcc4ti", "vbcc"]:
            target = target + "_targets"

        if len(params)<4:
            threads = str(compilation_threads)
        else:
            threads = params[3]

        if len(params)>=5 and params[4]=="on":
            zsdcc_extra_optimization = "--max-allocs-per-node200000"
        else:
            zsdcc_extra_optimization = ""

        if len(params)>=6:
            compiler_opts = " " + params[5]
        else:
            compiler_opts = ""

        if global_vars.verbose:

            print("Project name       : ", end="")
            printc(bcolors.BOLD, game_dir+"\n")

            print("Target name        : ", end="")
            printc(bcolors.UNDERLINE, target+"\n")

            print("Project type       : " + project_type)
            print("Number of threads  : " + threads)
            print("Extra optimization : " + zsdcc_extra_optimization)
            print("Compiler's options : " + compiler_opts)

            print("--------------------------")
            print("z88dk_compiler_opts     : " + z88dk_compiler_opts)
            print("zsdcc_compiler_opts     : " + zsdcc_compiler_opts)
            print("cmoc_compiler_opts      : " + cmoc_compiler_opts)
            print("cc65_compiler_opts      : " + cc65_compiler_opts)
            print("lcc1802_compiler_opts   : " + lcc1802_compiler_opts)
            print("gcc4ti99_compiler_opts  : " +  gcc4ti99_compiler_opts)
            print("vbcc_compiler_opts      : " +  vbcc_compiler_opts)
            print("native_compiler_opts    : " +  native_compiler_opts)

            print("")

        parent_and_game_dir = parent_dir + "/" + game_dir

        if os.path.exists(parent_and_game_dir + "/config.ini"):
            print("Local config.ini detected")
            read_config(parent_and_game_dir + "/config.ini")

        if game_dir not in ["games", "examples", "projects", "all"]:
            if reset_flag:
                reset(params)
            if not os.path.exists(parent_and_game_dir):
                print("Project not found!")
                return
            if use_tools:
                use_tools_str = " USE_TOOLS=1 "
            else:
                use_tools_str = ""

            if is_project_split(game_dir):
                printc(bcolors.OKBLUE,"Create main.c from split source files\n")
                create_main(game_dir, project_type)

            make_command = \
                GNU_MAKE + " " + target + \
                    use_tools_str + \
                    " ZSDCC_MAKEFILE_THREADS_OPTS=\'-j " + threads + "' " \
                    + all_compilers_opts(zsdcc_extra_optimization, compiler_opts) +  \
                    " _NATIVE_CC=" + native_compiler + \
                    " TOOL_CC=" + tool_compiler + " GNU_MAKE=" + GNU_MAKE + \
                    " -f " + parent_dir+"/"+game_dir+"/Makefile."+game_dir

            run_command_verbosely(make_command)

            if is_project_split(game_dir):
                printc(bcolors.OKBLUE,"Delete main.c because of split source files\n")
                delete_main(game_dir, project_type)

        else:
            if game_dir in ["games","examples","projects"]:
                multiple_build(game_dir,target,threads,zsdcc_extra_optimization, reset_flag)
            elif game_dir=="new":
                multiple_build("projects",target,threads,zsdcc_extra_optimization, reset_flag)
            elif game_dir in ["builtin","built-in"]:
                multiple_build("games",target,threads,zsdcc_extra_optimization, reset_flag)
                multiple_build("examples",target,threads,zsdcc_extra_optimization, reset_flag)
            elif game_dir=="all":
                multiple_build("games",target,threads,zsdcc_extra_optimization, reset_flag)
                multiple_build("examples",target,threads,zsdcc_extra_optimization, reset_flag)
                multiple_build("projects",target,threads,zsdcc_extra_optimization, reset_flag)
            else:
                return

        files_after = len(files_in_path("../build"))-1

        if global_vars.verbose:
            printc(bcolors.OKBLUE, "New binaries built: " + str(files_after-files_before)+"\n")



def slow(params):

    game_dir = params[1]


    project_type = project_category(game_dir)
    parent_dir = project_type + "s"


    target = params[2]

    slowdown = params[3]


    parent_and_game_dir = parent_dir + "/" + game_dir

    if os.path.exists(parent_and_game_dir + "/config.ini"):
        print("Local config.ini detected")
        read_config(parent_and_game_dir + "/config.ini")

    if not os.path.exists(parent_and_game_dir):
        print("Project not found!")
        return

    if is_project_split(game_dir):
        printc(bcolors.OKBLUE,"Create main.c from split source files\n")
        create_main(game_dir, project_type)

    make_command = \
        GNU_MAKE + " " + target + \
            " SLOWDOWN=" + slowdown + \
            all_compilers_opts("", "") +  \
            " -f " + parent_dir+"/"+game_dir+"/Makefile."+game_dir

    run_command_verbosely(make_command)

    if is_project_split(game_dir):
        printc(bcolors.OKBLUE,"Delete main.c because of split source files\n")
        delete_main(game_dir, project_type)


# Create a new project
def create(params):
    if len(params)<2:
        game_dir = "helloworld"
    else:
        game_dir = params[1]
    game_dir_capital = game_dir.upper()
    game_dir_capital_without_special_chars = \
        only_upper_digits_and_space(game_dir.upper().replace("-"," ").replace("_"," "))

    game_dir = no_space(game_dir)

    if game_dir in example_projects or game_dir in game_projects or game_dir in COMMANDS_LIST:
        print("invalid name!")
        return

    if len(params)<3:
        project_type = "helloworld"
    else:
        if params[2]=="game" or params[2]=="arcade":
            project_type = "arcade_game"
        elif params[2]=="text":
            project_type = "text_game"
        elif params[2]=="test":
            project_type = "test"
        else:
            if params[2] in ["apis","show_apis","example","show","demo"]:
                project_type = "demo"
            else:
                project_type = "helloworld"

    parent_dir = "projects"

    if global_vars.verbose:
        print("New project name: " + game_dir)
        print("Project type: " + project_type)

    parent_and_game_dir = parent_dir + "/" + game_dir

    if not os.path.exists(parent_and_game_dir):
        if global_vars.verbose:
            print("Creating project dir...")
        os.makedirs(parent_and_game_dir)

    source_path = "./template_projects/"+project_type+"_code.template"
    if global_vars.verbose:
        print("source_path: " + source_path)
    dest_path = parent_and_game_dir
    if global_vars.verbose:
        print("dest_path: " + dest_path)

    if not os.path.exists(dest_path+"/tiles"):
        if global_vars.verbose:
            print("Copying tiles...")
        shutil.copytree(source_path+"/tiles", dest_path+"/tiles")

    if not os.path.exists(dest_path+"/shapes"):
        if global_vars.verbose:
            print("Copying shapes...")
        if not os.path.exists(source_path+"/shapes"):
            os.makedirs(dest_path+"/shapes")
        else:
            shutil.copytree(source_path+"/shapes", dest_path+"/shapes")

    if not os.path.exists(dest_path+"/generated_assets"):
        if global_vars.verbose:
            print("Create empty generated_assets directory...")
        os.makedirs(dest_path+"/generated_assets")

    if not os.path.exists(dest_path+"/config"):
        if global_vars.verbose:
            print("Create empty config directory...")
        os.makedirs(dest_path+"/config")

    file_names = ["main.c"]

    for file_name in file_names:
        if global_vars.verbose:
            print("Copying file_name: " + file_name)
        shutil.copy(source_path+"/"+file_name, dest_path)

    # Replace _GAME_NAME_CAPITAL with the capitalized game name without special characters
    fin = open("./"+dest_path+"/main.c", "rt")
    data = fin.read()
    data = data.replace('_GAME_NAME_CAPITAL',game_dir_capital_without_special_chars)
    fin.close()
    fin = open("./"+dest_path+"/main.c", "wt")
    #overrite the input file with the resulting data
    fin.write(data)

    templated_makefile_path = "./template_projects"

    shutil.copy(templated_makefile_path+"/"+"Makefile_game.template", \
                "./"+dest_path+"/Makefile."+game_dir)

    shutil.copy(templated_makefile_path+"/"+"/config/project_config.mk.template", \
                "./"+dest_path+"/config/project_config.mk")
    shutil.copy(templated_makefile_path+"/"+"/config/game_config.mk.template", \
                "./"+dest_path+"/config/game_config.mk")


    #read input file
    fin = open("./"+dest_path+"/Makefile."+game_dir, "rt")
    #read file contents to string
    data = fin.read()
    #replace all occurrences of the required string
    data = data.replace('_GAME_NAME_CAPITAL',game_dir_capital)
    data = data.replace('_GAME_NAME_', game_dir)
    data = data.replace('_PARENT_DIR_', parent_dir)
    #close the input file
    fin.close()
    #open the file in write mode
    fin = open("./"+dest_path+"/Makefile."+game_dir, "wt")
    #overrite the input file with the resulting data
    fin.write(data)
    #close the file
    fin.close()


# Delete temporary project files If a project is specified, it also deletes generated assets.
def reset(params):
    par_len = len(params)

    if par_len>1:
        game_dir = params[1]
    else:
        game_dir=""

    if game_dir in ["games","examples","projects"]:
        multiple_project_reset(game_dir)
        return
    if game_dir=="new":
        multiple_project_reset("projects")
        return
    if game_dir in ["builtin","built-in"]:
        multiple_project_reset("games")
        multiple_project_reset("examples")
        return
    if game_dir=="all":
        multiple_project_reset("games")
        multiple_project_reset("examples")
        multiple_project_reset("projects")
        return

    if (len(params)==2) and (params[par_len-1]=='-y'): #(params[1]=='-y'):
        make_command = GNU_MAKE + \
                       " clean_generic_no_built_in -f makefiles.common/auxiliary/Makefile_common"

        if global_vars.verbose:
            print("Delete all non-project-specific temporary files")

        run_command_verbosely(make_command)
        return

    if len(params)<2:
        make_command = GNU_MAKE + \
            " clean_generic_no_built_in -f makefiles.common/auxiliary/Makefile_common"
        if global_vars.verbose:
            print("Delete all non-project-specific temporary files")
        if are_you_sure()=="y":
            run_command_verbosely(make_command)
            return
        return

    game_dir = params[1]

    project_type = project_category(game_dir)

    parent_dir = project_type + "s"

    if global_vars.verbose:

        print("Project name: " + game_dir)

    parent_and_game_dir = parent_dir + "/" + game_dir

    if not os.path.exists(parent_and_game_dir):
        print("Project not found!")
        return

    if global_vars.verbose:

        print("Delete all temporary files including generated assets for '"+game_dir+"'")

    # if (not interactive) or (are_you_sure()=="y"):
    make_command = GNU_MAKE + " clean_no_built_in -f " + \
                   parent_dir+"/"+game_dir+"/Makefile."+game_dir

    run_command_verbosely(make_command)


# Clean project data
def clean(params):

    if len(params)>=2:
        if params[1]=="tools":
            make_command = GNU_MAKE + " clean_tools -f makefiles.common/auxiliary/Makefile_tools"

            run_command_verbosely(make_command)
            return
        if params[1]=="log" or params[1]=="logs":
            make_command = GNU_MAKE + " clean_logs -f makefiles.common/auxiliary/Makefile_tools"

            run_command_verbosely(make_command)
            return

    if len(params)<2:
        make_command = GNU_MAKE + " clean_generic -f makefiles.common/auxiliary/Makefile_common"

        if global_vars.verbose:
            print("Delete all built binaries and non-project=specific temporary files")
        if are_you_sure()=="y":
            run_command_verbosely(make_command)
            return
        return
    if (len(params)==2) and (params[1]=='-y'):
        make_command = GNU_MAKE + " clean_generic -f makefiles.common/auxiliary/Makefile_common"

        if global_vars.verbose:
            print("Delete all built binaries and non-project-specific temporary files")

        run_command_verbosely(make_command)
        return

    game_dir = params[1]

    project_type = project_category(game_dir)

    parent_dir = project_type + "s"

    print("Project name: " + game_dir)

    parent_and_game_dir = parent_dir + "/" + game_dir

    if not os.path.exists(parent_and_game_dir):
        print("Project not found!")
        return

    print("Delete all built binaries and temporary files (also specific to '"+ \
          game_dir+"', e.g., generated assets)")

    # if (not interactive) or (are_you_sure()=="y"):
    make_command = GNU_MAKE + " clean -f " + parent_dir+"/"+game_dir+"/Makefile."+game_dir

    run_command_verbosely(make_command)


# Delete project
def delete(params):
    if(len(params)>=2) and params[1]=="tools":
        make_command = GNU_MAKE + " clean_tools"

        run_command_verbosely(make_command)
        return

    if len(params)<2:
        game_dir="helloworld"
    else:
        candidate_name = params[1]
        if candidate_name in example_projects or candidate_name in game_projects or \
            candidate_name in COMMANDS_LIST:
            print("invalid name!")
            return
        game_dir = candidate_name

    if (len(params)>2) and (params[2]=="-y"):
        interactive = False
    else:
        interactive = True

    parent_dir = "projects"

    if global_vars.verbose:
        print("Project name: " + game_dir)

    parent_and_game_dir = parent_dir + "/" + game_dir
    if global_vars.verbose:
        print("Remove the project '"+game_dir+ \
              "' with all its files (source, graphics assets, makefile)")
    if (not interactive) or (are_you_sure()=="y"):
        if os.path.exists(parent_and_game_dir):
            if global_vars.verbose:
                print("Deleting directory " + parent_and_game_dir)
            shutil.rmtree(parent_and_game_dir)

        makefile_name = "Makefile."+game_dir
        if os.path.exists(makefile_name):
            if global_vars.verbose:
                print("Deleting..." + makefile_name)
            os.remove(makefile_name)
        if global_vars.verbose:
            print("'" + game_dir + "' deleted")
    else:
        return


def built_files_in_path(mypath):
    files = []
    for (_, _, filenames) in walk(mypath):
        built_files = []
        for filename in filenames:
            if not filename.startswith('.'):
                built_files.append(filename)

        files.extend(built_files)
        break
    return files


def clean_test():
    clean(["clean","-y"])
    files_after_clean = len(files_in_path("../build"))

    if files_after_clean>1:
        printc(bcolors.FAIL, "[xl clean]        KO\n")
        return 0
    printc(bcolors.OKGREEN, "[xl clean]        OK\n")
    return 1


CROSS_COMPILER_COMMAND = \
    {
    'cc65'        : 'cl65',
    'z88dk'       : 'zcc',
    'cmoc'        : 'cmoc',
    'cc6303'      : 'cc68 -h',
    'lcc1802'     : 'lcc',
    'vbcc'        : 'vc -h',
    'ack'         : 'ack -h',
    'tms9900-gcc' : 'tms9900-gcc -h'
    }

CROSS_COMPILER_COMMAND_EXPECTED = \
    {
    'cc65'   : 0,
    'z88dk'  : 0,
    'cmoc'   : 256,
    'cc6303' : 256,
    'lcc1802': 0,
    'vbcc'   : 256,
    'ack'    : 0,
    'tms9900-gcc': 256
    }


NATIVE_COMPILER_COMMAND = \
    {
    'gcc'         : 'gcc',
    'g++'         : 'g++',
    }

NATIVE_COMPILER_COMMAND_EXPECTED = \
    {
    'gcc'    : 256,
    'g++'    : 256,
    }


TOOL_COMMAND = \
    {
    'f2k5'     : '../tools/cmoc/mo5/f2k5.' + NATIVE_EXTENSION + '',
    'sapfs'    : '../tools/cmoc/mo5/sapfs.' + NATIVE_EXTENSION + '',
    'file2dsk' : '../tools/cmoc/coco/file2dsk/file2dsk.' + NATIVE_EXTENSION + ' -h',
    'makewzd'  : '../tools/z88dk/oz/makewzd.' + NATIVE_EXTENSION + ' -h',
    'fixcart'  : '../tools/cc65/gamate/gamate-fixcart.' + NATIVE_EXTENSION + '',
    'bbcim'    : '../tools/bbc/bbcim.' + NATIVE_EXTENSION + ' -h',
    'nocart'   : '../tools/z88dk/cpc/nocart/nocart.' + NATIVE_EXTENSION + ' -h',
    'm20'      : '../tools/olivetti_m20/m20.' + NATIVE_EXTENSION + ' -h',
    'elf2ea5'  : '../tools/ti99/elf2ea5.' + NATIVE_EXTENSION + ' -h',
    'ea5split' : '../tools/ti99/ea5split.' + NATIVE_EXTENSION + ' -h',
    }

TOOL_COMMAND_EXPECTED = \
    {
    'f2k5'     : 0,
    'sapfs'    : 256,
    'file2dsk' : 256,
    'makewzd'  : 256,
    'fixcart'  : 65280,
    'bbcim'    : 256,
    'nocart'   : 256,
    'm20'      : 256,
    'elf2ea5'  : 256,
    'ea5split' : 256,
    }


EMULATOR_COMMAND = \
    {
    'c1541'    : 'c1541 -h',
    'x64'      : 'x64 -h',
    'xvic'     : 'xvic -h',
    'xplus4'   : 'xplus4 -h',
    'xpet'     : 'xpet -h',
    'mame'     : 'mame -h',
    }

EMULATOR_COMMAND_EXPECTED = \
    {
    'java'     : 0,
    'perl'     : 0,
    'c1541'    : 0,
    'x64'      : 0,
    'xvic'     : 0,
    'xplus4'   : 0,
    'xpet'     : 0,
    'mame'     : 0,
    }


BUILDABLE_TOOLS = \
{
    'f2k5',
    'sapfs',
    'file2dsk',
    'makewzd',
    'fixcart',
    'bbcim',
    'nocart',
    'm20',
    'elf2ea5',
    'ea5split',
}


INTERPRETER_COMMAND = \
    {
    'java'     : 'java -h',
    'perl'     : 'perl -h',
    }

INTERPRETER_COMMAND_EXPECTED = \
    {
    'java'     : 0,
    'perl'     : 0,
    }

LIBRARY_COMMAND = \
    {
    'ncurses'  : "ls /usr/include/ncurses.h",
    }

LIBRARY_COMMAND_EXPECTED = \
    {
    'ncurses'  : 0,
    }

ROM_COMMAND = \
    {
    'msx/msx.zip'      : 'ls ../roms/mame/msx.zip',
    'msx/canon20.zip'  : 'ls ../roms/mame/canonv20.zip',

    'c16/kernal'     : 'ls ../roms/vice/plus4/kernal',
    'c16/basic'     : 'ls ../roms/vice/plus4/basic',
    'c16/3plus1hi'     : 'ls ../roms/vice/plus4/3plus1hi',
    'c16/3plus1lo'     : 'ls ../roms/vice/plus4/3plus1lo',

    'c64/basic'     : 'ls ../roms/vice/c64/basic',
    'c64/chargen'     : 'ls ../roms/vice/c64/chargen',
    'c64/kernal'     : 'ls ../roms/vice/c64/kernal',

    'pet/basic1'     : 'ls ../roms/vice/pet/basic1',
    'pet/kernal1'     : 'ls ../roms/vice/pet/kernal1',

    'pet/basic2'     : 'ls ../roms/vice/pet/basic2',
    'pet/kernal2'     : 'ls ../roms/vice/pet/kernal2',

    'pet/basic4'     : 'ls ../roms/vice/pet/basic4',
    'pet/kernal4'     : 'ls ../roms/vice/pet/kernal4',

    'pet/chargen'     : 'ls ../roms/vice/pet/chargen',
    'pet/characters.901640-01.bin'     : 'ls ../roms/vice/pet/characters.901640-01.bin',

    'pet/edit1g'     :'ls ../roms/vice/pet/edit1g',
    'pet/edit2b'     :'ls ../roms/vice/pet/edit2b',
    'pet/edit2g'     :'ls ../roms/vice/pet/edit2g',

    'pet/edit4b40'     :'ls ../roms/vice/pet/edit4b40',
    'pet/edit4b80'     :'ls ../roms/vice/pet/edit4b80',
    'pet/edit4g40'     :'ls ../roms/vice/pet/edit4g40',

    'vic20/basic'     : 'ls ../roms/vice/vic20/basic',
    'vic20/chargen'     : 'ls ../roms/vice/vic20/chargen',
    'vic20/kernal'     : 'ls ../roms/vice/vic20/kernal',
    }


ROM_COMMAND_EXPECTED = \
    {
    'msx/msx.zip'        : 0,
    'msx/canon20.zip'    : 0,

    'c16/kernal'     : 0,
    'c16/basic'      : 0,
    'c16/3plus1hi'   : 0,
    'c16/3plus1lo'   : 0,

    'c64/kernal'     : 0,
    'c64/chargen'     :0,
    'c64/basic'     : 0,

    'pet/kernal1'     : 0,
    'pet/basic1'     : 0,

    'pet/kernal2'     : 0,
    'pet/basic2'     : 0,

    'pet/kernal4'     : 0,
    'pet/basic4'     : 0,

    'pet/chargen'     :0,
    'pet/characters.901640-01.bin'     :0,
    'pet/chargen'     :0,

    'pet/edit1g'     :0,
    'pet/edit2b'     :0,
    'pet/edit2g'     :0,

    'pet/edit4b40'     :0,
    'pet/edit4b80'     :0,
    'pet/edit4g40'     :0,



    'vic20/kernal'     : 0,
    'vic20/chargen'     :0,
    'vic20/basic'     : 0,
    }

MAKE_COMMAND = \
    {
    'make'     : 'make -h',
    'gmake'     : 'gmake -h',
    }

MAKE_COMMAND_EXPECTED = \
    {
    'make'  : 0,
    'gmake' : 0,
    }

def check_programs(title, command_list, expected_list, verbose=True):
    if verbose:
        printc(bcolors.OKCYAN,"----------------------------------------\n")
        printc(bcolors.OKCYAN, title)
        printc(bcolors.OKCYAN,"\n----------------------------------------\n")

    total_result = {}

    # max_len = 0
    # for compiler in command_list.keys():
        # if len(compiler)>max_len:
            # max_len = len(compiler)
    max_len = 28

    for compiler in command_list.keys():
        result = os.system(command_list[compiler] + " > /dev/null 2>&1")
        spaces = " " * (max_len+1-len(compiler))
        if result==expected_list[compiler]:
            if verbose:
                printc(bcolors.OKGREEN,"[" + compiler + "]")
            res = "found\n"
            res_color = bcolors.OKGREEN
            res_color2 = bcolors.OKGREEN
            total_result[compiler]=True
        else:

            total_result[compiler]=False
            if compiler in BUILDABLE_TOOLS:
                res = "NOT built\n"
                res_color = bcolors.OKBLUE
                res_color2 = bcolors.OKCYAN
            else:
                res = "NOT found\n"
                res_color = bcolors.WARNING
                res_color2 = bcolors.WARNING
            if verbose:
                printc(res_color,"[" + compiler + "]")
        if verbose:
            printc(res_color2, spaces + res)
    if verbose:
        printc(bcolors.OKCYAN,"----------------------------------------\n\n")
    return total_result



def test_cross_compilers():
    return check_programs("CROSS_COMPILERS", CROSS_COMPILER_COMMAND, \
                          CROSS_COMPILER_COMMAND_EXPECTED)

def test_native_compilers():
    return check_programs("NATIVE_COMPILERS", NATIVE_COMPILER_COMMAND, \
                          NATIVE_COMPILER_COMMAND_EXPECTED)

def test_make(verbose=True):
    return check_programs("MAKE", MAKE_COMMAND,MAKE_COMMAND_EXPECTED, verbose)

def test_tools(verbose=True):
    return check_programs("TOOLS", TOOL_COMMAND,TOOL_COMMAND_EXPECTED, verbose)

def test_emulators():
    return check_programs("EMULATORS", EMULATOR_COMMAND,EMULATOR_COMMAND_EXPECTED)

def test_interpreters():
    return check_programs("INTERPRETERS", INTERPRETER_COMMAND,INTERPRETER_COMMAND_EXPECTED)

def test_libraries():
    return check_programs("LIBRARIES", LIBRARY_COMMAND, LIBRARY_COMMAND_EXPECTED)

def test_roms():
    return check_programs("ROMS", ROM_COMMAND, ROM_COMMAND_EXPECTED)


def test_compilers():
    test_native_compilers()
    test_cross_compilers()


# TODO: Handle aliases such as dragon->coco

# TODO: Handle Windows vs Linux and targets with 3 binaries
if platform in ["cygwin", "msys"]:
    TARGETS_WITH_2_BINARIES = ['aquarius', 'cpc', 'coco3', 'to5', 'ace', 'mtx500', \
                               'mtx512', 'laser500']
    TARGETS_WITH_3_BINARIES = ['coco','abc80']
else:
    TARGETS_WITH_2_BINARIES = ['aquarius', 'cpc', 'coco3', 'to5', 'ace', 'mtx500', \
                               'mtx512', 'laser500','coco']
    TARGETS_WITH_3_BINARIES = ['abc80']


def list_of_projects(project_category):
    # print("category: " + project_category)
    if project_category in ["examples", "projects", "games"]:
        res = dirs_in_path("./"+project_category)
    else:
        res = dirs_in_path("./examples")+dirs_in_path("./games")+dirs_in_path("./projects")
    # print(res)
    return res


def test_projects(projects, target="stdio"):

    clean_test()

    if projects in ["examples", "projects", "games"]:
        number_of_projects = len(dirs_in_path("./"+projects))
    elif projects == "all":
        number_of_projects = \
        len(dirs_in_path("./examples")) + \
        len(dirs_in_path("./games")) + \
        len(dirs_in_path("./projects"))
    else:
        number_of_projects = 1
    print("number of projects: " + str(number_of_projects))
    #multiple_build
    build(["build",projects,target,compilation_threads,""])
    built_files = built_files_in_path("../build")

    # TODO: Handle target=*_targets and all
    if target.endswith("_targets") or target=="all":
        print("Test on the number of binaries for all these targets is not supported")

    if target in TARGETS_WITH_3_BINARIES:
        files_per_project = 3
    elif target in TARGETS_WITH_2_BINARIES:
        files_per_project = 2
    else:
        files_per_project = 1

    print("Expected binaries per project: " + str(files_per_project))

    if len(built_files)<files_per_project*number_of_projects:
        printc(bcolors.FAIL, "[xl build]  KO\n")
        print("Built files: " +str(built_files))
        print("Expected number : " + str(number_of_projects))
        print("No. Built files : " + str(len(built_files)))

        # success=0
        return False
    printc(bcolors.OKGREEN, "[xl build]  OK\n")
    return True


def test_clean_tools():
    #clean tools
    clean(["clean","tools"])

    tools_result_map=test_tools(False)
    number_of_tools = len(tools_result_map.keys())

    built_tools = 0
    for _, result in tools_result_map.items():
        if result:
            built_tools+=1
    if built_tools==0:
        printc(bcolors.OKGREEN, "[xl clean tools]  OK\n")
    else:
        printc(bcolors.FAIL, "[xl clean tools]  KO\n")
    return number_of_tools, built_tools


def test_self(target = "stdio",opt = "slow"):

    # print("target1: " + str(target))
    # if(len(params)<3):
        # target = "stdio"
    # else:
        # target = params[1]
    # print("target2: " + str(target))
    # quit()
    printc(bcolors.OKCYAN,"----------------------------------------\n")
    printc(bcolors.OKCYAN, "XL SCRIPT TEST")
    printc(bcolors.OKCYAN,"\n----------------------------------------\n")
    success = 1
    printc(bcolors.BOLD,  "target: ")
    printc(bcolors.OKBLUE,target+"\n")
    printc(bcolors.OKCYAN,"----------------------------------------\n")

    global_vars.test = 1
    global_vars.verbose = 0

    #clean tools
    number_of_tools, built_tools = test_clean_tools()
    if built_tools>0:
        success = 0

    if opt!="fast":

        #tools
        tools()

        tools_result_map=test_tools(False)
        built_tools = 0
        for _, result in tools_result_map.items():
            if result:
                built_tools+=1
        if built_tools==number_of_tools:
            printc(bcolors.OKGREEN, "[xl tools]        OK\n")
        else:
            printc(bcolors.FAIL, "[xl tools]       KO\n")
            print("built_tools: " + str(built_tools))
            print("number_of_tools: " + str(number_of_tools))
            success = 0

        #clean tools
        number_of_tools, built_tools = test_clean_tools()
        if built_tools > 0:
            success = 0

    #delete
    delete(["delete","_test_project","-y"])


    #clean
    success = success * clean_test()

    projects_before_create = list_projects(["list"],False)

    project_dirs_before_create = len(dirs_in_path("./projects"))
    initial_dirs = project_dirs_before_create

    # create
    create(["create", "_test_project", "test"])
    project_dirs_after_create = len(dirs_in_path("./projects"))

    if project_dirs_after_create!=project_dirs_before_create+1:
        printc(bcolors.FAIL, "[xl create]       KO\n")
        return 0
    printc(bcolors.OKGREEN, "[xl create]       OK\n")

    # list
    projects_after_create = list_projects(["list"],False)
    if projects_after_create!=projects_before_create+1:
        printc(bcolors.FAIL,"[xl list]         KO\n")
        success = 0
    printc(bcolors.OKGREEN,"[xl list]         OK\n")

    # create
    create(["create", "_test_project2", "game"])
    printc(bcolors.OKGREEN, "[xl create]       OK\n")

    # create
    create(["create", "_test_project3", "demo"])
    printc(bcolors.OKGREEN, "[xl create]       OK\n")

    # create
    create(["create", "_test_project4", "text"])
    printc(bcolors.OKGREEN, "[xl create]       OK\n")

    # create
    create(["create", "_test_project5", "helloworld"])
    printc(bcolors.OKGREEN, "[xl create]       OK\n")

    #build
    build(["build", "_test_project2", target])
    built_files = built_files_in_path("../build")
    printc(bcolors.OKGREEN,"[xl build]        OK\n")

    #build
    build(["build", "_test_project3", target])
    built_files = built_files_in_path("../build")
    printc(bcolors.OKGREEN,"[xl build]        OK\n")

    #build
    build(["build", "_test_project4", target])
    built_files = built_files_in_path("../build")
    printc(bcolors.OKGREEN,"[xl build]        OK\n")

    #build
    build(["build", "_test_project5", target])
    built_files = built_files_in_path("../build")
    printc(bcolors.OKGREEN,"[xl build]        OK\n")

    #clean
    success = success * clean_test()
    if success:
        printc(bcolors.OKGREEN,"[xl clean]        OK\n")

    #delete
    delete(["delete","_test_project2","-y"])
    printc(bcolors.OKGREEN, "[xl delete]       OK\n")

    #delete
    delete(["delete","_test_project3","-y"])
    printc(bcolors.OKGREEN, "[xl delete]       OK\n")

    #delete
    delete(["delete","_test_project4","-y"])
    printc(bcolors.OKGREEN, "[xl delete]       OK\n")

    #delete
    delete(["delete","_test_project5","-y"])
    printc(bcolors.OKGREEN, "[xl delete]       OK\n")

    #delete
    delete(["delete","_foo_test","-y"])

    #rename
    rename(["","_test_project", "_foo_test"])
    printc(bcolors.OKGREEN,"[xl rename]       OK\n")

    #rename
    rename(["","_foo_test", "_test_project"])
    printc(bcolors.OKGREEN,"[xl rename]       OK\n")

    #build
    build(["build", "_test_project", target])
    built_files = built_files_in_path("../build")

    if global_vars.verbose:
        print("built binaries: " + str(built_files))
    if len(built_files)==0:
        print("built binaries: " + str(built_files))

        printc(bcolors.FAIL, "[xl build]        KO\n")
        success=0
    else:
        printc(bcolors.OKGREEN, "[xl build]        OK\n")

    dirs_in_proj_before = len(dirs_in_path("./projects/_test_project"))
    if dirs_in_proj_before != 4:
        printc(bcolors.FAIL, "[xl build]        KO\n")
        success=0

    dirs_in_shapes_before = len(dirs_in_path("./projects/_test_project/shapes"))
    if dirs_in_shapes_before != 1:
        printc(bcolors.FAIL, "[xl build]        KO\n")
        print(dirs_in_shapes_before)
        print(str(dirs_in_path("./projects/_test_project/shapes")))
        success=0

    extend(["extend", "_test_project"])

    dirs_in_proj_after = len(dirs_in_path("./projects/_test_project"))

    if dirs_in_proj_after != 4:
        printc(bcolors.FAIL, "[xl extend]       KO\n")
        success=0

    dirs_in_shapes_after = len(dirs_in_path("./projects/_test_project/shapes"))

    if dirs_in_shapes_after != 5:
        printc(bcolors.FAIL, "[xl extend]       KO\n")
        print("no. dirs_in_shapes_after: " + str(dirs_in_shapes_after))
        print("dirs_in_shapes_after: " + str(dirs_in_path("./projects/_test_project/shapes")))
        success=0

    if success:
        printc(bcolors.OKGREEN, "[xl extend]       OK\n")


    # run
    run(["run", "_test_project", "stdio"])

    if global_vars.verbose:
        print("")
    printc(bcolors.OKGREEN, "[xl run]          OK\n")


    projects_before_create = list_projects(["list"],False)

    project_dirs_before_create = len(dirs_in_path("./projects"))


    # print(str(dirs_in_path("./projects")))

    # clone
    clone(["","_test_project","_cloned_test_project"])
    project_dirs_after_create = len(dirs_in_path("./projects"))

    # print(str(dirs_in_path("./projects")))

    if project_dirs_after_create!=project_dirs_before_create+1:
        printc(bcolors.FAIL,
                            "[xl clone]        KO\n")
        return 0
    printc(bcolors.OKGREEN,
                            "[xl clone]        OK\n")


    # run
    run(["run", "_test_cloned_test_project_project", "stdio"])

    if global_vars.verbose:
        print("")
    printc(bcolors.OKGREEN, "[xl run]          OK\n")

    # delete
    delete(["","_cloned_test_project","-y"])
    printc(bcolors.OKGREEN, "[xl delete]       OK\n")


    #clean
    success = success * clean_test()

    #shapes
    shapes(["","_test_cloned_test_project_project"])
    # make_assets_from_tiles(["_test_cloned_test_project_project"])
    printc(bcolors.OKGREEN, "[xl shapes]       OK\n")


    if opt!="fast":

        #size
        size(["size", "_test_project", "stdio_sized", "12", "12"],True)
        built_files = built_files_in_path("../build")

        if global_vars.verbose:
            print("built binaries: " + str(built_files))
        if len(built_files)!=1:
            printc(bcolors.FAIL, "[xl size]         KO\n")
            print(str(built_files))
            success=0
        else:
            printc(bcolors.OKGREEN, "[xl size]         OK\n")

        dirs_in_proj_before = len(dirs_in_path("./projects/_test_project"))
        if dirs_in_proj_before != 4:
            printc(bcolors.FAIL, "[xl size]         KO\n")
            print(str(dirs_in_path("./projects/_test_project")))
            success=0

        dirs_in_shapes_before = len(dirs_in_path("./projects/_test_project/shapes"))
        if dirs_in_shapes_before != 5:
            printc(bcolors.FAIL, "[xl size]         KO\n")
            print(str(dirs_in_path("./projects/_test_project/shapes")))
            success=0

        #reset
        reset(["","-y"])
        printc(bcolors.OKGREEN, "[xl reset]        OK\n")

        #size
        size(["size", "_test_project", "stdio_sized", "32", "24"],False)
        built_files = built_files_in_path("../build")

        if global_vars.verbose:
            print("built binaries: " + str(built_files))

        if len(built_files)!=2:
            printc(bcolors.FAIL, "[xl size]         KO\n")
            print(str(built_files))
            print("Wrong number of built files")
            success=0
        else:
            printc(bcolors.OKGREEN, "[xl size]         OK\n")

        projects = []
        for (_, dirnames, _) in walk("./projects"):
            projects.extend(dirnames)
            break

        games = []
        for (_, dirnames, _) in walk("./games"):
            games.extend(dirnames)
            break

        examples = []
        for (_, dirnames, _) in walk("./examples"):
            examples.extend(dirnames)
            break

        #reset
        reset(["","_test_project"])
        printc(bcolors.OKGREEN, "[xl reset]        OK\n")

    #delete
    delete(["delete","_test_project","-y"])
    project_dirs_after_delete = len(dirs_in_path("./projects"))

    if project_dirs_after_delete != initial_dirs:
        printc(bcolors.FAIL,    "[xl delete]       KO\n")
        print(project_dirs_before_create)
        print(project_dirs_after_delete)
        success=0
    else:
        printc(bcolors.OKGREEN, "[xl delete]       OK\n")

    if clean_test()==0:
        success=0

    # build (all examples)
    build(["","examples","stdio"])

    built_files = built_files_in_path("../build")

    if len(built_files)!=len(examples):
        success=0
        printc(bcolors.FAIL, "[xl build]        KO\n")
        print(built_files)
        print(examples)
    else:
        printc(bcolors.OKGREEN, "[xl build]        OK\n")

    if clean_test()==0:
        success=0

    # build (all games)
    # global_vars.verbose = 1
    # global_vars.test = 0
    build(["","games","stdio"])

    built_files = built_files_in_path("../build")

    if len(built_files)!=len(games):
        success=0
        printc(bcolors.FAIL, "[xl build]        KO\n")
        print(built_files)
        print(games)
        sys.exit()
    else:
        printc(bcolors.OKGREEN, "[xl build]        OK\n")

    if clean_test()==0:
        success=0

    printc(bcolors.OKCYAN,"----------------------------------------\n")

    return success


def test_all(params):

    test_compilers()
    # test_make()
    test_tools()
    test_libraries()
    test_interpreters()
    # test_emulators()
    # test_roms()

    unit_tests()
    # print("params: " + str(params))
    return test_self(params)

expected_files = {
    "cc65_extra": 8,
    "z88dk_extra": 5,
    "cmoc_extra": 3,
    "lcc1802_extra": 1,
    "stdio_extra": 1,
    "z88dk_extra_alt": 38
    }


def targets_test(params):

    success = clean_test()
    if params[1].startswith("z88dk_extra"):
        parallel = " -j " + compilation_threads
    else:
        parallel = ""

    game_dir = "chase"
    project_type = "game"
    if is_project_split(game_dir):
        printc(bcolors.OKBLUE,"Create main.c from split source files\n")
        create_main(game_dir, project_type)
    if params[1].endswith("_extra"):
        make_command = GNU_MAKE + parallel + " test_" + params[1] + " " + \
                       " GNU_MAKE=" + GNU_MAKE + " _NATIVE_CC="+ native_compiler + " " + \
                       all_compilers_opts("","") + \
                       " -f makefiles.other/chase/tests/Makefile.tests"
        run_command_verbosely(make_command)
    elif params[1]=="z88dk_extra_alt":
        # parallel = ""
        make_command = GNU_MAKE + parallel + " GNU_MAKE=" + GNU_MAKE + \
                       " z88dk_quick_test -f makefiles.other/chase/tests/Makefile.z88dk_quick_tests"
        run_command_verbosely(make_command)
    else:
        printc(bcolors.FAIL, "Parameter not recognized\n")
        if is_project_split(game_dir):
            print("Delete main.c (because of split source files)\n")
            delete_main(game_dir, project_type)
        sys.exit(-1)
    if is_project_split("chase"):
        printc(bcolors.OKBLUE,"Delete main.c (because of split source files)\n")
        delete_main(game_dir, project_type)


    built_files = len(files_in_path("../build"))-1
    if global_vars.verbose:
        print("Number of built files: " + str(built_files))

    if params[1] in expected_files.keys():
        if global_vars.verbose:
            printc(bcolors.OKCYAN, "Built files: " + str(built_files)+"\n")
            printc(bcolors.OKBLUE, "Expected files: " + str(expected_files[params[1]])+"\n")
        if built_files != expected_files[params[1]]:
            printc(bcolors.FAIL, "binaries KO\n")
            success=0

        else:
            printc(bcolors.OKGREEN, "binaries OK\n")

    # if clean_test()==0:
        # success=0
    return success


def unit_tests():
    printc(bcolors.OKCYAN,"----------------------------------------\n")
    printc(bcolors.OKCYAN, "UNIT-TESTS")
    printc(bcolors.OKCYAN,"\n----------------------------------------\n")

    command_string = "python -t tests/testImport.py"
    run_command_verbosely(command_string)
    printc(bcolors.OKBLUE,"--------------------------------\n")


    command_string = "python -t tests/testTiles.py"
    run_command_verbosely(command_string)
    printc(bcolors.OKBLUE,"--------------------------------\n")

    command_string = "python -t tests/testStrings.py"
    run_command_verbosely(command_string)
    printc(bcolors.OKBLUE,"--------------------------------\n")

    command_string = "python -t tests/testAssets.py"
    run_command_verbosely(command_string)
    printc(bcolors.OKBLUE,"--------------------------------\n")

    command_string = "python -t tests/testParams.py"
    run_command_verbosely(command_string)
    printc(bcolors.OKBLUE,"--------------------------------\n")

    command_string = "python -t tests/testDefaults.py"
    run_command_verbosely(command_string)
    printc(bcolors.OKCYAN,"----------------------------------------\n")

# Self-test xl and native build
def test(params):
    if (len(params)<=1) or ((len(params)==2) and (params[1]=="check")):
        if test_all("stdio"):
            printc(bcolors.OKGREEN, "TEST OK\n")
        else:
            printc(bcolors.FAIL, "TEST KO\n")
        return
    if params[1]=="self":
        if len(params)<3:
            test_self()
        else:
            test_self(params[2])
    elif params[1]=="compilers":
        test_compilers()
    elif params[1]=="tools":
        test_tools()
    elif params[1]=="emulators":
        test_emulators()
    elif params[1]=="cross-compilers" or params[1]=="cross_compilers":
        test_cross_compilers()
    elif params[1]=="native_compilers" or params[1]=="native-compilers":
        test_native_compilers()
    elif params[1]=="libraries":
        test_libraries()
    elif params[1]=="interpreters":
        test_interpreters()
    elif params[1]=="roms":
        test_roms()
    elif params[1]=="make":
        test_make()
    elif params[1] in ("unit-tests", "unit_tests", "unit-test", "unit_test", "u"):
        unit_tests()
    elif params[1].endswith('extra') or params[1].endswith('extra_alt'):
        if targets_test(params):
            printc(bcolors.OKGREEN, "TEST OK\n")
        else:
            printc(bcolors.FAIL, "TEST KO\n")
        return
    else:
        projects = []
        for (_, dirnames, _) in walk("./projects"):
            projects.extend(dirnames)
            break

        games = []
        for (_, dirnames, _) in walk("./games"):
            games.extend(dirnames)
            break

        examples = []
        for (_, dirnames, _) in walk("./examples"):
            examples.extend(dirnames)
            break

        # print(projects + games + examples)
        # quit()
        if params[1] in projects + games + examples or params[1] in \
           ['examples','games','projects','all']:
            # print("KO")
            # quit()
            if len(params)>=3:
                par1 = params[1]
                par2 = params[2]
            else:
                par1 = params[1]
                par2 = "stdio"
            if test_projects(par1,par2):
                printc(bcolors.OKGREEN, "TEST OK\n")
            else:
                printc(bcolors.FAIL, "TEST KO\n")
        else:
            # print("OK")
            # quit()
            test_all(params[1])
        return


# Self-test xl and native build
def check(params):
    if len(params)<=1:
        tools = test_tools()
        # interpreters = test_interpreters()
        native_compilers =test_native_compilers()
        cross_compilers = test_cross_compilers()
        libraries = test_libraries()
        make = test_make()
        emulators = test_emulators()
        roms = test_roms()

        print("")

        printc(bcolors.BOLD, "SUMMARY\n")
        tools = True
        xl_run_cross_target = True
        native_target = True
        cross_target = True


        if not make['make'] and not make['gmake']:
            printc(bcolors.FAIL, "No make command detected!\n")

        if not native_compilers['gcc']:
            tools = False
            native_target = False

        if not native_compilers['g++']:
            xl_run_cross_target = True
            tools = False

        if not libraries['ncurses']:
            printc(bcolors.WARNING, \
                   "No ncurses library detected -> Native target impacted\n")
            native_target = False

        for _, present in cross_compilers.items():
            if not present:
                cross_target = False

        for _, present in emulators.items():
            if not present:
                xl_run_cross_target = False
                break

        for _, present in roms.items():
            if not present:
                xl_run_cross_target = False
                break

        if not tools:
            printc(bcolors.WARNING, "'xl tools' may be KO for some targets\n")

        if not native_target:
            printc(bcolors.WARNING, "'xl build <project>' may be KO (no native build)\n")

        if not cross_target:
            printc(bcolors.WARNING, "'xl build <project> <target>' may be KO for some targets\n")

        if not xl_run_cross_target:
            printc(bcolors.WARNING, "'xl run <project> <target>' may be KO for some targets\n")

        if tools and native_target and xl_run_cross_target and cross_target:
            printc(bcolors.OKCYAN, "No issue found\n")


    elif params[1]=="compilers":
        test_compilers()
    elif params[1]=="tools":
        test_tools()
    elif params[1]=="emulators":
        test_emulators()
    elif params[1]=="cross-compilers" or params[1]=="cross_compilers":
        test_cross_compilers()
    elif params[1]=="native_compilers" or params[1]=="native-compilers":
        test_native_compilers()
    elif params[1]=="libraries":
        test_libraries()
    elif params[1]=="interpreters":
        test_interpreters()
    elif params[1]=="make":
        test_make()
    elif params[1]=="roms":
        test_roms()





# List all projects
def list_projects(params, print_projects=True):

    if len(params)<2:
        project_dirs = ["examples", "games", "projects"]
    elif params[1]=="all":
        project_dirs = ["examples", "games", "projects"]
    elif params[1] in ["games", "examples", "projects"]:
        project_dirs = [params[1]]
    elif params[1] in ["new"]:
        project_dirs = ["projects"]
    elif params[1] in ["built-in", "builtin"]:
        project_dirs = ["games", "examples"]
    else:
        return

    count = 0

    for mypath in project_dirs:
        if print_projects:
            printc(bcolors.BOLD, "["+mypath+"]\n")
        for (_, dirnames, _) in walk(mypath):
            # projects.extend(dirnames)
            for project in dirnames:
                if print_projects:
                    print("  "+str(project))
                count+=1
            break
        if print_projects:
            print("")

    if global_vars.verbose:
        print("Projects found: " + str(count))
        print("")

    return count


def run_native(params, target):

    command_prefix = "../build/X" + params[1] + "_" + target

    if len(params)>=4:
        xsize = params[2]
        ysize = params[3]
        command_string = command_prefix + "_" + xsize + "X" + ysize + "." + NATIVE_EXTENSION
    else:
        command_string = command_prefix + "." + NATIVE_EXTENSION
    run_command_verbosely(command_string)


def run_stdio(params):
    command_prefix = "../build/X" + params[1] + "_stdio"

    if len(params)>=4:
        xsize = params[3]
        ysize = params[4]
        command_string = command_prefix + "_" + xsize + "X" + ysize + "." + NATIVE_EXTENSION
    else:
        command_string = command_prefix + "." + NATIVE_EXTENSION
    run_command_verbosely(command_string)


DEFAULT_TARGET_MAP = {\
                     "vic20":"vic20_exp_16k", \
                     "c16":"c16_16k", \
                     "plus4":"c16_32k", \
                     "pet":"pet_16k", \
                     "msx": "msx_16k" \
                     }

VICE_TARGETS = ["c64",
                "vic20", 
                "vic20_unexpanded", 
                "vic20_exp_3k", 
                "vic20_exp_8k", 
                "vic20_exp_16k",
                "c16", 
                "plus4", 
                "c16_16k", 
                "c16_32k",
                "pet", 
                "pet_8k", 
                "pet_16k"
               ]

MAME_TARGETS = ["msx", "msx_16k"]


# Run a project by using an emulator if necessary. Only few emulators are supported.
def run(params):

    if len(params)==2:
        run_native(params, "ncurses")

    if len(params)>=3:
        params = insert_default_sizes(params)

        target = params[2]
        if target in DEFAULT_TARGET_MAP:
            target = DEFAULT_TARGET_MAP[target]
            if global_vars.verbose:
                print("defaulting to target: " + target)

        if target=="stdio":
            run_stdio(params)
        elif target=="ncurses":
            run_native(params[0:2]+params[3:], "ncurses")
        elif target=="terminal":
            run_native(params[0:2]+params[3:], "terminal8x8")
        elif target.startswith("terminal"):
            run_native(params[0:2]+params[3:], target)

        # e.g. xl run bomber 20 30
        elif(len(params)>=3 and params[2].isnumeric() and params[3].isnumeric()):
            run_native(params, "ncurses")

        # TODO: replace this with a check on prefixes
        elif target in VICE_TARGETS:
            extension = "prg"
            rom_directory = vice_rom_path
            if target=="c64":
                rom_directory += "c64"

                emulator = C64_EMULATOR
            elif target.startswith("vic20"):
                rom_directory += "vic20"

                if target=="vic20_exp_3k":
                    emulator = VIC20_EMULATOR + " -memory 3k"
                elif target=="vic20_unexpanded":
                    emulator = VIC20_EMULATOR + " -memory none"
                else:
                    emulator = VIC20_EMULATOR + " -memory 24k"
            elif target.startswith("c16") or target=="plus4":
                rom_directory += "plus4"

                emulator = PLUS4_EMULATOR
            elif target.startswith("pet"):
                rom_directory += "pet"
                emulator = PET_EMULATOR
            else:
                print("'xl run' does not support this target")
                return
            command_string = vice_path + emulator + " -directory " + \
                             rom_directory + " -autostartprgmode 1  ../build/X" + \
                             params[1] + "_" + target + "." + extension

            run_command_verbosely(command_string)

        elif target in MAME_TARGETS:
            emulator = MAME_EMULATOR

            if target.startswith("msx"):
                extension = "rom"
                mame_sub_target = "canonv20"
                command_string = mame_path + emulator + " " + mame_sub_target + \
                " -rompath " + mame_rom_path + \
                " -window -uimodekey DEL  -skip_gameinfo  -cart1 ../build/X" + \
                params[1] + "_" + target + "." + extension
                run_command_verbosely(command_string)
        else:
            print("'xl run' does not support this target")
            return


# It should be able to import from
# - Assembly files that use byte directives with either decimal and hex notation
# - Assembly files that use word directives with ONLY hex notation
def import_from_source(params, rotate = False):
    filename = params[1]

    rip_option = params[len(params)-1]=="-rip"

    xsize = 8
    ysize = 8

    tiles = rip_tiles(filename, xsize, ysize, rip_option, rotate)

    try:
        if(len(params)>=3) and "-" not in params[2]:
            store_tiles(params[2],tiles, xsize, ysize)
    except Exception as exception:
        print("Sorry! Failed to store tiles: \n" + str(exception.args))


# It should be able to import from
# - Assembly files that use byte directives with either decimal and hex notation
# - Assembly files that use word directives with ONLY hex notation
# - BASIC files that use decimal, hex notation or "headless" hex notation (by guessing)
# Remark: This function is like "import_from_source" with the "-rip" option
def rip(params, rotate = False):
    filename = params[1]

    xsize = 8
    ysize = 8

    tiles = rip_tiles(filename, xsize, ysize, True, rotate)

    try:
        if(len(params)>=3) and "-" not in params[2]:
            store_tiles(params[2],tiles, xsize, ysize)
    except Exception as exception:
        print("Sorry! Failed to store tiles: \n" + str(exception.args))

# Show all generated files
def files():
    make_command = "ls -ls ../build"
    os.system(make_command)


def split(params):

    import_split_tiles(params[1])



# Import a shape as single tile from a text file that describes its shape with characters
def tile(params):

    tile,xsize,ysize = import_tile(params[1])



    if global_vars.verbose:
        print_shape(compute_shape(tile,xsize))

    if len(params)>=3:
        store_tile(params[2], tile, xsize, ysize, params[3])
    else:
        printc(bcolors.OKCYAN, tile+"\n")

# replace_shapes:
# 0 -> write in _shapes directory,
# 1 -> write in shapes directory but avoid overwriting existing shapes or tiles
def write_shapes(project, shapes, xsize,ysize):
    path = path_to_shapes(project,xsize,ysize)
    if not replace_shapes:
        path = path.replace("shapes","_shapes")
    if global_vars.verbose:
        print("Writing shapes in: " + path)
    if os.path.exists(path):
        if global_vars.verbose:
            print("Directory exists")
    else:
        if global_vars.verbose:
            print("Directory does not exist")
        os.makedirs(path)
    for tile_number, shape in shapes.items():
        #print(tile_number,shape)
        path_to_shape = path+"shape"+tile_number+".txt"
        if global_vars.verbose:
            print("Path to shape file: " + path_to_shape)
        path_to_tile = path.replace("shapes","tiles")+"tile"+tile_number+".txt"
        if global_vars.verbose:
            print("Path to tile file: " + path_to_tile)
        if replace_shapes and (os.path.exists(path_to_shape) or \
           os.path.exists(path_to_tile)):
            if os.path.exists(path_to_shape):
                if not global_vars.test:
                    print("shape "+ tile_number +" already exists")
            elif os.path.exists(path_to_tile):
                if not global_vars.test:
                    print("tile "+ tile_number +" already exists")
        else:
            with open(path_to_shape,"w") as file:
                for row in shape:
                    if not global_vars.test:
                        print(row)
                    file.write(row+"\n")
        if global_vars.verbose:
            print("")


# Extand 8x8 shapes by reshaping them into shapes with other dimensions
def extend(params):
    project = params[1]

    path_to_8x8_files = path_to_shapes(project,8,8)
    if global_vars.verbose:
        print("Path to shape files: " + path_to_8x8_files)
        print("")
    shape_files = files_in_path(path_to_8x8_files)

    dict7x8 = {}
    dict6x8 = {}
    dict8x6 = {}
    dict6x9 = {}
    for shape_file in shape_files:
        path_to_shape_file = path_to_8x8_files + "/" + shape_file

        if not global_vars.test:
            print("shape file: " + shape_file)

        tile_number_str = shape_file[5:].replace(".txt","")

        if not global_vars.test:
            print("---tile number: " + tile_number_str)

            print("")

        tile,xsize,ysize = read_shape(path_to_shape_file)
        if xsize!=8 or ysize!=8:
            print("Shape in file " + path_to_shape_file + " has wrong dimensions!")
            print(tile)
            return

        if global_vars.verbose:
            print(tile)

        if not global_vars.test:
            print("")
            print("7x8")
        shape7x8 = convert(tile,7,8,extend_algorithm)
        if not global_vars.test:
            display_shape(shape7x8)
        dict7x8[tile_number_str]=shape7x8

        if not global_vars.test:
            print("")
            print("6x8")
        shape6x8 = convert(tile,6,8,extend_algorithm)
        if not global_vars.test:
            display_shape(shape6x8)
        dict6x8[tile_number_str]=shape6x8

        if not global_vars.test:
            print("")
            print("8x6")
        shape8x6 = convert(tile,8,6,extend_algorithm)
        if not global_vars.test:
            display_shape(shape8x6)
        dict8x6[tile_number_str]=shape8x6

        if not global_vars.test:
            print("")
            print("6x9")
        shape6x9 = convert(tile,6,9,extend_algorithm)
        if not global_vars.test:
            display_shape(shape6x9)
        dict6x9[tile_number_str]=shape6x9
        if not global_vars.test:
            print("")
    # print(str(dict7x8))
    write_shapes(project,dict7x8,7,8)
    write_shapes(project,dict6x8,6,8)
    write_shapes(project,dict8x6,8,6)
    write_shapes(project,dict6x9,6,9)
    return


# Import as tiles all shapes from files named "shape<number>.txt" inside the directories in the "shapes" directory of a given project
def shapes(params):
    project_name = params[1]

    project_cat = project_category(project_name)

    if len(params)>3:   # xsize, ysize parameters
        xsize_str,ysize_str = params[2:]
    elif len(params)==3: # target parameter
        detected_xsize = detect_xsize(params[2])
        detected_ysize = detect_ysize(params[2])
        xsize_str = str(detected_xsize)
        ysize_str = str(detected_ysize)
        # if global_vars.verbose:
            # print("Detected xsize: " + xsize_str)
            # print("Detected ysize: " + ysize_str)
    else:                # no parameter
        xsize_str = "8"
        ysize_str = "8"
    if not global_vars.test:
        print("xsize: " + xsize_str)
        print("ysize: " + ysize_str)
    path_to_files = project_cat + "s/" + params[1] + \
                    "/shapes/" + xsize_str + "x" + ysize_str + "/"
    if not global_vars.test:
        print("Path to shape files: " + path_to_files)
    shape_files = files_in_path(path_to_files)
    if global_vars.verbose:
        print("shape files: ", shape_files)
    for shape_file in shape_files:
        if global_vars.verbose:
            print("processing file: ", shape_file)

        path_to_shape_file = path_to_files + str(shape_file)
        if global_vars.verbose:
            print("processing path file: ", path_to_shape_file)
        tile_number_str = shape_file[5:].replace(".txt","")

        print("tile number: " + tile_number_str)

        tile,xsize,ysize = import_tile(path_to_shape_file)

        if str(xsize)!=xsize_str or str(ysize)!=ysize_str:
            print("Shape in file " + path_to_shape_file + " has wrong dimensions!")
            print(tile)
            return
        print(tile)
        print_shape(compute_shape(tile,xsize))

        store_tile(project_name, tile, xsize, ysize, tile_number_str)

        print("")


# Show tile shapes of a given project
def show(params):
    parent_dir = project_category(params[1])+"s"

    if len(params)<4:
        xsize = "8"
        ysize = "8"
    else:
        xsize = params[2]
        ysize = params[3]

    if len(params)>=5:
        index = params[4]
    else:
        index = ""

    if index!="":
        print_shape_from_file(parent_dir, params[1], xsize, ysize, index)

    else:
        for i in range(NUMBER_OF_TILES):
            print_shape_from_file(parent_dir, params[1], xsize, ysize, i)

# ---------------------------------------------


# ---------------------------------------------
#  System               Value
# ---------------------------------------------
#  Linux                linux or linux2 (*)
#  Windows              win32
#  Windows/Cygwin       cygwin
#  Windows/MSYS2        msys
#  Mac OS X             darwin
#  OS/2                 os2
#  OS/2 EMX             os2emx
#  RiscOS               riscos
#  AtheOS               atheos
#  FreeBSD 7            freebsd7
#  FreeBSD 8            freebsd8
#  FreeBSD N            freebsdN
#  OpenBSD 6            openbsd6
# ---------------------------------------------

def read_config_option(config, section, option):
    if config.has_option(section,option):
        return config.get(section,option)
    return ""

def read_config(config_file="./config.ini"):
    try:
        import configparser
    except ImportError:
        # Python 2.x fallback
        print("Python 2.x configuration")
        import ConfigParser as configparser

    global compilation_threads
    global parallelize_multi_build
    global z88dk_compiler_opts
    global z88dk_compiler
    global sccz80_compiler_opts
    global zsdcc_compiler_opts
    global cmoc_compiler_opts
    global cc65_compiler_opts
    global lcc1802_compiler_opts
    global gcc4ti99_compiler_opts
    global vbcc_compiler_opts
    global native_compiler_opts
    global native_compiler
    global tool_compiler
    global interactive_clean
    global vice_path
    global vice_rom_path
    global mame_path
    global mame_rom_path
    global extend_algorithm
    global replace_shapes
    global use_tools
    
    
    # global config

    config = configparser.ConfigParser()

    try:
        config.read(config_file)

        global_vars.test = read_config_option(config,"terminal","test")
        if global_vars.test!="":
            global_vars.test=int(global_vars.test)
        else:
            global_vars.test=0
        if global_vars.test:
            print("Test Mode ON")

        global_vars.verbose = read_config_option(config,"terminal","verbose")
        if global_vars.verbose!="":
            global_vars.verbose=int(global_vars.verbose)
        else:
            global_vars.verbose=0
        if global_vars.verbose:
            print("----------------------------")
            print("Verbose Mode ON")

        # global color_terminal
        global_vars.color_terminal = read_config_option(config,"terminal","color")

        logger.info("Color terminal: %s", str(global_vars.color_terminal))

        if global_vars.verbose:
            if global_vars.color_terminal:
                printc(bcolors.OKCYAN, "Color terminal ON\n")
            else:
                print("Color terminal OFF")

        if global_vars.verbose:
            print("Config file found with: " + str(config.sections()))
            # print("")

        compilation_threads = read_config_option(config,"build","threads")


        if compilation_threads in ("auto", "automaic"):
            if global_vars.verbose:
                print("----------------------------")
            import multiprocessing
            compilation_threads = str(multiprocessing.cpu_count())
            if global_vars.verbose:
                print("Detected " + compilation_threads + " threads...")
                print("----------------------------")

        logger.info("Compilation threads: %s", str(compilation_threads))

        parallelize_multi_build = read_config_option(config,"build","parallelize_multi_build")
        if parallelize_multi_build!="":
            parallelize_multi_build=int(parallelize_multi_build)
        else:
            parallelize_multi_build=0

        z88dk_compiler_opts = read_config_option(config,"build","z88dk_compiler_opts")
        z88dk_compiler = read_config_option(config,"build","z88dk_compiler")
        sccz80_compiler_opts = read_config_option(config,"build","sccz80_compiler_opts")
        zsdcc_compiler_opts = read_config_option(config,"build","zsdcc_compiler_opts")
        cmoc_compiler_opts = read_config_option(config,"build","cmoc_compiler_opts")
        cc65_compiler_opts = read_config_option(config,"build","cc65_compiler_opts")
        lcc1802_compiler_opts = read_config_option(config,"build","lcc1802_compiler_opts")
        gcc4ti99_compiler_opts = read_config_option(config,"build","gcc4ti99_compiler_opts")
        vbcc_compiler_opts = read_config_option(config,"build","vbcc_compiler_opts")
        native_compiler_opts = read_config_option(config,"build","native_compiler_opts")

        native_compiler = read_config_option(config,"build", "native_compiler")

        tool_compiler = read_config_option(config,"tools", "tool_compiler")

        interactive_clean = read_config_option(config,"clean", "interactive")

        vice_path = read_config_option(config,"run", "vice_path")
        vice_rom_path = read_config_option(config,"run", "vice_rom_path")

        mame_path = read_config_option(config,"run", "mame_path")
        mame_rom_path = read_config_option(config,"run", "mame_rom_path")

        extend_algorithm = read_config_option(config,"extend", "extend_algorithm")

        replace_shapes = read_config_option(config,"extend", "replace_shapes")

        use_tools = read_config_option(config,"build", "use_tools")

        if interactive_clean!="":
            interactive_clean = int(interactive_clean)
        logger.info("Interactive clean: %s", str(interactive_clean))

        if replace_shapes!="":
            replace_shapes = int(replace_shapes)

        if use_tools!="":
            use_tools = int(use_tools)

    except Exception as e:
        print("An exception occurred while reading the configuration: " + str(e))
        logger.debug("Error while reading configuration file")
        raise


def default_config():

    global compilation_threads
    global parallelize_multi_build
    global z88dk_compiler_opts
    global z88dk_compiler
    global sccz80_compiler_opts
    global zsdcc_compiler_opts
    global cmoc_compiler_opts
    global cc65_compiler_opts
    global lcc1802_compiler_opts
    global gcc4ti99_compiler_opts
    global vbcc_compiler_opts
    global native_compiler_opts
    global native_compiler
    global tool_compiler
    global interactive_clean
    global vice_path
    global vice_rom_path
    global mame_path
    global mame_rom_path
    global extend_algorithm
    global replace_shapes
    global use_tools


    global_vars.verbose = True
    compilation_threads = 1
    parallelize_multi_build = 0
    zsdcc_compiler_opts = ""
    sccz80_compiler_opts = ""
    z88dk_compiler_opts = ""
    z88dk_compiler = "sccz80"
    cmoc_compiler_opts = ""
    native_compiler_opts = ""
    native_compiler = "gcc"
    tool_compiler = "gcc"
    cc65_compiler_opts = "-O -Cl"
    lcc1802_compiler_opts = '"-Wf-volatile" -O "-Wp-D nofloats" "-Wa-D LCCNOLONG" "-Wf-mulcall"'
    gcc4ti99_compiler_opts = "-O2"
    vbcc_compiler_opts = "-O1"
    use_tools = 0
    global_vars.color_terminal = 0


def display_config():

    printc(bcolors.BOLD,"[terminal]\n")

    print("verbose: " + str(global_vars.verbose))
    print("test: " + str(global_vars.test))

    print("color: " + str(global_vars.color_terminal))

    print("")

    printc(bcolors.BOLD,"[build]\n")
    print("compilation_threads: " + str(compilation_threads))
    print("parallelize_multi_build: " + str(parallelize_multi_build))

    print("z88dk_compiler: " + z88dk_compiler)
    print("z88dk_compiler_opts: " +  z88dk_compiler_opts)
    print("sccz80_compiler_opts: " + sccz80_compiler_opts)
    print("zsdcc_compiler_opts: " +  zsdcc_compiler_opts)
    print("cmoc_compiler_opts: " +  cmoc_compiler_opts)
    print("cc65_compiler_opts: " +  cc65_compiler_opts)
    print("lcc1802_compiler_opts: " +  lcc1802_compiler_opts)
    print("gcc4ti99_compiler_opts: " +  gcc4ti99_compiler_opts)
    print("vbcc_compiler_opts: " +  vbcc_compiler_opts)
    print("native_compiler_opts: " +  native_compiler_opts)

    print("native_compiler: " +  native_compiler)
    print("tool_compiler: " +  tool_compiler)

    print("")

    printc(bcolors.BOLD,"[clean]\n")
    print("interactive_clean: " + str(interactive_clean))


    print("")
    printc(bcolors.BOLD,"[run]\n")
    print("vice_path: " +  vice_path)
    print("vice_rom_path: " +  vice_rom_path)
    print("mame_path: " +  mame_path)
    print("mame_rom_path: " +  mame_rom_path)

    print("")
    printc(bcolors.BOLD,"[extend]\n")
    print("extend_algorithm: " +  extend_algorithm)
    print("replace_shapes: " +  str(replace_shapes))

    print("")
    printc(bcolors.BOLD,"[tools]\n")
    print("use_tools: " + str(use_tools))


def make_assets_from_tiles(params):

    game_dir = params[1]

    project_type = project_category(game_dir)
    parent_dir = project_type + "s"

    run_command_verbosely(GNU_MAKE+" GAME_NAME=" + game_dir + \
                          " PARENT_DIR=" + parent_dir + \
                          " -f ./makefiles.common/auxiliary/Makefile_assets")


# ---------------------------------------------


if __name__ == "__main__":

    make_test = test_make(False)

    if make_test['gmake']:
        GNU_MAKE = "gmake"
    else:
        # print(make_test['make'])
        GNU_MAKE = "make"

    if python_version<2 or (python_version<=2 and python_subversion<7):
        print("Python version not supported")
        logger.error("Python version not supported")
        sys.exit(-1)
    try:
        logger.info("(read_config) Read configuration file")
        read_config()
        logger.info("(read_config) Configuration file read")
    except:
        logger.warning("Reverting to default configuration")
        default_config()
        print("WARNING: Using default config")

    if parallelize_multi_build:
        logger.info("Parallelize_multi_build is ON")
        from multiprocessing import Pool
    else:
        logger.info("Parallelize_multi_build is OFF")

    if global_vars.verbose:
        logger.info("Verbose mode ON")
        print("----------------------------")
        printc(bcolors.OKGREEN, "Cross-Lib `xl` helper script\n")
        print("----------------------------")
        print("Platform: " + platform)
        print("Python:   " + str(python_version) + "." + str(python_subversion))
        logger.info("Using Python version %s.%s", str(python_version), str(python_subversion))

        print("GNU MAKE command: " + GNU_MAKE)
        print("----------------------------")
        print("")


    if len(sys.argv)<2:
        logger.info("Interactive mode ON")
        print("For more commands, use the non-interactive mode.")
        printc(bcolors.BOLD, "xl help")
        print(" for instructions.")

        print("")
        print("--------------------------------------------------")
        printc(bcolors.OKCYAN, "Interactive mode\n")
        print("--------------------------------------------------")
        print("")

        project_name = generic_input("Insert project to build\n")

        if project_name in ("", "\n"):
            project_name="helloworld"
            if global_vars.verbose:
                printc(bcolors.WARNING,"Defaulting to helloworld\n")

        print("")

        target_name = generic_input("Insert target name\n")
        if target_name in ("", "\n"):
            target_name="ncurses"
            if global_vars.verbose:
                printc(bcolors.WARNING, "Defaulting to ncurses\n")

        print("")
        time.sleep(1)

        params = ["rebuild", project_name, target_name]
    else:
        logger.info("Interactive mode OFF")
        params = sys.argv
        params = handle_two_letter_params(params)

        params = full_params(params)

    command_name = "build" if params[1] in list_of_projects("all") + \
                   ["examples"] + ["games"] + ["projects"] + ["all"] else params[1]
                   
    logger.info("Command : %s", command_name)
    if params[1]=="run":
        run(params[1:])
    elif params[1]=="check":
        check(params[1:])
    elif params[1]=="compilers":
        test(["test","compilers"])
    elif params[1]=="unit-tests":
        test(["test","unit-tests"])
    elif params[1]=="self":
        if len(params)<3:
            test_self()
        else:
            test_self(params[2])
    elif params[1]=="assets":
        shapes(params[1:])
        make_assets_from_tiles(params[1:])
    elif params[1]=="split":
        split(params[1:])
    elif params[1]=="config":
        display_config()
    elif params[1]=="string":
        string(params[1:])
    elif params[1]=="commands":
        commands()
    elif params[1]=="import":
        import_from_source(params[1:],False)
    elif params[1]=="rotate":
        rip(params[1:],True)
    elif params[1]=="rip":
        rip(params[1:],False)
    elif params[1]=="rebuild":
        rebuild(params[1:])
    elif params[1]=="make":
        shapes(params[1:])
        rebuild(params[1:])
    elif params[1]=="rename":
        rename(params[1:])
    elif params[1]=="clone":
        clone(params[1:])
    elif params[1]=="show":
        show(params[1:])
    elif params[1]=="test":
        test(params[1:])
    elif params[1]=="tile":
        tile(params[1:])
    elif params[1]=="shapes":
        shapes(params[1:])
    elif params[1]=="extend":
        extend(params[1:])
    elif params[1]=="build":
        build(params[1:])
    elif params[1]=="manual":
        manual(params[1:])
    elif params[1]=="files":
        files()
    elif params[1]=="size":
        size(params[1:],0)
    elif params[1]=="debug":
        size(params[1:],1)
    elif params[1]=="create":
        create(params[1:])
    elif params[1]=="clean":
        if interactive_clean:
            clean(params[1:])
        else:
            clean(params[1:]+["-y"])
    elif params[1]=="reset":
        reset(params[1:])
    elif params[1]=="delete":
        delete(params[1:])
    elif params[1]=="list":
        list_projects(params[1:])
    elif params[1]=="help":
        help_command(params[1:])
    elif params[1]=="tools":
        tools()
    elif params[1]=="slow":
        slow(params[1:])
    elif params[1] in list_of_projects("all") + \
                      ["examples"] + ["games"] + ["projects"] + ["all"]:
        build(params)
    else:
        manual(params)

    logger.info('Finished')

    os.system('mv ../logs/log.log ../logs/log_' + \
              datetime.datetime.now().strftime("%Y-%m-%d_%H_%M_%S")+'.log 2>/dev/null' )
